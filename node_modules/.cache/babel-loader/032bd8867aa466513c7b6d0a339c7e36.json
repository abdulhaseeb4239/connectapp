{"ast":null,"code":"import { Buffer } from '@stacks/common';\nimport { getCryptoLib } from './cryptoUtils';\nexport class NodeCryptoAesCipher {\n  constructor(createCipher, createDecipher) {\n    this.createCipher = createCipher;\n    this.createDecipher = createDecipher;\n  }\n\n  async encrypt(algorithm, key, iv, data) {\n    if (algorithm !== 'aes-128-cbc' && algorithm !== 'aes-256-cbc') {\n      throw new Error(`Unsupported cipher algorithm \"${algorithm}\"`);\n    }\n\n    const cipher = this.createCipher(algorithm, key, iv);\n    const result = Buffer.concat([cipher.update(data), cipher.final()]);\n    return Promise.resolve(result);\n  }\n\n  async decrypt(algorithm, key, iv, data) {\n    if (algorithm !== 'aes-128-cbc' && algorithm !== 'aes-256-cbc') {\n      throw new Error(`Unsupported cipher algorithm \"${algorithm}\"`);\n    }\n\n    const cipher = this.createDecipher(algorithm, key, iv);\n    const result = Buffer.concat([cipher.update(data), cipher.final()]);\n    return Promise.resolve(result);\n  }\n\n}\nexport class WebCryptoAesCipher {\n  constructor(subtleCrypto) {\n    this.subtleCrypto = subtleCrypto;\n  }\n\n  async encrypt(algorithm, key, iv, data) {\n    let algo;\n    let length;\n\n    if (algorithm === 'aes-128-cbc') {\n      algo = 'AES-CBC';\n      length = 128;\n    } else if (algorithm === 'aes-256-cbc') {\n      algo = 'AES-CBC';\n      length = 256;\n    } else {\n      throw new Error(`Unsupported cipher algorithm \"${algorithm}\"`);\n    }\n\n    const cryptoKey = await this.subtleCrypto.importKey('raw', key, {\n      name: algo,\n      length\n    }, false, ['encrypt']);\n    const result = await this.subtleCrypto.encrypt({\n      name: algo,\n      iv\n    }, cryptoKey, data);\n    return Buffer.from(result);\n  }\n\n  async decrypt(algorithm, key, iv, data) {\n    let algo;\n    let length;\n\n    if (algorithm === 'aes-128-cbc') {\n      algo = 'AES-CBC';\n      length = 128;\n    } else if (algorithm === 'aes-256-cbc') {\n      algo = 'AES-CBC';\n      length = 256;\n    } else {\n      throw new Error(`Unsupported cipher algorithm \"${algorithm}\"`);\n    }\n\n    const cryptoKey = await this.subtleCrypto.importKey('raw', key, {\n      name: algo,\n      length\n    }, false, ['decrypt']);\n    const result = await this.subtleCrypto.decrypt({\n      name: algo,\n      iv\n    }, cryptoKey, data);\n    return Buffer.from(result);\n  }\n\n}\nexport async function createCipher() {\n  const cryptoLib = await getCryptoLib();\n\n  if (cryptoLib.name === 'subtleCrypto') {\n    return new WebCryptoAesCipher(cryptoLib.lib);\n  } else {\n    return new NodeCryptoAesCipher(cryptoLib.lib.createCipheriv, cryptoLib.lib.createDecipheriv);\n  }\n}","map":{"version":3,"sources":["../../src/aesCipher.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Buffer } from '@stacks/common';\nimport { getCryptoLib } from './cryptoUtils';\nexport class NodeCryptoAesCipher {\n    constructor(createCipher, createDecipher) {\n        this.createCipher = createCipher;\n        this.createDecipher = createDecipher;\n    }\n    async encrypt(algorithm, key, iv, data) {\n        if (algorithm !== 'aes-128-cbc' && algorithm !== 'aes-256-cbc') {\n            throw new Error(`Unsupported cipher algorithm \"${algorithm}\"`);\n        }\n        const cipher = this.createCipher(algorithm, key, iv);\n        const result = Buffer.concat([cipher.update(data), cipher.final()]);\n        return Promise.resolve(result);\n    }\n    async decrypt(algorithm, key, iv, data) {\n        if (algorithm !== 'aes-128-cbc' && algorithm !== 'aes-256-cbc') {\n            throw new Error(`Unsupported cipher algorithm \"${algorithm}\"`);\n        }\n        const cipher = this.createDecipher(algorithm, key, iv);\n        const result = Buffer.concat([cipher.update(data), cipher.final()]);\n        return Promise.resolve(result);\n    }\n}\nexport class WebCryptoAesCipher {\n    constructor(subtleCrypto) {\n        this.subtleCrypto = subtleCrypto;\n    }\n    async encrypt(algorithm, key, iv, data) {\n        let algo;\n        let length;\n        if (algorithm === 'aes-128-cbc') {\n            algo = 'AES-CBC';\n            length = 128;\n        }\n        else if (algorithm === 'aes-256-cbc') {\n            algo = 'AES-CBC';\n            length = 256;\n        }\n        else {\n            throw new Error(`Unsupported cipher algorithm \"${algorithm}\"`);\n        }\n        const cryptoKey = await this.subtleCrypto.importKey('raw', key, { name: algo, length }, false, [\n            'encrypt',\n        ]);\n        const result = await this.subtleCrypto.encrypt({ name: algo, iv }, cryptoKey, data);\n        return Buffer.from(result);\n    }\n    async decrypt(algorithm, key, iv, data) {\n        let algo;\n        let length;\n        if (algorithm === 'aes-128-cbc') {\n            algo = 'AES-CBC';\n            length = 128;\n        }\n        else if (algorithm === 'aes-256-cbc') {\n            algo = 'AES-CBC';\n            length = 256;\n        }\n        else {\n            throw new Error(`Unsupported cipher algorithm \"${algorithm}\"`);\n        }\n        const cryptoKey = await this.subtleCrypto.importKey('raw', key, { name: algo, length }, false, [\n            'decrypt',\n        ]);\n        const result = await this.subtleCrypto.decrypt({ name: algo, iv }, cryptoKey, data);\n        return Buffer.from(result);\n    }\n}\nexport async function createCipher() {\n    const cryptoLib = await getCryptoLib();\n    if (cryptoLib.name === 'subtleCrypto') {\n        return new WebCryptoAesCipher(cryptoLib.lib);\n    }\n    else {\n        return new NodeCryptoAesCipher(cryptoLib.lib.createCipheriv, cryptoLib.lib.createDecipheriv);\n    }\n}\n//# sourceMappingURL=aesCipher.js.map"]},"metadata":{},"sourceType":"module"}