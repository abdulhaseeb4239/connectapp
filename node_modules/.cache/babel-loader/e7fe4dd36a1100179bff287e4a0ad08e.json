{"ast":null,"code":"import { Buffer } from '@stacks/common';\nimport { serializeAddress, serializeLPString, createLPString } from '../types';\nimport { ClarityType } from '.';\nimport { BufferArray } from '../utils';\nimport { SerializationError } from '../errors';\nimport { CLARITY_INT_BYTE_SIZE, CLARITY_INT_SIZE } from '../constants';\nimport BN from 'bn.js';\n\nfunction bufferWithTypeID(typeId, buffer) {\n  const id = Buffer.from([typeId]);\n  return Buffer.concat([id, buffer]);\n}\n\nfunction serializeBoolCV(value) {\n  return Buffer.from([value.type]);\n}\n\nfunction serializeOptionalCV(cv) {\n  if (cv.type === ClarityType.OptionalNone) {\n    return Buffer.from([cv.type]);\n  } else {\n    return bufferWithTypeID(cv.type, serializeCV(cv.value));\n  }\n}\n\nfunction serializeBufferCV(cv) {\n  const length = Buffer.alloc(4);\n  length.writeUInt32BE(cv.buffer.length, 0);\n  return bufferWithTypeID(cv.type, Buffer.concat([length, cv.buffer]));\n}\n\nfunction serializeIntCV(cv) {\n  const buffer = new BN(cv.value.toString()).toTwos(CLARITY_INT_SIZE).toArrayLike(Buffer, 'be', CLARITY_INT_BYTE_SIZE);\n  return bufferWithTypeID(cv.type, buffer);\n}\n\nfunction serializeUIntCV(cv) {\n  const buffer = new BN(cv.value.toString()).toArrayLike(Buffer, 'be', CLARITY_INT_BYTE_SIZE);\n  return bufferWithTypeID(cv.type, buffer);\n}\n\nfunction serializeStandardPrincipalCV(cv) {\n  return bufferWithTypeID(cv.type, serializeAddress(cv.address));\n}\n\nfunction serializeContractPrincipalCV(cv) {\n  return bufferWithTypeID(cv.type, Buffer.concat([serializeAddress(cv.address), serializeLPString(cv.contractName)]));\n}\n\nfunction serializeResponseCV(cv) {\n  return bufferWithTypeID(cv.type, serializeCV(cv.value));\n}\n\nfunction serializeListCV(cv) {\n  const buffers = new BufferArray();\n  const length = Buffer.alloc(4);\n  length.writeUInt32BE(cv.list.length, 0);\n  buffers.push(length);\n\n  for (const value of cv.list) {\n    const serializedValue = serializeCV(value);\n    buffers.push(serializedValue);\n  }\n\n  return bufferWithTypeID(cv.type, buffers.concatBuffer());\n}\n\nfunction serializeTupleCV(cv) {\n  const buffers = new BufferArray();\n  const length = Buffer.alloc(4);\n  length.writeUInt32BE(Object.keys(cv.data).length, 0);\n  buffers.push(length);\n  const lexicographicOrder = Object.keys(cv.data).sort((a, b) => {\n    const bufA = Buffer.from(a);\n    const bufB = Buffer.from(b);\n    return bufA.compare(bufB);\n  });\n\n  for (const key of lexicographicOrder) {\n    const nameWithLength = createLPString(key);\n    buffers.push(serializeLPString(nameWithLength));\n    const serializedValue = serializeCV(cv.data[key]);\n    buffers.push(serializedValue);\n  }\n\n  return bufferWithTypeID(cv.type, buffers.concatBuffer());\n}\n\nfunction serializeStringCV(cv, encoding) {\n  const buffers = new BufferArray();\n  const str = Buffer.from(cv.data, encoding);\n  const len = Buffer.alloc(4);\n  len.writeUInt32BE(str.length, 0);\n  buffers.push(len);\n  buffers.push(str);\n  return bufferWithTypeID(cv.type, buffers.concatBuffer());\n}\n\nfunction serializeStringAsciiCV(cv) {\n  return serializeStringCV(cv, 'ascii');\n}\n\nfunction serializeStringUtf8CV(cv) {\n  return serializeStringCV(cv, 'utf8');\n}\n\nexport function serializeCV(value) {\n  switch (value.type) {\n    case ClarityType.BoolTrue:\n    case ClarityType.BoolFalse:\n      return serializeBoolCV(value);\n\n    case ClarityType.OptionalNone:\n    case ClarityType.OptionalSome:\n      return serializeOptionalCV(value);\n\n    case ClarityType.Buffer:\n      return serializeBufferCV(value);\n\n    case ClarityType.UInt:\n      return serializeUIntCV(value);\n\n    case ClarityType.Int:\n      return serializeIntCV(value);\n\n    case ClarityType.PrincipalStandard:\n      return serializeStandardPrincipalCV(value);\n\n    case ClarityType.PrincipalContract:\n      return serializeContractPrincipalCV(value);\n\n    case ClarityType.ResponseOk:\n    case ClarityType.ResponseErr:\n      return serializeResponseCV(value);\n\n    case ClarityType.List:\n      return serializeListCV(value);\n\n    case ClarityType.Tuple:\n      return serializeTupleCV(value);\n\n    case ClarityType.StringASCII:\n      return serializeStringAsciiCV(value);\n\n    case ClarityType.StringUTF8:\n      return serializeStringUtf8CV(value);\n\n    default:\n      throw new SerializationError('Unable to serialize. Invalid Clarity Value.');\n  }\n}","map":{"version":3,"sources":["../../../src/clarity/serialize.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Buffer } from '@stacks/common';\nimport { serializeAddress, serializeLPString, createLPString } from '../types';\nimport { ClarityType, } from '.';\nimport { BufferArray } from '../utils';\nimport { SerializationError } from '../errors';\nimport { CLARITY_INT_BYTE_SIZE, CLARITY_INT_SIZE } from '../constants';\nimport BN from 'bn.js';\nfunction bufferWithTypeID(typeId, buffer) {\n    const id = Buffer.from([typeId]);\n    return Buffer.concat([id, buffer]);\n}\nfunction serializeBoolCV(value) {\n    return Buffer.from([value.type]);\n}\nfunction serializeOptionalCV(cv) {\n    if (cv.type === ClarityType.OptionalNone) {\n        return Buffer.from([cv.type]);\n    }\n    else {\n        return bufferWithTypeID(cv.type, serializeCV(cv.value));\n    }\n}\nfunction serializeBufferCV(cv) {\n    const length = Buffer.alloc(4);\n    length.writeUInt32BE(cv.buffer.length, 0);\n    return bufferWithTypeID(cv.type, Buffer.concat([length, cv.buffer]));\n}\nfunction serializeIntCV(cv) {\n    const buffer = new BN(cv.value.toString())\n        .toTwos(CLARITY_INT_SIZE)\n        .toArrayLike(Buffer, 'be', CLARITY_INT_BYTE_SIZE);\n    return bufferWithTypeID(cv.type, buffer);\n}\nfunction serializeUIntCV(cv) {\n    const buffer = new BN(cv.value.toString()).toArrayLike(Buffer, 'be', CLARITY_INT_BYTE_SIZE);\n    return bufferWithTypeID(cv.type, buffer);\n}\nfunction serializeStandardPrincipalCV(cv) {\n    return bufferWithTypeID(cv.type, serializeAddress(cv.address));\n}\nfunction serializeContractPrincipalCV(cv) {\n    return bufferWithTypeID(cv.type, Buffer.concat([serializeAddress(cv.address), serializeLPString(cv.contractName)]));\n}\nfunction serializeResponseCV(cv) {\n    return bufferWithTypeID(cv.type, serializeCV(cv.value));\n}\nfunction serializeListCV(cv) {\n    const buffers = new BufferArray();\n    const length = Buffer.alloc(4);\n    length.writeUInt32BE(cv.list.length, 0);\n    buffers.push(length);\n    for (const value of cv.list) {\n        const serializedValue = serializeCV(value);\n        buffers.push(serializedValue);\n    }\n    return bufferWithTypeID(cv.type, buffers.concatBuffer());\n}\nfunction serializeTupleCV(cv) {\n    const buffers = new BufferArray();\n    const length = Buffer.alloc(4);\n    length.writeUInt32BE(Object.keys(cv.data).length, 0);\n    buffers.push(length);\n    const lexicographicOrder = Object.keys(cv.data).sort((a, b) => {\n        const bufA = Buffer.from(a);\n        const bufB = Buffer.from(b);\n        return bufA.compare(bufB);\n    });\n    for (const key of lexicographicOrder) {\n        const nameWithLength = createLPString(key);\n        buffers.push(serializeLPString(nameWithLength));\n        const serializedValue = serializeCV(cv.data[key]);\n        buffers.push(serializedValue);\n    }\n    return bufferWithTypeID(cv.type, buffers.concatBuffer());\n}\nfunction serializeStringCV(cv, encoding) {\n    const buffers = new BufferArray();\n    const str = Buffer.from(cv.data, encoding);\n    const len = Buffer.alloc(4);\n    len.writeUInt32BE(str.length, 0);\n    buffers.push(len);\n    buffers.push(str);\n    return bufferWithTypeID(cv.type, buffers.concatBuffer());\n}\nfunction serializeStringAsciiCV(cv) {\n    return serializeStringCV(cv, 'ascii');\n}\nfunction serializeStringUtf8CV(cv) {\n    return serializeStringCV(cv, 'utf8');\n}\nexport function serializeCV(value) {\n    switch (value.type) {\n        case ClarityType.BoolTrue:\n        case ClarityType.BoolFalse:\n            return serializeBoolCV(value);\n        case ClarityType.OptionalNone:\n        case ClarityType.OptionalSome:\n            return serializeOptionalCV(value);\n        case ClarityType.Buffer:\n            return serializeBufferCV(value);\n        case ClarityType.UInt:\n            return serializeUIntCV(value);\n        case ClarityType.Int:\n            return serializeIntCV(value);\n        case ClarityType.PrincipalStandard:\n            return serializeStandardPrincipalCV(value);\n        case ClarityType.PrincipalContract:\n            return serializeContractPrincipalCV(value);\n        case ClarityType.ResponseOk:\n        case ClarityType.ResponseErr:\n            return serializeResponseCV(value);\n        case ClarityType.List:\n            return serializeListCV(value);\n        case ClarityType.Tuple:\n            return serializeTupleCV(value);\n        case ClarityType.StringASCII:\n            return serializeStringAsciiCV(value);\n        case ClarityType.StringUTF8:\n            return serializeStringUtf8CV(value);\n        default:\n            throw new SerializationError('Unable to serialize. Invalid Clarity Value.');\n    }\n}\n//# sourceMappingURL=serialize.js.map"]},"metadata":{},"sourceType":"module"}