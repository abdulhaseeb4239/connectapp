{"ast":null,"code":"import { Buffer } from '@stacks/common';\nimport { encryptECIES, decryptECIES, signECDSA } from './ec';\nimport { getPublicKeyFromPrivate } from './keys';\nexport async function encryptContent(content, options) {\n  const opts = Object.assign({}, options);\n  let privateKey;\n\n  if (!opts.publicKey) {\n    if (!opts.privateKey) {\n      throw new Error('Either public key or private key must be supplied for encryption.');\n    }\n\n    opts.publicKey = getPublicKeyFromPrivate(opts.privateKey);\n  }\n\n  let wasString;\n\n  if (typeof opts.wasString === 'boolean') {\n    wasString = opts.wasString;\n  } else {\n    wasString = typeof content === 'string';\n  }\n\n  const contentBuffer = typeof content === 'string' ? Buffer.from(content) : content;\n  const cipherObject = await encryptECIES(opts.publicKey, contentBuffer, wasString, opts.cipherTextEncoding);\n  let cipherPayload = JSON.stringify(cipherObject);\n\n  if (opts.sign) {\n    if (typeof opts.sign === 'string') {\n      privateKey = opts.sign;\n    } else if (!privateKey) {\n      privateKey = opts.privateKey;\n    }\n\n    const signatureObject = signECDSA(privateKey, cipherPayload);\n    const signedCipherObject = {\n      signature: signatureObject.signature,\n      publicKey: signatureObject.publicKey,\n      cipherText: cipherPayload\n    };\n    cipherPayload = JSON.stringify(signedCipherObject);\n  }\n\n  return cipherPayload;\n}\nexport function decryptContent(content, options) {\n  const opts = Object.assign({}, options);\n\n  if (!opts.privateKey) {\n    throw new Error('Private key is required for decryption.');\n  }\n\n  try {\n    const cipherObject = JSON.parse(content);\n    return decryptECIES(opts.privateKey, cipherObject);\n  } catch (err) {\n    if (err instanceof SyntaxError) {\n      throw new Error('Failed to parse encrypted content JSON. The content may not ' + 'be encrypted. If using getFile, try passing { decrypt: false }.');\n    } else {\n      throw err;\n    }\n  }\n}","map":{"version":3,"sources":["../../src/encryption.ts"],"names":[],"mappings":"AAAA,SAAS,MAAT,QAAuB,gBAAvB;AACA,SAGE,YAHF,EAIE,YAJF,EAKE,SALF,QAMO,MANP;AAQA,SAAS,uBAAT,QAAwC,QAAxC;AAiDA,OAAO,eAAe,cAAf,CACL,OADK,EAEL,OAFK,EAE0B;AAE/B,QAAM,IAAI,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,OAAlB,CAAb;AACA,MAAI,UAAJ;;AACA,MAAI,CAAC,IAAI,CAAC,SAAV,EAAqB;AACnB,QAAI,CAAC,IAAI,CAAC,UAAV,EAAsB;AACpB,YAAM,IAAI,KAAJ,CAAU,mEAAV,CAAN;AACD;;AACD,IAAA,IAAI,CAAC,SAAL,GAAiB,uBAAuB,CAAC,IAAI,CAAC,UAAN,CAAxC;AACD;;AACD,MAAI,SAAJ;;AACA,MAAI,OAAO,IAAI,CAAC,SAAZ,KAA0B,SAA9B,EAAyC;AACvC,IAAA,SAAS,GAAG,IAAI,CAAC,SAAjB;AACD,GAFD,MAEO;AACL,IAAA,SAAS,GAAG,OAAO,OAAP,KAAmB,QAA/B;AACD;;AACD,QAAM,aAAa,GAAG,OAAO,OAAP,KAAmB,QAAnB,GAA8B,MAAM,CAAC,IAAP,CAAY,OAAZ,CAA9B,GAAqD,OAA3E;AACA,QAAM,YAAY,GAAG,MAAM,YAAY,CACrC,IAAI,CAAC,SADgC,EAErC,aAFqC,EAGrC,SAHqC,EAIrC,IAAI,CAAC,kBAJgC,CAAvC;AAMA,MAAI,aAAa,GAAG,IAAI,CAAC,SAAL,CAAe,YAAf,CAApB;;AACA,MAAI,IAAI,CAAC,IAAT,EAAe;AACb,QAAI,OAAO,IAAI,CAAC,IAAZ,KAAqB,QAAzB,EAAmC;AACjC,MAAA,UAAU,GAAG,IAAI,CAAC,IAAlB;AACD,KAFD,MAEO,IAAI,CAAC,UAAL,EAAiB;AACtB,MAAA,UAAU,GAAG,IAAI,CAAC,UAAlB;AACD;;AACD,UAAM,eAAe,GAAG,SAAS,CAAC,UAAD,EAAc,aAAd,CAAjC;AACA,UAAM,kBAAkB,GAAuB;AAC7C,MAAA,SAAS,EAAE,eAAe,CAAC,SADkB;AAE7C,MAAA,SAAS,EAAE,eAAe,CAAC,SAFkB;AAG7C,MAAA,UAAU,EAAE;AAHiC,KAA/C;AAKA,IAAA,aAAa,GAAG,IAAI,CAAC,SAAL,CAAe,kBAAf,CAAhB;AACD;;AACD,SAAO,aAAP;AACD;AAWD,OAAM,SAAU,cAAV,CACJ,OADI,EAEJ,OAFI,EAIH;AAED,QAAM,IAAI,GAAG,MAAM,CAAC,MAAP,CAAc,EAAd,EAAkB,OAAlB,CAAb;;AACA,MAAI,CAAC,IAAI,CAAC,UAAV,EAAsB;AACpB,UAAM,IAAI,KAAJ,CAAU,yCAAV,CAAN;AACD;;AAED,MAAI;AACF,UAAM,YAAY,GAAG,IAAI,CAAC,KAAL,CAAW,OAAX,CAArB;AACA,WAAO,YAAY,CAAC,IAAI,CAAC,UAAN,EAAkB,YAAlB,CAAnB;AACD,GAHD,CAGE,OAAO,GAAP,EAAY;AACZ,QAAI,GAAG,YAAY,WAAnB,EAAgC;AAC9B,YAAM,IAAI,KAAJ,CACJ,iEACE,iEAFE,CAAN;AAID,KALD,MAKO;AACL,YAAM,GAAN;AACD;AACF;AACF","sourceRoot":"","sourcesContent":["import { Buffer } from '@stacks/common';\nimport { encryptECIES, decryptECIES, signECDSA, } from './ec';\nimport { getPublicKeyFromPrivate } from './keys';\nexport async function encryptContent(content, options) {\n    const opts = Object.assign({}, options);\n    let privateKey;\n    if (!opts.publicKey) {\n        if (!opts.privateKey) {\n            throw new Error('Either public key or private key must be supplied for encryption.');\n        }\n        opts.publicKey = getPublicKeyFromPrivate(opts.privateKey);\n    }\n    let wasString;\n    if (typeof opts.wasString === 'boolean') {\n        wasString = opts.wasString;\n    }\n    else {\n        wasString = typeof content === 'string';\n    }\n    const contentBuffer = typeof content === 'string' ? Buffer.from(content) : content;\n    const cipherObject = await encryptECIES(opts.publicKey, contentBuffer, wasString, opts.cipherTextEncoding);\n    let cipherPayload = JSON.stringify(cipherObject);\n    if (opts.sign) {\n        if (typeof opts.sign === 'string') {\n            privateKey = opts.sign;\n        }\n        else if (!privateKey) {\n            privateKey = opts.privateKey;\n        }\n        const signatureObject = signECDSA(privateKey, cipherPayload);\n        const signedCipherObject = {\n            signature: signatureObject.signature,\n            publicKey: signatureObject.publicKey,\n            cipherText: cipherPayload,\n        };\n        cipherPayload = JSON.stringify(signedCipherObject);\n    }\n    return cipherPayload;\n}\nexport function decryptContent(content, options) {\n    const opts = Object.assign({}, options);\n    if (!opts.privateKey) {\n        throw new Error('Private key is required for decryption.');\n    }\n    try {\n        const cipherObject = JSON.parse(content);\n        return decryptECIES(opts.privateKey, cipherObject);\n    }\n    catch (err) {\n        if (err instanceof SyntaxError) {\n            throw new Error('Failed to parse encrypted content JSON. The content may not ' +\n                'be encrypted. If using getFile, try passing { decrypt: false }.');\n        }\n        else {\n            throw err;\n        }\n    }\n}\n//# sourceMappingURL=encryption.js.map"]},"metadata":{},"sourceType":"module"}