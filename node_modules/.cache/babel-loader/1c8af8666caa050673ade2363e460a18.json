{"ast":null,"code":"import { AppConfig } from './appConfig';\nimport { InstanceDataStore, LocalStorageStore } from './sessionStore';\nimport { decodeToken } from 'jsontokens';\nimport { verifyAuthResponse } from './verification';\nimport * as authMessages from './messages';\nimport { decryptContent, encryptContent, hexStringToECPair } from '@stacks/encryption';\nimport { getAddressFromDID } from './dids';\nimport { BLOCKSTACK_DEFAULT_GAIA_HUB_URL, fetchPrivate, getGlobalObject, InvalidStateError, isLaterVersion, Logger, LoginFailedError, MissingParameterError, nextHour } from '@stacks/common';\nimport { extractProfile } from '@stacks/profile';\nimport { DEFAULT_PROFILE, NAME_LOOKUP_PATH } from './constants';\nimport * as queryString from 'query-string';\nimport { StacksMainnet } from '@stacks/network';\nimport { protocolEchoReplyDetection } from './protocolEchoDetection';\nexport class UserSession {\n  constructor(options) {\n    let runningInBrowser = true;\n\n    if (typeof window === 'undefined' && typeof self === 'undefined') {\n      runningInBrowser = false;\n    }\n\n    if (options && options.appConfig) {\n      this.appConfig = options.appConfig;\n    } else if (runningInBrowser) {\n      this.appConfig = new AppConfig();\n    } else {\n      throw new MissingParameterError('You need to specify options.appConfig');\n    }\n\n    if (options && options.sessionStore) {\n      this.store = options.sessionStore;\n    } else if (runningInBrowser) {\n      if (options) {\n        this.store = new LocalStorageStore(options.sessionOptions);\n      } else {\n        this.store = new LocalStorageStore();\n      }\n    } else if (options) {\n      this.store = new InstanceDataStore(options.sessionOptions);\n    } else {\n      this.store = new InstanceDataStore();\n    }\n  }\n\n  makeAuthRequest(transitKey, redirectURI, manifestURI, scopes, appDomain, expiresAt = nextHour().getTime(), extraParams = {}) {\n    const appConfig = this.appConfig;\n\n    if (!appConfig) {\n      throw new InvalidStateError('Missing AppConfig');\n    }\n\n    transitKey = transitKey || this.generateAndStoreTransitKey();\n    redirectURI = redirectURI || appConfig.redirectURI();\n    manifestURI = manifestURI || appConfig.manifestURI();\n    scopes = scopes || appConfig.scopes;\n    appDomain = appDomain || appConfig.appDomain;\n    return authMessages.makeAuthRequest(transitKey, redirectURI, manifestURI, scopes, appDomain, expiresAt, extraParams);\n  }\n\n  generateAndStoreTransitKey() {\n    const sessionData = this.store.getSessionData();\n    const transitKey = authMessages.generateTransitKey();\n    sessionData.transitKey = transitKey;\n    this.store.setSessionData(sessionData);\n    return transitKey;\n  }\n\n  getAuthResponseToken() {\n    var _a;\n\n    const search = (_a = getGlobalObject('location', {\n      throwIfUnavailable: true,\n      usageDesc: 'getAuthResponseToken'\n    })) === null || _a === void 0 ? void 0 : _a.search;\n\n    if (search) {\n      const queryDict = queryString.parse(search);\n      return queryDict.authResponse ? queryDict.authResponse : '';\n    }\n\n    return '';\n  }\n\n  isSignInPending() {\n    try {\n      const isProtocolEcho = protocolEchoReplyDetection();\n\n      if (isProtocolEcho) {\n        Logger.info('protocolEchoReply detected from isSignInPending call, the page is about to redirect.');\n        return true;\n      }\n    } catch (error) {\n      Logger.error(`Error checking for protocol echo reply isSignInPending: ${error}`);\n    }\n\n    return !!this.getAuthResponseToken();\n  }\n\n  isUserSignedIn() {\n    return !!this.store.getSessionData().userData;\n  }\n\n  async handlePendingSignIn(authResponseToken = this.getAuthResponseToken()) {\n    const sessionData = this.store.getSessionData();\n\n    if (sessionData.userData) {\n      throw new LoginFailedError('Existing user session found.');\n    }\n\n    const transitKey = this.store.getSessionData().transitKey;\n    let coreNode = this.appConfig && this.appConfig.coreNode;\n\n    if (!coreNode) {\n      const network = new StacksMainnet();\n      coreNode = network.bnsLookupUrl;\n    }\n\n    const tokenPayload = decodeToken(authResponseToken).payload;\n\n    if (typeof tokenPayload === 'string') {\n      throw new Error('Unexpected token payload type of string');\n    }\n\n    const nameLookupURL = `${coreNode}${NAME_LOOKUP_PATH}`;\n    const fallbackLookupURLs = [`https://stacks-node-api.stacks.co${NAME_LOOKUP_PATH}`, `https://registrar.stacks.co${NAME_LOOKUP_PATH}`].filter(url => url !== nameLookupURL);\n    const isValid = await verifyAuthResponse(authResponseToken, nameLookupURL, fallbackLookupURLs);\n\n    if (!isValid) {\n      throw new LoginFailedError('Invalid authentication response.');\n    }\n\n    let appPrivateKey = tokenPayload.private_key;\n    let coreSessionToken = tokenPayload.core_token;\n\n    if (isLaterVersion(tokenPayload.version, '1.1.0')) {\n      if (transitKey !== undefined && transitKey != null) {\n        if (tokenPayload.private_key !== undefined && tokenPayload.private_key !== null) {\n          try {\n            appPrivateKey = await authMessages.decryptPrivateKey(transitKey, tokenPayload.private_key);\n          } catch (e) {\n            Logger.warn('Failed decryption of appPrivateKey, will try to use as given');\n\n            try {\n              hexStringToECPair(tokenPayload.private_key);\n            } catch (ecPairError) {\n              throw new LoginFailedError('Failed decrypting appPrivateKey. Usually means' + ' that the transit key has changed during login.');\n            }\n          }\n        }\n\n        if (coreSessionToken !== undefined && coreSessionToken !== null) {\n          try {\n            coreSessionToken = await authMessages.decryptPrivateKey(transitKey, coreSessionToken);\n          } catch (e) {\n            Logger.info('Failed decryption of coreSessionToken, will try to use as given');\n          }\n        }\n      } else {\n        throw new LoginFailedError('Authenticating with protocol > 1.1.0 requires transit' + ' key, and none found.');\n      }\n    }\n\n    let hubUrl = BLOCKSTACK_DEFAULT_GAIA_HUB_URL;\n    let gaiaAssociationToken;\n\n    if (isLaterVersion(tokenPayload.version, '1.2.0') && tokenPayload.hubUrl !== null && tokenPayload.hubUrl !== undefined) {\n      hubUrl = tokenPayload.hubUrl;\n    }\n\n    if (isLaterVersion(tokenPayload.version, '1.3.0') && tokenPayload.associationToken !== null && tokenPayload.associationToken !== undefined) {\n      gaiaAssociationToken = tokenPayload.associationToken;\n    }\n\n    const userData = {\n      username: tokenPayload.username,\n      profile: tokenPayload.profile,\n      email: tokenPayload.email,\n      decentralizedID: tokenPayload.iss,\n      identityAddress: getAddressFromDID(tokenPayload.iss),\n      appPrivateKey,\n      coreSessionToken,\n      authResponseToken,\n      hubUrl,\n      coreNode: tokenPayload.blockstackAPIUrl,\n      gaiaAssociationToken\n    };\n    const profileURL = tokenPayload.profile_url;\n\n    if (!userData.profile && profileURL) {\n      const response = await fetchPrivate(profileURL);\n\n      if (!response.ok) {\n        userData.profile = Object.assign({}, DEFAULT_PROFILE);\n      } else {\n        const responseText = await response.text();\n        const wrappedProfile = JSON.parse(responseText);\n        userData.profile = extractProfile(wrappedProfile[0].token);\n      }\n    } else {\n      userData.profile = tokenPayload.profile;\n    }\n\n    sessionData.userData = userData;\n    this.store.setSessionData(sessionData);\n    return userData;\n  }\n\n  loadUserData() {\n    const userData = this.store.getSessionData().userData;\n\n    if (!userData) {\n      throw new InvalidStateError('No user data found. Did the user sign in?');\n    }\n\n    return userData;\n  }\n\n  encryptContent(content, options) {\n    const opts = Object.assign({}, options);\n\n    if (!opts.privateKey) {\n      opts.privateKey = this.loadUserData().appPrivateKey;\n    }\n\n    return encryptContent(content, opts);\n  }\n\n  decryptContent(content, options) {\n    const opts = Object.assign({}, options);\n\n    if (!opts.privateKey) {\n      opts.privateKey = this.loadUserData().appPrivateKey;\n    }\n\n    return decryptContent(content, opts);\n  }\n\n  signUserOut(redirectURL) {\n    this.store.deleteSessionData();\n\n    if (redirectURL) {\n      if (typeof location !== 'undefined' && location.href) {\n        location.href = redirectURL;\n      }\n    }\n  }\n\n}","map":{"version":3,"sources":["../../src/userSession.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { AppConfig } from './appConfig';\nimport { InstanceDataStore, LocalStorageStore } from './sessionStore';\nimport { decodeToken } from 'jsontokens';\nimport { verifyAuthResponse } from './verification';\nimport * as authMessages from './messages';\nimport { decryptContent, encryptContent, hexStringToECPair, } from '@stacks/encryption';\nimport { getAddressFromDID } from './dids';\nimport { BLOCKSTACK_DEFAULT_GAIA_HUB_URL, fetchPrivate, getGlobalObject, InvalidStateError, isLaterVersion, Logger, LoginFailedError, MissingParameterError, nextHour, } from '@stacks/common';\nimport { extractProfile } from '@stacks/profile';\nimport { DEFAULT_PROFILE, NAME_LOOKUP_PATH } from './constants';\nimport * as queryString from 'query-string';\nimport { StacksMainnet } from '@stacks/network';\nimport { protocolEchoReplyDetection } from './protocolEchoDetection';\nexport class UserSession {\n    constructor(options) {\n        let runningInBrowser = true;\n        if (typeof window === 'undefined' && typeof self === 'undefined') {\n            runningInBrowser = false;\n        }\n        if (options && options.appConfig) {\n            this.appConfig = options.appConfig;\n        }\n        else if (runningInBrowser) {\n            this.appConfig = new AppConfig();\n        }\n        else {\n            throw new MissingParameterError('You need to specify options.appConfig');\n        }\n        if (options && options.sessionStore) {\n            this.store = options.sessionStore;\n        }\n        else if (runningInBrowser) {\n            if (options) {\n                this.store = new LocalStorageStore(options.sessionOptions);\n            }\n            else {\n                this.store = new LocalStorageStore();\n            }\n        }\n        else if (options) {\n            this.store = new InstanceDataStore(options.sessionOptions);\n        }\n        else {\n            this.store = new InstanceDataStore();\n        }\n    }\n    makeAuthRequest(transitKey, redirectURI, manifestURI, scopes, appDomain, expiresAt = nextHour().getTime(), extraParams = {}) {\n        const appConfig = this.appConfig;\n        if (!appConfig) {\n            throw new InvalidStateError('Missing AppConfig');\n        }\n        transitKey = transitKey || this.generateAndStoreTransitKey();\n        redirectURI = redirectURI || appConfig.redirectURI();\n        manifestURI = manifestURI || appConfig.manifestURI();\n        scopes = scopes || appConfig.scopes;\n        appDomain = appDomain || appConfig.appDomain;\n        return authMessages.makeAuthRequest(transitKey, redirectURI, manifestURI, scopes, appDomain, expiresAt, extraParams);\n    }\n    generateAndStoreTransitKey() {\n        const sessionData = this.store.getSessionData();\n        const transitKey = authMessages.generateTransitKey();\n        sessionData.transitKey = transitKey;\n        this.store.setSessionData(sessionData);\n        return transitKey;\n    }\n    getAuthResponseToken() {\n        var _a;\n        const search = (_a = getGlobalObject('location', {\n            throwIfUnavailable: true,\n            usageDesc: 'getAuthResponseToken',\n        })) === null || _a === void 0 ? void 0 : _a.search;\n        if (search) {\n            const queryDict = queryString.parse(search);\n            return queryDict.authResponse ? queryDict.authResponse : '';\n        }\n        return '';\n    }\n    isSignInPending() {\n        try {\n            const isProtocolEcho = protocolEchoReplyDetection();\n            if (isProtocolEcho) {\n                Logger.info('protocolEchoReply detected from isSignInPending call, the page is about to redirect.');\n                return true;\n            }\n        }\n        catch (error) {\n            Logger.error(`Error checking for protocol echo reply isSignInPending: ${error}`);\n        }\n        return !!this.getAuthResponseToken();\n    }\n    isUserSignedIn() {\n        return !!this.store.getSessionData().userData;\n    }\n    async handlePendingSignIn(authResponseToken = this.getAuthResponseToken()) {\n        const sessionData = this.store.getSessionData();\n        if (sessionData.userData) {\n            throw new LoginFailedError('Existing user session found.');\n        }\n        const transitKey = this.store.getSessionData().transitKey;\n        let coreNode = this.appConfig && this.appConfig.coreNode;\n        if (!coreNode) {\n            const network = new StacksMainnet();\n            coreNode = network.bnsLookupUrl;\n        }\n        const tokenPayload = decodeToken(authResponseToken).payload;\n        if (typeof tokenPayload === 'string') {\n            throw new Error('Unexpected token payload type of string');\n        }\n        const nameLookupURL = `${coreNode}${NAME_LOOKUP_PATH}`;\n        const fallbackLookupURLs = [\n            `https://stacks-node-api.stacks.co${NAME_LOOKUP_PATH}`,\n            `https://registrar.stacks.co${NAME_LOOKUP_PATH}`,\n        ].filter(url => url !== nameLookupURL);\n        const isValid = await verifyAuthResponse(authResponseToken, nameLookupURL, fallbackLookupURLs);\n        if (!isValid) {\n            throw new LoginFailedError('Invalid authentication response.');\n        }\n        let appPrivateKey = tokenPayload.private_key;\n        let coreSessionToken = tokenPayload.core_token;\n        if (isLaterVersion(tokenPayload.version, '1.1.0')) {\n            if (transitKey !== undefined && transitKey != null) {\n                if (tokenPayload.private_key !== undefined && tokenPayload.private_key !== null) {\n                    try {\n                        appPrivateKey = (await authMessages.decryptPrivateKey(transitKey, tokenPayload.private_key));\n                    }\n                    catch (e) {\n                        Logger.warn('Failed decryption of appPrivateKey, will try to use as given');\n                        try {\n                            hexStringToECPair(tokenPayload.private_key);\n                        }\n                        catch (ecPairError) {\n                            throw new LoginFailedError('Failed decrypting appPrivateKey. Usually means' +\n                                ' that the transit key has changed during login.');\n                        }\n                    }\n                }\n                if (coreSessionToken !== undefined && coreSessionToken !== null) {\n                    try {\n                        coreSessionToken = (await authMessages.decryptPrivateKey(transitKey, coreSessionToken));\n                    }\n                    catch (e) {\n                        Logger.info('Failed decryption of coreSessionToken, will try to use as given');\n                    }\n                }\n            }\n            else {\n                throw new LoginFailedError('Authenticating with protocol > 1.1.0 requires transit' + ' key, and none found.');\n            }\n        }\n        let hubUrl = BLOCKSTACK_DEFAULT_GAIA_HUB_URL;\n        let gaiaAssociationToken;\n        if (isLaterVersion(tokenPayload.version, '1.2.0') &&\n            tokenPayload.hubUrl !== null &&\n            tokenPayload.hubUrl !== undefined) {\n            hubUrl = tokenPayload.hubUrl;\n        }\n        if (isLaterVersion(tokenPayload.version, '1.3.0') &&\n            tokenPayload.associationToken !== null &&\n            tokenPayload.associationToken !== undefined) {\n            gaiaAssociationToken = tokenPayload.associationToken;\n        }\n        const userData = {\n            username: tokenPayload.username,\n            profile: tokenPayload.profile,\n            email: tokenPayload.email,\n            decentralizedID: tokenPayload.iss,\n            identityAddress: getAddressFromDID(tokenPayload.iss),\n            appPrivateKey,\n            coreSessionToken,\n            authResponseToken,\n            hubUrl,\n            coreNode: tokenPayload.blockstackAPIUrl,\n            gaiaAssociationToken,\n        };\n        const profileURL = tokenPayload.profile_url;\n        if (!userData.profile && profileURL) {\n            const response = await fetchPrivate(profileURL);\n            if (!response.ok) {\n                userData.profile = Object.assign({}, DEFAULT_PROFILE);\n            }\n            else {\n                const responseText = await response.text();\n                const wrappedProfile = JSON.parse(responseText);\n                userData.profile = extractProfile(wrappedProfile[0].token);\n            }\n        }\n        else {\n            userData.profile = tokenPayload.profile;\n        }\n        sessionData.userData = userData;\n        this.store.setSessionData(sessionData);\n        return userData;\n    }\n    loadUserData() {\n        const userData = this.store.getSessionData().userData;\n        if (!userData) {\n            throw new InvalidStateError('No user data found. Did the user sign in?');\n        }\n        return userData;\n    }\n    encryptContent(content, options) {\n        const opts = Object.assign({}, options);\n        if (!opts.privateKey) {\n            opts.privateKey = this.loadUserData().appPrivateKey;\n        }\n        return encryptContent(content, opts);\n    }\n    decryptContent(content, options) {\n        const opts = Object.assign({}, options);\n        if (!opts.privateKey) {\n            opts.privateKey = this.loadUserData().appPrivateKey;\n        }\n        return decryptContent(content, opts);\n    }\n    signUserOut(redirectURL) {\n        this.store.deleteSessionData();\n        if (redirectURL) {\n            if (typeof location !== 'undefined' && location.href) {\n                location.href = redirectURL;\n            }\n        }\n    }\n}\n//# sourceMappingURL=userSession.js.map"]},"metadata":{},"sourceType":"module"}