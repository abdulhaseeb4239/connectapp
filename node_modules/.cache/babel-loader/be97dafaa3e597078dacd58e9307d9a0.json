{"ast":null,"code":"import { Buffer } from '@stacks/common';\nimport { ECPair, address, networks } from 'bitcoinjs-lib';\nimport { randomBytes } from './cryptoRandom';\nimport { hashSha256Sync } from './sha2Hash';\nimport { hashRipemd160 } from './hashRipemd160';\nexport function getEntropy(arg) {\n  if (!arg) {\n    arg = 32;\n  }\n\n  return randomBytes(arg);\n}\nexport function makeECPrivateKey() {\n  const keyPair = ECPair.makeRandom({\n    rng: getEntropy\n  });\n  return keyPair.privateKey.toString('hex');\n}\nexport function publicKeyToAddress(publicKey) {\n  const publicKeyBuffer = Buffer.isBuffer(publicKey) ? publicKey : Buffer.from(publicKey, 'hex');\n  const publicKeyHash160 = hashRipemd160(hashSha256Sync(publicKeyBuffer));\n  const result = address.toBase58Check(publicKeyHash160, networks.bitcoin.pubKeyHash);\n  return result;\n}\nexport function getPublicKeyFromPrivate(privateKey) {\n  const privateKeyBuffer = Buffer.isBuffer(privateKey) ? privateKey : Buffer.from(privateKey, 'hex');\n  const keyPair = ECPair.fromPrivateKey(privateKeyBuffer);\n  return keyPair.publicKey.toString('hex');\n}\nexport function hexStringToECPair(skHex, network) {\n  const ecPairOptions = {\n    network: network || networks.bitcoin,\n    compressed: true\n  };\n\n  if (skHex.length === 66) {\n    if (skHex.slice(64) !== '01') {\n      throw new Error('Improperly formatted private-key hex string. 66-length hex usually ' + 'indicates compressed key, but last byte must be == 1');\n    }\n\n    return ECPair.fromPrivateKey(Buffer.from(skHex.slice(0, 64), 'hex'), ecPairOptions);\n  } else if (skHex.length === 64) {\n    ecPairOptions.compressed = false;\n    return ECPair.fromPrivateKey(Buffer.from(skHex, 'hex'), ecPairOptions);\n  } else {\n    throw new Error('Improperly formatted private-key hex string: length should be 64 or 66.');\n  }\n}\nexport function ecPairToHexString(secretKey) {\n  const ecPointHex = secretKey.privateKey.toString('hex');\n\n  if (secretKey.compressed) {\n    return `${ecPointHex}01`;\n  } else {\n    return ecPointHex;\n  }\n}\nexport function ecPairToAddress(keyPair) {\n  const sha256 = hashSha256Sync(keyPair.publicKey);\n  const hash160 = hashRipemd160(sha256);\n  return address.toBase58Check(hash160, keyPair.network.pubKeyHash);\n}","map":{"version":3,"sources":["../../src/keys.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Buffer } from '@stacks/common';\nimport { ECPair, address, networks } from 'bitcoinjs-lib';\nimport { randomBytes } from './cryptoRandom';\nimport { hashSha256Sync } from './sha2Hash';\nimport { hashRipemd160 } from './hashRipemd160';\nexport function getEntropy(arg) {\n    if (!arg) {\n        arg = 32;\n    }\n    return randomBytes(arg);\n}\nexport function makeECPrivateKey() {\n    const keyPair = ECPair.makeRandom({ rng: getEntropy });\n    return keyPair.privateKey.toString('hex');\n}\nexport function publicKeyToAddress(publicKey) {\n    const publicKeyBuffer = Buffer.isBuffer(publicKey) ? publicKey : Buffer.from(publicKey, 'hex');\n    const publicKeyHash160 = hashRipemd160(hashSha256Sync(publicKeyBuffer));\n    const result = address.toBase58Check(publicKeyHash160, networks.bitcoin.pubKeyHash);\n    return result;\n}\nexport function getPublicKeyFromPrivate(privateKey) {\n    const privateKeyBuffer = Buffer.isBuffer(privateKey)\n        ? privateKey\n        : Buffer.from(privateKey, 'hex');\n    const keyPair = ECPair.fromPrivateKey(privateKeyBuffer);\n    return keyPair.publicKey.toString('hex');\n}\nexport function hexStringToECPair(skHex, network) {\n    const ecPairOptions = {\n        network: network || networks.bitcoin,\n        compressed: true,\n    };\n    if (skHex.length === 66) {\n        if (skHex.slice(64) !== '01') {\n            throw new Error('Improperly formatted private-key hex string. 66-length hex usually ' +\n                'indicates compressed key, but last byte must be == 1');\n        }\n        return ECPair.fromPrivateKey(Buffer.from(skHex.slice(0, 64), 'hex'), ecPairOptions);\n    }\n    else if (skHex.length === 64) {\n        ecPairOptions.compressed = false;\n        return ECPair.fromPrivateKey(Buffer.from(skHex, 'hex'), ecPairOptions);\n    }\n    else {\n        throw new Error('Improperly formatted private-key hex string: length should be 64 or 66.');\n    }\n}\nexport function ecPairToHexString(secretKey) {\n    const ecPointHex = secretKey.privateKey.toString('hex');\n    if (secretKey.compressed) {\n        return `${ecPointHex}01`;\n    }\n    else {\n        return ecPointHex;\n    }\n}\nexport function ecPairToAddress(keyPair) {\n    const sha256 = hashSha256Sync(keyPair.publicKey);\n    const hash160 = hashRipemd160(sha256);\n    return address.toBase58Check(hash160, keyPair.network.pubKeyHash);\n}\n//# sourceMappingURL=keys.js.map"]},"metadata":{},"sourceType":"module"}