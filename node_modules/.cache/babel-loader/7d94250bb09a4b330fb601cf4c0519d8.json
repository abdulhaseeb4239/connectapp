{"ast":null,"code":"import { Buffer } from '@stacks/common';\nimport { validateMnemonic, mnemonicToEntropy, entropyToMnemonic } from 'bip39';\nimport { randomBytes } from './cryptoRandom';\nimport { createSha2Hash } from './sha2Hash';\nimport { createHmacSha256 } from './hmacSha256';\nimport { createCipher } from './aesCipher';\nimport { createPbkdf2 } from './pbkdf2';\nexport async function encryptMnemonic(phrase, password, opts) {\n  let mnemonicEntropy;\n\n  try {\n    mnemonicEntropy = mnemonicToEntropy(phrase);\n  } catch (error) {\n    console.error('Invalid mnemonic phrase provided');\n    console.error(error);\n    throw new Error('Not a valid bip39 mnemonic');\n  }\n\n  const plaintextNormalized = Buffer.from(mnemonicEntropy, 'hex');\n  const pbkdf2 = await createPbkdf2();\n  let salt;\n\n  if (opts && opts.getRandomBytes) {\n    salt = opts.getRandomBytes(16);\n  } else {\n    salt = randomBytes(16);\n  }\n\n  const keysAndIV = await pbkdf2.derive(password, salt, 100000, 48, 'sha512');\n  const encKey = keysAndIV.slice(0, 16);\n  const macKey = keysAndIV.slice(16, 32);\n  const iv = keysAndIV.slice(32, 48);\n  const cipher = await createCipher();\n  const cipherText = await cipher.encrypt('aes-128-cbc', encKey, iv, plaintextNormalized);\n  const hmacPayload = Buffer.concat([salt, cipherText]);\n  const hmacSha256 = await createHmacSha256();\n  const hmacDigest = await hmacSha256.digest(macKey, hmacPayload);\n  const payload = Buffer.concat([salt, hmacDigest, cipherText]);\n  return payload;\n}\n\nclass PasswordError extends Error {}\n\nasync function decryptMnemonicBuffer(dataBuffer, password) {\n  const salt = dataBuffer.slice(0, 16);\n  const hmacSig = dataBuffer.slice(16, 48);\n  const cipherText = dataBuffer.slice(48);\n  const hmacPayload = Buffer.concat([salt, cipherText]);\n  const pbkdf2 = await createPbkdf2();\n  const keysAndIV = await pbkdf2.derive(password, salt, 100000, 48, 'sha512');\n  const encKey = keysAndIV.slice(0, 16);\n  const macKey = keysAndIV.slice(16, 32);\n  const iv = keysAndIV.slice(32, 48);\n  const decipher = await createCipher();\n  const decryptedResult = await decipher.decrypt('aes-128-cbc', encKey, iv, cipherText);\n  const hmacSha256 = await createHmacSha256();\n  const hmacDigest = await hmacSha256.digest(macKey, hmacPayload);\n  const sha2Hash = await createSha2Hash();\n  const hmacSigHash = await sha2Hash.digest(hmacSig);\n  const hmacDigestHash = await sha2Hash.digest(hmacDigest);\n\n  if (!hmacSigHash.equals(hmacDigestHash)) {\n    throw new PasswordError('Wrong password (HMAC mismatch)');\n  }\n\n  let mnemonic;\n\n  try {\n    mnemonic = entropyToMnemonic(decryptedResult);\n  } catch (error) {\n    console.error('Error thrown by `entropyToMnemonic`');\n    console.error(error);\n    throw new PasswordError('Wrong password (invalid plaintext)');\n  }\n\n  if (!validateMnemonic(mnemonic)) {\n    throw new PasswordError('Wrong password (invalid plaintext)');\n  }\n\n  return mnemonic;\n}\n\nfunction decryptLegacy(dataBuffer, password, triplesecDecrypt) {\n  return new Promise((resolve, reject) => {\n    if (!triplesecDecrypt) {\n      reject(new Error('The `triplesec.decrypt` function must be provided'));\n    }\n\n    triplesecDecrypt({\n      key: Buffer.from(password),\n      data: dataBuffer\n    }, (err, plaintextBuffer) => {\n      if (!err) {\n        resolve(plaintextBuffer);\n      } else {\n        reject(err);\n      }\n    });\n  });\n}\n\nexport async function decryptMnemonic(data, password, triplesecDecrypt) {\n  const dataBuffer = Buffer.isBuffer(data) ? data : Buffer.from(data, 'hex');\n\n  try {\n    return await decryptMnemonicBuffer(dataBuffer, password);\n  } catch (err) {\n    if (err instanceof PasswordError) {\n      throw err;\n    }\n\n    const data = await decryptLegacy(dataBuffer, password, triplesecDecrypt);\n    return data.toString();\n  }\n}","map":{"version":3,"sources":["../../src/wallet.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Buffer } from '@stacks/common';\nimport { validateMnemonic, mnemonicToEntropy, entropyToMnemonic } from 'bip39';\nimport { randomBytes } from './cryptoRandom';\nimport { createSha2Hash } from './sha2Hash';\nimport { createHmacSha256 } from './hmacSha256';\nimport { createCipher } from './aesCipher';\nimport { createPbkdf2 } from './pbkdf2';\nexport async function encryptMnemonic(phrase, password, opts) {\n    let mnemonicEntropy;\n    try {\n        mnemonicEntropy = mnemonicToEntropy(phrase);\n    }\n    catch (error) {\n        console.error('Invalid mnemonic phrase provided');\n        console.error(error);\n        throw new Error('Not a valid bip39 mnemonic');\n    }\n    const plaintextNormalized = Buffer.from(mnemonicEntropy, 'hex');\n    const pbkdf2 = await createPbkdf2();\n    let salt;\n    if (opts && opts.getRandomBytes) {\n        salt = opts.getRandomBytes(16);\n    }\n    else {\n        salt = randomBytes(16);\n    }\n    const keysAndIV = await pbkdf2.derive(password, salt, 100000, 48, 'sha512');\n    const encKey = keysAndIV.slice(0, 16);\n    const macKey = keysAndIV.slice(16, 32);\n    const iv = keysAndIV.slice(32, 48);\n    const cipher = await createCipher();\n    const cipherText = await cipher.encrypt('aes-128-cbc', encKey, iv, plaintextNormalized);\n    const hmacPayload = Buffer.concat([salt, cipherText]);\n    const hmacSha256 = await createHmacSha256();\n    const hmacDigest = await hmacSha256.digest(macKey, hmacPayload);\n    const payload = Buffer.concat([salt, hmacDigest, cipherText]);\n    return payload;\n}\nclass PasswordError extends Error {\n}\nasync function decryptMnemonicBuffer(dataBuffer, password) {\n    const salt = dataBuffer.slice(0, 16);\n    const hmacSig = dataBuffer.slice(16, 48);\n    const cipherText = dataBuffer.slice(48);\n    const hmacPayload = Buffer.concat([salt, cipherText]);\n    const pbkdf2 = await createPbkdf2();\n    const keysAndIV = await pbkdf2.derive(password, salt, 100000, 48, 'sha512');\n    const encKey = keysAndIV.slice(0, 16);\n    const macKey = keysAndIV.slice(16, 32);\n    const iv = keysAndIV.slice(32, 48);\n    const decipher = await createCipher();\n    const decryptedResult = await decipher.decrypt('aes-128-cbc', encKey, iv, cipherText);\n    const hmacSha256 = await createHmacSha256();\n    const hmacDigest = await hmacSha256.digest(macKey, hmacPayload);\n    const sha2Hash = await createSha2Hash();\n    const hmacSigHash = await sha2Hash.digest(hmacSig);\n    const hmacDigestHash = await sha2Hash.digest(hmacDigest);\n    if (!hmacSigHash.equals(hmacDigestHash)) {\n        throw new PasswordError('Wrong password (HMAC mismatch)');\n    }\n    let mnemonic;\n    try {\n        mnemonic = entropyToMnemonic(decryptedResult);\n    }\n    catch (error) {\n        console.error('Error thrown by `entropyToMnemonic`');\n        console.error(error);\n        throw new PasswordError('Wrong password (invalid plaintext)');\n    }\n    if (!validateMnemonic(mnemonic)) {\n        throw new PasswordError('Wrong password (invalid plaintext)');\n    }\n    return mnemonic;\n}\nfunction decryptLegacy(dataBuffer, password, triplesecDecrypt) {\n    return new Promise((resolve, reject) => {\n        if (!triplesecDecrypt) {\n            reject(new Error('The `triplesec.decrypt` function must be provided'));\n        }\n        triplesecDecrypt({\n            key: Buffer.from(password),\n            data: dataBuffer,\n        }, (err, plaintextBuffer) => {\n            if (!err) {\n                resolve(plaintextBuffer);\n            }\n            else {\n                reject(err);\n            }\n        });\n    });\n}\nexport async function decryptMnemonic(data, password, triplesecDecrypt) {\n    const dataBuffer = Buffer.isBuffer(data) ? data : Buffer.from(data, 'hex');\n    try {\n        return await decryptMnemonicBuffer(dataBuffer, password);\n    }\n    catch (err) {\n        if (err instanceof PasswordError) {\n            throw err;\n        }\n        const data = await decryptLegacy(dataBuffer, password, triplesecDecrypt);\n        return data.toString();\n    }\n}\n//# sourceMappingURL=wallet.js.map"]},"metadata":{},"sourceType":"module"}