{"ast":null,"code":"import { Buffer } from '@stacks/common';\nimport { cloneDeep } from './utils';\nimport { uintCV, intCV, contractPrincipalCV, standardPrincipalCV, noneCV, bufferCV, falseCV, trueCV, ClarityType, getCVTypeString, bufferCVFromString } from './clarity';\nimport { NotImplementedError } from './errors';\nimport { stringAsciiCV, stringUtf8CV } from './clarity/types/stringCV';\nexport var ClarityAbiTypeId;\n\n(function (ClarityAbiTypeId) {\n  ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeUInt128\"] = 1] = \"ClarityAbiTypeUInt128\";\n  ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeInt128\"] = 2] = \"ClarityAbiTypeInt128\";\n  ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeBool\"] = 3] = \"ClarityAbiTypeBool\";\n  ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypePrincipal\"] = 4] = \"ClarityAbiTypePrincipal\";\n  ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeNone\"] = 5] = \"ClarityAbiTypeNone\";\n  ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeBuffer\"] = 6] = \"ClarityAbiTypeBuffer\";\n  ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeResponse\"] = 7] = \"ClarityAbiTypeResponse\";\n  ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeOptional\"] = 8] = \"ClarityAbiTypeOptional\";\n  ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeTuple\"] = 9] = \"ClarityAbiTypeTuple\";\n  ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeList\"] = 10] = \"ClarityAbiTypeList\";\n  ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeStringAscii\"] = 11] = \"ClarityAbiTypeStringAscii\";\n  ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeStringUtf8\"] = 12] = \"ClarityAbiTypeStringUtf8\";\n  ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeTraitReference\"] = 13] = \"ClarityAbiTypeTraitReference\";\n})(ClarityAbiTypeId || (ClarityAbiTypeId = {}));\n\nexport const isClarityAbiPrimitive = val => typeof val === 'string';\nexport const isClarityAbiBuffer = val => val.buffer !== undefined;\nexport const isClarityAbiStringAscii = val => val['string-ascii'] !== undefined;\nexport const isClarityAbiStringUtf8 = val => val['string-utf8'] !== undefined;\nexport const isClarityAbiResponse = val => val.response !== undefined;\nexport const isClarityAbiOptional = val => val.optional !== undefined;\nexport const isClarityAbiTuple = val => val.tuple !== undefined;\nexport const isClarityAbiList = val => val.list !== undefined;\nexport function getTypeUnion(val) {\n  if (isClarityAbiPrimitive(val)) {\n    if (val === 'uint128') {\n      return {\n        id: ClarityAbiTypeId.ClarityAbiTypeUInt128,\n        type: val\n      };\n    } else if (val === 'int128') {\n      return {\n        id: ClarityAbiTypeId.ClarityAbiTypeInt128,\n        type: val\n      };\n    } else if (val === 'bool') {\n      return {\n        id: ClarityAbiTypeId.ClarityAbiTypeBool,\n        type: val\n      };\n    } else if (val === 'principal') {\n      return {\n        id: ClarityAbiTypeId.ClarityAbiTypePrincipal,\n        type: val\n      };\n    } else if (val === 'trait_reference') {\n      return {\n        id: ClarityAbiTypeId.ClarityAbiTypeTraitReference,\n        type: val\n      };\n    } else if (val === 'none') {\n      return {\n        id: ClarityAbiTypeId.ClarityAbiTypeNone,\n        type: val\n      };\n    } else {\n      throw new Error(`Unexpected Clarity ABI type primitive: ${JSON.stringify(val)}`);\n    }\n  } else if (isClarityAbiBuffer(val)) {\n    return {\n      id: ClarityAbiTypeId.ClarityAbiTypeBuffer,\n      type: val\n    };\n  } else if (isClarityAbiResponse(val)) {\n    return {\n      id: ClarityAbiTypeId.ClarityAbiTypeResponse,\n      type: val\n    };\n  } else if (isClarityAbiOptional(val)) {\n    return {\n      id: ClarityAbiTypeId.ClarityAbiTypeOptional,\n      type: val\n    };\n  } else if (isClarityAbiTuple(val)) {\n    return {\n      id: ClarityAbiTypeId.ClarityAbiTypeTuple,\n      type: val\n    };\n  } else if (isClarityAbiList(val)) {\n    return {\n      id: ClarityAbiTypeId.ClarityAbiTypeList,\n      type: val\n    };\n  } else if (isClarityAbiStringAscii(val)) {\n    return {\n      id: ClarityAbiTypeId.ClarityAbiTypeStringAscii,\n      type: val\n    };\n  } else if (isClarityAbiStringUtf8(val)) {\n    return {\n      id: ClarityAbiTypeId.ClarityAbiTypeStringUtf8,\n      type: val\n    };\n  } else {\n    throw new Error(`Unexpected Clarity ABI type: ${JSON.stringify(val)}`);\n  }\n}\n\nfunction encodeClarityValue(input, val) {\n  let union;\n\n  if (input.id !== undefined) {\n    union = input;\n  } else {\n    union = getTypeUnion(input);\n  }\n\n  switch (union.id) {\n    case ClarityAbiTypeId.ClarityAbiTypeUInt128:\n      return uintCV(val);\n\n    case ClarityAbiTypeId.ClarityAbiTypeInt128:\n      return intCV(val);\n\n    case ClarityAbiTypeId.ClarityAbiTypeBool:\n      if (val === 'false' || val === '0') return falseCV();else if (val === 'true' || val === '1') return trueCV();else throw new Error(`Unexpected Clarity bool value: ${JSON.stringify(val)}`);\n\n    case ClarityAbiTypeId.ClarityAbiTypePrincipal:\n      if (val.includes('.')) {\n        const [addr, name] = val.split('.');\n        return contractPrincipalCV(addr, name);\n      } else {\n        return standardPrincipalCV(val);\n      }\n\n    case ClarityAbiTypeId.ClarityAbiTypeTraitReference:\n      const [addr, name] = val.split('.');\n      return contractPrincipalCV(addr, name);\n\n    case ClarityAbiTypeId.ClarityAbiTypeNone:\n      return noneCV();\n\n    case ClarityAbiTypeId.ClarityAbiTypeBuffer:\n      return bufferCV(Buffer.from(val, 'utf8'));\n\n    case ClarityAbiTypeId.ClarityAbiTypeStringAscii:\n      return stringAsciiCV(val);\n\n    case ClarityAbiTypeId.ClarityAbiTypeStringUtf8:\n      return stringUtf8CV(val);\n\n    case ClarityAbiTypeId.ClarityAbiTypeResponse:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n\n    case ClarityAbiTypeId.ClarityAbiTypeOptional:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n\n    case ClarityAbiTypeId.ClarityAbiTypeTuple:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n\n    case ClarityAbiTypeId.ClarityAbiTypeList:\n      throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n\n    default:\n      throw new Error(`Unexpected Clarity type ID: ${JSON.stringify(union)}`);\n  }\n}\n\nexport { encodeClarityValue };\nexport function getTypeString(val) {\n  if (isClarityAbiPrimitive(val)) {\n    if (val === 'int128') {\n      return 'int';\n    } else if (val === 'uint128') {\n      return 'uint';\n    }\n\n    return val;\n  } else if (isClarityAbiBuffer(val)) {\n    return `(buff ${val.buffer.length})`;\n  } else if (isClarityAbiStringAscii(val)) {\n    return `(string-ascii ${val['string-ascii'].length})`;\n  } else if (isClarityAbiStringUtf8(val)) {\n    return `(string-utf8 ${val['string-utf8'].length})`;\n  } else if (isClarityAbiResponse(val)) {\n    return `(response ${getTypeString(val.response.ok)} ${getTypeString(val.response.error)})`;\n  } else if (isClarityAbiOptional(val)) {\n    return `(optional ${getTypeString(val.optional)})`;\n  } else if (isClarityAbiTuple(val)) {\n    return `(tuple ${val.tuple.map(t => `(${t.name} ${getTypeString(t.type)})`).join(' ')})`;\n  } else if (isClarityAbiList(val)) {\n    return `(list ${val.list.length} ${getTypeString(val.list.type)})`;\n  } else {\n    throw new Error(`Type string unsupported for Clarity type: ${JSON.stringify(val)}`);\n  }\n}\nexport function abiFunctionToString(func) {\n  const access = func.access === 'read_only' ? 'read-only' : func.access;\n  return `(define-${access} (${func.name} ${func.args.map(arg => `(${arg.name} ${getTypeString(arg.type)})`).join(' ')}))`;\n}\n\nfunction matchType(cv, abiType) {\n  const union = getTypeUnion(abiType);\n\n  switch (cv.type) {\n    case ClarityType.BoolTrue:\n    case ClarityType.BoolFalse:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeBool;\n\n    case ClarityType.Int:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeInt128;\n\n    case ClarityType.UInt:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeUInt128;\n\n    case ClarityType.Buffer:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeBuffer && union.type.buffer.length >= cv.buffer.length;\n\n    case ClarityType.StringASCII:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeStringAscii && union.type['string-ascii'].length >= cv.data.length;\n\n    case ClarityType.StringUTF8:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeStringUtf8 && union.type['string-utf8'].length >= cv.data.length;\n\n    case ClarityType.OptionalNone:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeNone || union.id === ClarityAbiTypeId.ClarityAbiTypeOptional;\n\n    case ClarityType.OptionalSome:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeOptional && matchType(cv.value, union.type.optional);\n\n    case ClarityType.ResponseErr:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeResponse && matchType(cv.value, union.type.response.error);\n\n    case ClarityType.ResponseOk:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypeResponse && matchType(cv.value, union.type.response.ok);\n\n    case ClarityType.PrincipalContract:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypePrincipal || union.id === ClarityAbiTypeId.ClarityAbiTypeTraitReference;\n\n    case ClarityType.PrincipalStandard:\n      return union.id === ClarityAbiTypeId.ClarityAbiTypePrincipal;\n\n    case ClarityType.List:\n      return union.id == ClarityAbiTypeId.ClarityAbiTypeList && union.type.list.length >= cv.list.length && cv.list.every(val => matchType(val, union.type.list.type));\n\n    case ClarityType.Tuple:\n      if (union.id == ClarityAbiTypeId.ClarityAbiTypeTuple) {\n        const tuple = cloneDeep(cv.data);\n\n        for (let i = 0; i < union.type.tuple.length; i++) {\n          const abiTupleEntry = union.type.tuple[i];\n          const key = abiTupleEntry.name;\n          const val = tuple[key];\n\n          if (val) {\n            if (!matchType(val, abiTupleEntry.type)) {\n              return false;\n            }\n\n            delete tuple[key];\n          } else {\n            return false;\n          }\n        }\n\n        return true;\n      } else {\n        return false;\n      }\n\n    default:\n      return false;\n  }\n}\n\nexport function validateContractCall(payload, abi) {\n  const filtered = abi.functions.filter(fn => fn.name === payload.functionName.content);\n\n  if (filtered.length === 1) {\n    const abiFunc = filtered[0];\n    const abiArgs = abiFunc.args;\n\n    if (payload.functionArgs.length !== abiArgs.length) {\n      throw new Error(`Clarity function expects ${abiArgs.length} argument(s) but received ${payload.functionArgs.length}`);\n    }\n\n    for (let i = 0; i < payload.functionArgs.length; i++) {\n      const payloadArg = payload.functionArgs[i];\n      const abiArg = abiArgs[i];\n\n      if (!matchType(payloadArg, abiArg.type)) {\n        const argNum = i + 1;\n        throw new Error(`Clarity function \\`${payload.functionName.content}\\` expects argument ${argNum} to be of type ${getTypeString(abiArg.type)}, not ${getCVTypeString(payloadArg)}`);\n      }\n    }\n\n    return true;\n  } else if (filtered.length === 0) {\n    throw new Error(`ABI doesn't contain a function with the name ${payload.functionName.content}`);\n  } else {\n    throw new Error(`Malformed ABI. Contains multiple functions with the name ${payload.functionName.content}`);\n  }\n}\nexport function parseToCV(input, type) {\n  const typeString = getTypeString(type);\n\n  if (isClarityAbiPrimitive(type)) {\n    if (type === 'uint128') {\n      return uintCV(input);\n    } else if (type === 'int128') {\n      return intCV(input);\n    } else if (type === 'bool') {\n      if (input.toLowerCase() === 'true') {\n        return trueCV();\n      } else if (input.toLowerCase() === 'false') {\n        return falseCV();\n      } else {\n        throw new Error(`Invalid bool value: ${input}`);\n      }\n    } else if (type === 'principal') {\n      if (input.includes('.')) {\n        const [address, contractName] = input.split('.');\n        return contractPrincipalCV(address, contractName);\n      } else {\n        return standardPrincipalCV(input);\n      }\n    } else {\n      throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n    }\n  } else if (isClarityAbiBuffer(type)) {\n    const inputLength = Buffer.from(input).byteLength;\n\n    if (inputLength > type.buffer.length) {\n      throw new Error(`Input exceeds specified buffer length limit of ${type.buffer.length}`);\n    }\n\n    return bufferCVFromString(input);\n  } else if (isClarityAbiResponse(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiOptional(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiTuple(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else if (isClarityAbiList(type)) {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  } else {\n    throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n  }\n}","map":{"version":3,"sources":["../../src/contract-abi.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Buffer } from '@stacks/common';\nimport { cloneDeep } from './utils';\nimport { uintCV, intCV, contractPrincipalCV, standardPrincipalCV, noneCV, bufferCV, falseCV, trueCV, ClarityType, getCVTypeString, bufferCVFromString, } from './clarity';\nimport { NotImplementedError } from './errors';\nimport { stringAsciiCV, stringUtf8CV } from './clarity/types/stringCV';\nexport var ClarityAbiTypeId;\n(function (ClarityAbiTypeId) {\n    ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeUInt128\"] = 1] = \"ClarityAbiTypeUInt128\";\n    ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeInt128\"] = 2] = \"ClarityAbiTypeInt128\";\n    ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeBool\"] = 3] = \"ClarityAbiTypeBool\";\n    ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypePrincipal\"] = 4] = \"ClarityAbiTypePrincipal\";\n    ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeNone\"] = 5] = \"ClarityAbiTypeNone\";\n    ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeBuffer\"] = 6] = \"ClarityAbiTypeBuffer\";\n    ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeResponse\"] = 7] = \"ClarityAbiTypeResponse\";\n    ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeOptional\"] = 8] = \"ClarityAbiTypeOptional\";\n    ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeTuple\"] = 9] = \"ClarityAbiTypeTuple\";\n    ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeList\"] = 10] = \"ClarityAbiTypeList\";\n    ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeStringAscii\"] = 11] = \"ClarityAbiTypeStringAscii\";\n    ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeStringUtf8\"] = 12] = \"ClarityAbiTypeStringUtf8\";\n    ClarityAbiTypeId[ClarityAbiTypeId[\"ClarityAbiTypeTraitReference\"] = 13] = \"ClarityAbiTypeTraitReference\";\n})(ClarityAbiTypeId || (ClarityAbiTypeId = {}));\nexport const isClarityAbiPrimitive = (val) => typeof val === 'string';\nexport const isClarityAbiBuffer = (val) => val.buffer !== undefined;\nexport const isClarityAbiStringAscii = (val) => val['string-ascii'] !== undefined;\nexport const isClarityAbiStringUtf8 = (val) => val['string-utf8'] !== undefined;\nexport const isClarityAbiResponse = (val) => val.response !== undefined;\nexport const isClarityAbiOptional = (val) => val.optional !== undefined;\nexport const isClarityAbiTuple = (val) => val.tuple !== undefined;\nexport const isClarityAbiList = (val) => val.list !== undefined;\nexport function getTypeUnion(val) {\n    if (isClarityAbiPrimitive(val)) {\n        if (val === 'uint128') {\n            return { id: ClarityAbiTypeId.ClarityAbiTypeUInt128, type: val };\n        }\n        else if (val === 'int128') {\n            return { id: ClarityAbiTypeId.ClarityAbiTypeInt128, type: val };\n        }\n        else if (val === 'bool') {\n            return { id: ClarityAbiTypeId.ClarityAbiTypeBool, type: val };\n        }\n        else if (val === 'principal') {\n            return { id: ClarityAbiTypeId.ClarityAbiTypePrincipal, type: val };\n        }\n        else if (val === 'trait_reference') {\n            return { id: ClarityAbiTypeId.ClarityAbiTypeTraitReference, type: val };\n        }\n        else if (val === 'none') {\n            return { id: ClarityAbiTypeId.ClarityAbiTypeNone, type: val };\n        }\n        else {\n            throw new Error(`Unexpected Clarity ABI type primitive: ${JSON.stringify(val)}`);\n        }\n    }\n    else if (isClarityAbiBuffer(val)) {\n        return { id: ClarityAbiTypeId.ClarityAbiTypeBuffer, type: val };\n    }\n    else if (isClarityAbiResponse(val)) {\n        return { id: ClarityAbiTypeId.ClarityAbiTypeResponse, type: val };\n    }\n    else if (isClarityAbiOptional(val)) {\n        return { id: ClarityAbiTypeId.ClarityAbiTypeOptional, type: val };\n    }\n    else if (isClarityAbiTuple(val)) {\n        return { id: ClarityAbiTypeId.ClarityAbiTypeTuple, type: val };\n    }\n    else if (isClarityAbiList(val)) {\n        return { id: ClarityAbiTypeId.ClarityAbiTypeList, type: val };\n    }\n    else if (isClarityAbiStringAscii(val)) {\n        return { id: ClarityAbiTypeId.ClarityAbiTypeStringAscii, type: val };\n    }\n    else if (isClarityAbiStringUtf8(val)) {\n        return { id: ClarityAbiTypeId.ClarityAbiTypeStringUtf8, type: val };\n    }\n    else {\n        throw new Error(`Unexpected Clarity ABI type: ${JSON.stringify(val)}`);\n    }\n}\nfunction encodeClarityValue(input, val) {\n    let union;\n    if (input.id !== undefined) {\n        union = input;\n    }\n    else {\n        union = getTypeUnion(input);\n    }\n    switch (union.id) {\n        case ClarityAbiTypeId.ClarityAbiTypeUInt128:\n            return uintCV(val);\n        case ClarityAbiTypeId.ClarityAbiTypeInt128:\n            return intCV(val);\n        case ClarityAbiTypeId.ClarityAbiTypeBool:\n            if (val === 'false' || val === '0')\n                return falseCV();\n            else if (val === 'true' || val === '1')\n                return trueCV();\n            else\n                throw new Error(`Unexpected Clarity bool value: ${JSON.stringify(val)}`);\n        case ClarityAbiTypeId.ClarityAbiTypePrincipal:\n            if (val.includes('.')) {\n                const [addr, name] = val.split('.');\n                return contractPrincipalCV(addr, name);\n            }\n            else {\n                return standardPrincipalCV(val);\n            }\n        case ClarityAbiTypeId.ClarityAbiTypeTraitReference:\n            const [addr, name] = val.split('.');\n            return contractPrincipalCV(addr, name);\n        case ClarityAbiTypeId.ClarityAbiTypeNone:\n            return noneCV();\n        case ClarityAbiTypeId.ClarityAbiTypeBuffer:\n            return bufferCV(Buffer.from(val, 'utf8'));\n        case ClarityAbiTypeId.ClarityAbiTypeStringAscii:\n            return stringAsciiCV(val);\n        case ClarityAbiTypeId.ClarityAbiTypeStringUtf8:\n            return stringUtf8CV(val);\n        case ClarityAbiTypeId.ClarityAbiTypeResponse:\n            throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n        case ClarityAbiTypeId.ClarityAbiTypeOptional:\n            throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n        case ClarityAbiTypeId.ClarityAbiTypeTuple:\n            throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n        case ClarityAbiTypeId.ClarityAbiTypeList:\n            throw new NotImplementedError(`Unsupported encoding for Clarity type: ${union.id}`);\n        default:\n            throw new Error(`Unexpected Clarity type ID: ${JSON.stringify(union)}`);\n    }\n}\nexport { encodeClarityValue };\nexport function getTypeString(val) {\n    if (isClarityAbiPrimitive(val)) {\n        if (val === 'int128') {\n            return 'int';\n        }\n        else if (val === 'uint128') {\n            return 'uint';\n        }\n        return val;\n    }\n    else if (isClarityAbiBuffer(val)) {\n        return `(buff ${val.buffer.length})`;\n    }\n    else if (isClarityAbiStringAscii(val)) {\n        return `(string-ascii ${val['string-ascii'].length})`;\n    }\n    else if (isClarityAbiStringUtf8(val)) {\n        return `(string-utf8 ${val['string-utf8'].length})`;\n    }\n    else if (isClarityAbiResponse(val)) {\n        return `(response ${getTypeString(val.response.ok)} ${getTypeString(val.response.error)})`;\n    }\n    else if (isClarityAbiOptional(val)) {\n        return `(optional ${getTypeString(val.optional)})`;\n    }\n    else if (isClarityAbiTuple(val)) {\n        return `(tuple ${val.tuple.map(t => `(${t.name} ${getTypeString(t.type)})`).join(' ')})`;\n    }\n    else if (isClarityAbiList(val)) {\n        return `(list ${val.list.length} ${getTypeString(val.list.type)})`;\n    }\n    else {\n        throw new Error(`Type string unsupported for Clarity type: ${JSON.stringify(val)}`);\n    }\n}\nexport function abiFunctionToString(func) {\n    const access = func.access === 'read_only' ? 'read-only' : func.access;\n    return `(define-${access} (${func.name} ${func.args\n        .map(arg => `(${arg.name} ${getTypeString(arg.type)})`)\n        .join(' ')}))`;\n}\nfunction matchType(cv, abiType) {\n    const union = getTypeUnion(abiType);\n    switch (cv.type) {\n        case ClarityType.BoolTrue:\n        case ClarityType.BoolFalse:\n            return union.id === ClarityAbiTypeId.ClarityAbiTypeBool;\n        case ClarityType.Int:\n            return union.id === ClarityAbiTypeId.ClarityAbiTypeInt128;\n        case ClarityType.UInt:\n            return union.id === ClarityAbiTypeId.ClarityAbiTypeUInt128;\n        case ClarityType.Buffer:\n            return (union.id === ClarityAbiTypeId.ClarityAbiTypeBuffer &&\n                union.type.buffer.length >= cv.buffer.length);\n        case ClarityType.StringASCII:\n            return (union.id === ClarityAbiTypeId.ClarityAbiTypeStringAscii &&\n                union.type['string-ascii'].length >= cv.data.length);\n        case ClarityType.StringUTF8:\n            return (union.id === ClarityAbiTypeId.ClarityAbiTypeStringUtf8 &&\n                union.type['string-utf8'].length >= cv.data.length);\n        case ClarityType.OptionalNone:\n            return (union.id === ClarityAbiTypeId.ClarityAbiTypeNone ||\n                union.id === ClarityAbiTypeId.ClarityAbiTypeOptional);\n        case ClarityType.OptionalSome:\n            return (union.id === ClarityAbiTypeId.ClarityAbiTypeOptional &&\n                matchType(cv.value, union.type.optional));\n        case ClarityType.ResponseErr:\n            return (union.id === ClarityAbiTypeId.ClarityAbiTypeResponse &&\n                matchType(cv.value, union.type.response.error));\n        case ClarityType.ResponseOk:\n            return (union.id === ClarityAbiTypeId.ClarityAbiTypeResponse &&\n                matchType(cv.value, union.type.response.ok));\n        case ClarityType.PrincipalContract:\n            return (union.id === ClarityAbiTypeId.ClarityAbiTypePrincipal ||\n                union.id === ClarityAbiTypeId.ClarityAbiTypeTraitReference);\n        case ClarityType.PrincipalStandard:\n            return union.id === ClarityAbiTypeId.ClarityAbiTypePrincipal;\n        case ClarityType.List:\n            return (union.id == ClarityAbiTypeId.ClarityAbiTypeList &&\n                union.type.list.length >= cv.list.length &&\n                cv.list.every(val => matchType(val, union.type.list.type)));\n        case ClarityType.Tuple:\n            if (union.id == ClarityAbiTypeId.ClarityAbiTypeTuple) {\n                const tuple = cloneDeep(cv.data);\n                for (let i = 0; i < union.type.tuple.length; i++) {\n                    const abiTupleEntry = union.type.tuple[i];\n                    const key = abiTupleEntry.name;\n                    const val = tuple[key];\n                    if (val) {\n                        if (!matchType(val, abiTupleEntry.type)) {\n                            return false;\n                        }\n                        delete tuple[key];\n                    }\n                    else {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            else {\n                return false;\n            }\n        default:\n            return false;\n    }\n}\nexport function validateContractCall(payload, abi) {\n    const filtered = abi.functions.filter(fn => fn.name === payload.functionName.content);\n    if (filtered.length === 1) {\n        const abiFunc = filtered[0];\n        const abiArgs = abiFunc.args;\n        if (payload.functionArgs.length !== abiArgs.length) {\n            throw new Error(`Clarity function expects ${abiArgs.length} argument(s) but received ${payload.functionArgs.length}`);\n        }\n        for (let i = 0; i < payload.functionArgs.length; i++) {\n            const payloadArg = payload.functionArgs[i];\n            const abiArg = abiArgs[i];\n            if (!matchType(payloadArg, abiArg.type)) {\n                const argNum = i + 1;\n                throw new Error(`Clarity function \\`${payload.functionName.content}\\` expects argument ${argNum} to be of type ${getTypeString(abiArg.type)}, not ${getCVTypeString(payloadArg)}`);\n            }\n        }\n        return true;\n    }\n    else if (filtered.length === 0) {\n        throw new Error(`ABI doesn't contain a function with the name ${payload.functionName.content}`);\n    }\n    else {\n        throw new Error(`Malformed ABI. Contains multiple functions with the name ${payload.functionName.content}`);\n    }\n}\nexport function parseToCV(input, type) {\n    const typeString = getTypeString(type);\n    if (isClarityAbiPrimitive(type)) {\n        if (type === 'uint128') {\n            return uintCV(input);\n        }\n        else if (type === 'int128') {\n            return intCV(input);\n        }\n        else if (type === 'bool') {\n            if (input.toLowerCase() === 'true') {\n                return trueCV();\n            }\n            else if (input.toLowerCase() === 'false') {\n                return falseCV();\n            }\n            else {\n                throw new Error(`Invalid bool value: ${input}`);\n            }\n        }\n        else if (type === 'principal') {\n            if (input.includes('.')) {\n                const [address, contractName] = input.split('.');\n                return contractPrincipalCV(address, contractName);\n            }\n            else {\n                return standardPrincipalCV(input);\n            }\n        }\n        else {\n            throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n        }\n    }\n    else if (isClarityAbiBuffer(type)) {\n        const inputLength = Buffer.from(input).byteLength;\n        if (inputLength > type.buffer.length) {\n            throw new Error(`Input exceeds specified buffer length limit of ${type.buffer.length}`);\n        }\n        return bufferCVFromString(input);\n    }\n    else if (isClarityAbiResponse(type)) {\n        throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n    }\n    else if (isClarityAbiOptional(type)) {\n        throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n    }\n    else if (isClarityAbiTuple(type)) {\n        throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n    }\n    else if (isClarityAbiList(type)) {\n        throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n    }\n    else {\n        throw new Error(`Contract function contains unsupported Clarity ABI type: ${typeString}`);\n    }\n}\n//# sourceMappingURL=contract-abi.js.map"]},"metadata":{},"sourceType":"module"}