{"ast":null,"code":"import { Buffer, intToBigInt } from '@stacks/common';\nimport { AnchorMode, AuthType, DEFAULT_CHAIN_ID, PayloadType, PostConditionMode, PubKeyEncoding, StacksMessageType, TransactionVersion } from './constants';\nimport { Authorization, createMessageSignature, createTransactionAuthField, isSingleSig, nextSignature } from './authorization';\nimport { BufferArray, cloneDeep, txidFromData } from './utils';\nimport { deserializePayload, serializePayload } from './payload';\nimport { createLPList, deserializeLPList, serializeLPList } from './types';\nimport { isCompressed } from './keys';\nimport { BufferReader } from './bufferReader';\nimport { SerializationError, SigningError } from './errors';\nexport class StacksTransaction {\n  constructor(version, auth, payload, postConditions, postConditionMode, anchorMode, chainId) {\n    this.version = version;\n    this.auth = auth;\n\n    if ('amount' in payload) {\n      this.payload = Object.assign(Object.assign({}, payload), {\n        amount: intToBigInt(payload.amount, false)\n      });\n    } else {\n      this.payload = payload;\n    }\n\n    this.chainId = chainId !== null && chainId !== void 0 ? chainId : DEFAULT_CHAIN_ID;\n    this.postConditionMode = postConditionMode !== null && postConditionMode !== void 0 ? postConditionMode : PostConditionMode.Deny;\n    this.postConditions = postConditions !== null && postConditions !== void 0 ? postConditions : createLPList([]);\n\n    if (anchorMode) {\n      this.anchorMode = anchorMode;\n    } else {\n      switch (payload.payloadType) {\n        case PayloadType.Coinbase:\n        case PayloadType.PoisonMicroblock:\n          {\n            this.anchorMode = AnchorMode.OnChainOnly;\n            break;\n          }\n\n        case PayloadType.ContractCall:\n        case PayloadType.SmartContract:\n        case PayloadType.TokenTransfer:\n          {\n            this.anchorMode = AnchorMode.Any;\n            break;\n          }\n      }\n    }\n  }\n\n  signBegin() {\n    const tx = cloneDeep(this);\n    tx.auth = tx.auth.intoInitialSighashAuth();\n    return tx.txid();\n  }\n\n  verifyBegin() {\n    const tx = cloneDeep(this);\n    tx.auth = tx.auth.intoInitialSighashAuth();\n    return tx.txid();\n  }\n\n  createTxWithSignature(signature) {\n    const parsedSig = typeof signature === 'string' ? signature : signature.toString('hex');\n    const tx = cloneDeep(this);\n\n    if (!tx.auth.spendingCondition) {\n      throw new Error('Cannot set signature on transaction without spending condition');\n    }\n\n    tx.auth.spendingCondition.signature = createMessageSignature(parsedSig);\n    return tx;\n  }\n\n  verifyOrigin() {\n    return this.auth.verifyOrigin(this.verifyBegin());\n  }\n\n  signNextOrigin(sigHash, privateKey) {\n    if (this.auth.spendingCondition === undefined) {\n      throw new Error('\"auth.spendingCondition\" is undefined');\n    }\n\n    if (this.auth.authType === undefined) {\n      throw new Error('\"auth.authType\" is undefined');\n    }\n\n    return this.signAndAppend(this.auth.spendingCondition, sigHash, AuthType.Standard, privateKey);\n  }\n\n  signNextSponsor(sigHash, privateKey) {\n    if (this.auth.sponsorSpendingCondition === undefined) {\n      throw new Error('\"auth.spendingCondition\" is undefined');\n    }\n\n    if (this.auth.authType === undefined) {\n      throw new Error('\"auth.authType\" is undefined');\n    }\n\n    return this.signAndAppend(this.auth.sponsorSpendingCondition, sigHash, AuthType.Sponsored, privateKey);\n  }\n\n  appendPubkey(publicKey) {\n    const cond = this.auth.spendingCondition;\n\n    if (cond && !isSingleSig(cond)) {\n      const compressed = isCompressed(publicKey);\n      cond.fields.push(createTransactionAuthField(compressed ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed, publicKey));\n    } else {\n      throw new Error(`Can't append public key to a singlesig condition`);\n    }\n  }\n\n  signAndAppend(condition, curSigHash, authType, privateKey) {\n    const {\n      nextSig,\n      nextSigHash\n    } = nextSignature(curSigHash, authType, condition.fee, condition.nonce, privateKey);\n\n    if (isSingleSig(condition)) {\n      condition.signature = nextSig;\n    } else {\n      const compressed = privateKey.data.toString('hex').endsWith('01');\n      condition.fields.push(createTransactionAuthField(compressed ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed, nextSig));\n    }\n\n    return nextSigHash;\n  }\n\n  txid() {\n    const serialized = this.serialize();\n    return txidFromData(serialized);\n  }\n\n  setSponsor(sponsorSpendingCondition) {\n    if (this.auth.authType != AuthType.Sponsored) {\n      throw new SigningError('Cannot sponsor sign a non-sponsored transaction');\n    }\n\n    this.auth.setSponsor(sponsorSpendingCondition);\n  }\n\n  setFee(amount) {\n    this.auth.setFee(amount);\n  }\n\n  setNonce(nonce) {\n    this.auth.setNonce(nonce);\n  }\n\n  setSponsorNonce(nonce) {\n    this.auth.setSponsorNonce(nonce);\n  }\n\n  serialize() {\n    if (this.version === undefined) {\n      throw new SerializationError('\"version\" is undefined');\n    }\n\n    if (this.chainId === undefined) {\n      throw new SerializationError('\"chainId\" is undefined');\n    }\n\n    if (this.auth === undefined) {\n      throw new SerializationError('\"auth\" is undefined');\n    }\n\n    if (this.anchorMode === undefined) {\n      throw new SerializationError('\"anchorMode\" is undefined');\n    }\n\n    if (this.payload === undefined) {\n      throw new SerializationError('\"payload\" is undefined');\n    }\n\n    const bufferArray = new BufferArray();\n    bufferArray.appendByte(this.version);\n    const chainIdBuffer = Buffer.alloc(4);\n    chainIdBuffer.writeUInt32BE(this.chainId, 0);\n    bufferArray.push(chainIdBuffer);\n    bufferArray.push(this.auth.serialize());\n    bufferArray.appendByte(this.anchorMode);\n    bufferArray.appendByte(this.postConditionMode);\n    bufferArray.push(serializeLPList(this.postConditions));\n    bufferArray.push(serializePayload(this.payload));\n    return bufferArray.concatBuffer();\n  }\n\n}\nexport function deserializeTransaction(data) {\n  let bufferReader;\n\n  if (typeof data === 'string') {\n    if (data.slice(0, 2).toLowerCase() === '0x') {\n      bufferReader = new BufferReader(Buffer.from(data.slice(2), 'hex'));\n    } else {\n      bufferReader = new BufferReader(Buffer.from(data, 'hex'));\n    }\n  } else if (Buffer.isBuffer(data)) {\n    bufferReader = new BufferReader(data);\n  } else {\n    bufferReader = data;\n  }\n\n  const version = bufferReader.readUInt8Enum(TransactionVersion, n => {\n    throw new Error(`Could not parse ${n} as TransactionVersion`);\n  });\n  const chainId = bufferReader.readUInt32BE();\n  const auth = Authorization.deserialize(bufferReader);\n  const anchorMode = bufferReader.readUInt8Enum(AnchorMode, n => {\n    throw new Error(`Could not parse ${n} as AnchorMode`);\n  });\n  const postConditionMode = bufferReader.readUInt8Enum(PostConditionMode, n => {\n    throw new Error(`Could not parse ${n} as PostConditionMode`);\n  });\n  const postConditions = deserializeLPList(bufferReader, StacksMessageType.PostCondition);\n  const payload = deserializePayload(bufferReader);\n  return new StacksTransaction(version, auth, payload, postConditions, postConditionMode, anchorMode, chainId);\n}","map":{"version":3,"sources":["../../src/transaction.ts"],"names":[],"mappings":"AAAA,SAAS,MAAT,EAA8B,WAA9B,QAAiD,gBAAjD;AACA,SACE,UADF,EAEE,QAFF,EAIE,gBAJF,EAKE,WALF,EAME,iBANF,EAOE,cAPF,EAQE,iBARF,EASE,kBATF,QAUO,aAVP;AAYA,SACE,aADF,EAEE,sBAFF,EAGE,0BAHF,EAIE,WAJF,EAKE,aALF,QAQO,iBARP;AAUA,SAAS,WAAT,EAAsB,SAAtB,EAAiC,YAAjC,QAAqD,SAArD;AAEA,SAAS,kBAAT,EAAoD,gBAApD,QAA4E,WAA5E;AAEA,SAAS,YAAT,EAAuB,iBAAvB,EAA8D,eAA9D,QAAqF,SAArF;AAEA,SAAS,YAAT,QAAgE,QAAhE;AAEA,SAAS,YAAT,QAA6B,gBAA7B;AAEA,SAAS,kBAAT,EAA6B,YAA7B,QAAiD,UAAjD;AAEA,OAAM,MAAO,iBAAP,CAAwB;AAS5B,EAAA,WAAA,CACE,OADF,EAEE,IAFF,EAGE,OAHF,EAIE,cAJF,EAKE,iBALF,EAME,UANF,EAOE,OAPF,EAOmB;AAEjB,SAAK,OAAL,GAAe,OAAf;AACA,SAAK,IAAL,GAAY,IAAZ;;AACA,QAAI,YAAY,OAAhB,EAAyB;AACvB,WAAK,OAAL,GAAY,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACP,OADO,CAAA,EACA;AACV,QAAA,MAAM,EAAE,WAAW,CAAC,OAAO,CAAC,MAAT,EAAiB,KAAjB;AADT,OADA,CAAZ;AAID,KALD,MAKO;AACL,WAAK,OAAL,GAAe,OAAf;AACD;;AACD,SAAK,OAAL,GAAe,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAA,OAAA,GAAW,gBAA1B;AACA,SAAK,iBAAL,GAAyB,iBAAiB,KAAA,IAAjB,IAAA,iBAAiB,KAAA,KAAA,CAAjB,GAAA,iBAAA,GAAqB,iBAAiB,CAAC,IAAhE;AACA,SAAK,cAAL,GAAsB,cAAc,KAAA,IAAd,IAAA,cAAc,KAAA,KAAA,CAAd,GAAA,cAAA,GAAkB,YAAY,CAAC,EAAD,CAApD;;AAEA,QAAI,UAAJ,EAAgB;AACd,WAAK,UAAL,GAAkB,UAAlB;AACD,KAFD,MAEO;AACL,cAAQ,OAAO,CAAC,WAAhB;AACE,aAAK,WAAW,CAAC,QAAjB;AACA,aAAK,WAAW,CAAC,gBAAjB;AAAmC;AACjC,iBAAK,UAAL,GAAkB,UAAU,CAAC,WAA7B;AACA;AACD;;AACD,aAAK,WAAW,CAAC,YAAjB;AACA,aAAK,WAAW,CAAC,aAAjB;AACA,aAAK,WAAW,CAAC,aAAjB;AAAgC;AAC9B,iBAAK,UAAL,GAAkB,UAAU,CAAC,GAA7B;AACA;AACD;AAXH;AAaD;AACF;;AAED,EAAA,SAAS,GAAA;AACP,UAAM,EAAE,GAAG,SAAS,CAAC,IAAD,CAApB;AACA,IAAA,EAAE,CAAC,IAAH,GAAU,EAAE,CAAC,IAAH,CAAQ,sBAAR,EAAV;AACA,WAAO,EAAE,CAAC,IAAH,EAAP;AACD;;AAED,EAAA,WAAW,GAAA;AACT,UAAM,EAAE,GAAG,SAAS,CAAC,IAAD,CAApB;AACA,IAAA,EAAE,CAAC,IAAH,GAAU,EAAE,CAAC,IAAH,CAAQ,sBAAR,EAAV;AACA,WAAO,EAAE,CAAC,IAAH,EAAP;AACD;;AAED,EAAA,qBAAqB,CAAC,SAAD,EAA2B;AAC9C,UAAM,SAAS,GAAG,OAAO,SAAP,KAAqB,QAArB,GAAgC,SAAhC,GAA4C,SAAS,CAAC,QAAV,CAAmB,KAAnB,CAA9D;AACA,UAAM,EAAE,GAAG,SAAS,CAAC,IAAD,CAApB;;AACA,QAAI,CAAC,EAAE,CAAC,IAAH,CAAQ,iBAAb,EAAgC;AAC9B,YAAM,IAAI,KAAJ,CAAU,gEAAV,CAAN;AACD;;AACA,IAAA,EAAE,CAAC,IAAH,CAAQ,iBAAR,CAAyD,SAAzD,GACC,sBAAsB,CAAC,SAAD,CADvB;AAED,WAAO,EAAP;AACD;;AAED,EAAA,YAAY,GAAA;AACV,WAAO,KAAK,IAAL,CAAU,YAAV,CAAuB,KAAK,WAAL,EAAvB,CAAP;AACD;;AAED,EAAA,cAAc,CAAC,OAAD,EAAkB,UAAlB,EAA8C;AAC1D,QAAI,KAAK,IAAL,CAAU,iBAAV,KAAgC,SAApC,EAA+C;AAC7C,YAAM,IAAI,KAAJ,CAAU,uCAAV,CAAN;AACD;;AACD,QAAI,KAAK,IAAL,CAAU,QAAV,KAAuB,SAA3B,EAAsC;AACpC,YAAM,IAAI,KAAJ,CAAU,8BAAV,CAAN;AACD;;AACD,WAAO,KAAK,aAAL,CAAmB,KAAK,IAAL,CAAU,iBAA7B,EAAgD,OAAhD,EAAyD,QAAQ,CAAC,QAAlE,EAA4E,UAA5E,CAAP;AACD;;AAED,EAAA,eAAe,CAAC,OAAD,EAAkB,UAAlB,EAA8C;AAC3D,QAAI,KAAK,IAAL,CAAU,wBAAV,KAAuC,SAA3C,EAAsD;AACpD,YAAM,IAAI,KAAJ,CAAU,uCAAV,CAAN;AACD;;AACD,QAAI,KAAK,IAAL,CAAU,QAAV,KAAuB,SAA3B,EAAsC;AACpC,YAAM,IAAI,KAAJ,CAAU,8BAAV,CAAN;AACD;;AACD,WAAO,KAAK,aAAL,CACL,KAAK,IAAL,CAAU,wBADL,EAEL,OAFK,EAGL,QAAQ,CAAC,SAHJ,EAIL,UAJK,CAAP;AAMD;;AAED,EAAA,YAAY,CAAC,SAAD,EAA2B;AACrC,UAAM,IAAI,GAAG,KAAK,IAAL,CAAU,iBAAvB;;AACA,QAAI,IAAI,IAAI,CAAC,WAAW,CAAC,IAAD,CAAxB,EAAgC;AAC9B,YAAM,UAAU,GAAG,YAAY,CAAC,SAAD,CAA/B;AACA,MAAA,IAAI,CAAC,MAAL,CAAY,IAAZ,CACE,0BAA0B,CACxB,UAAU,GAAG,cAAc,CAAC,UAAlB,GAA+B,cAAc,CAAC,YADhC,EAExB,SAFwB,CAD5B;AAMD,KARD,MAQO;AACL,YAAM,IAAI,KAAJ,CAAU,kDAAV,CAAN;AACD;AACF;;AAED,EAAA,aAAa,CACX,SADW,EAEX,UAFW,EAGX,QAHW,EAIX,UAJW,EAIiB;AAE5B,UAAM;AAAE,MAAA,OAAF;AAAW,MAAA;AAAX,QAA2B,aAAa,CAC5C,UAD4C,EAE5C,QAF4C,EAG5C,SAAS,CAAC,GAHkC,EAI5C,SAAS,CAAC,KAJkC,EAK5C,UAL4C,CAA9C;;AAOA,QAAI,WAAW,CAAC,SAAD,CAAf,EAA4B;AAC1B,MAAA,SAAS,CAAC,SAAV,GAAsB,OAAtB;AACD,KAFD,MAEO;AACL,YAAM,UAAU,GAAG,UAAU,CAAC,IAAX,CAAgB,QAAhB,CAAyB,KAAzB,EAAgC,QAAhC,CAAyC,IAAzC,CAAnB;AACA,MAAA,SAAS,CAAC,MAAV,CAAiB,IAAjB,CACE,0BAA0B,CACxB,UAAU,GAAG,cAAc,CAAC,UAAlB,GAA+B,cAAc,CAAC,YADhC,EAExB,OAFwB,CAD5B;AAMD;;AAED,WAAO,WAAP;AACD;;AAED,EAAA,IAAI,GAAA;AACF,UAAM,UAAU,GAAG,KAAK,SAAL,EAAnB;AACA,WAAO,YAAY,CAAC,UAAD,CAAnB;AACD;;AAED,EAAA,UAAU,CAAC,wBAAD,EAAgD;AACxD,QAAI,KAAK,IAAL,CAAU,QAAV,IAAsB,QAAQ,CAAC,SAAnC,EAA8C;AAC5C,YAAM,IAAI,YAAJ,CAAiB,iDAAjB,CAAN;AACD;;AAED,SAAK,IAAL,CAAU,UAAV,CAAqB,wBAArB;AACD;;AAOD,EAAA,MAAM,CAAC,MAAD,EAAoB;AACxB,SAAK,IAAL,CAAU,MAAV,CAAiB,MAAjB;AACD;;AAOD,EAAA,QAAQ,CAAC,KAAD,EAAmB;AACzB,SAAK,IAAL,CAAU,QAAV,CAAmB,KAAnB;AACD;;AAOD,EAAA,eAAe,CAAC,KAAD,EAAmB;AAChC,SAAK,IAAL,CAAU,eAAV,CAA0B,KAA1B;AACD;;AAED,EAAA,SAAS,GAAA;AACP,QAAI,KAAK,OAAL,KAAiB,SAArB,EAAgC;AAC9B,YAAM,IAAI,kBAAJ,CAAuB,wBAAvB,CAAN;AACD;;AACD,QAAI,KAAK,OAAL,KAAiB,SAArB,EAAgC;AAC9B,YAAM,IAAI,kBAAJ,CAAuB,wBAAvB,CAAN;AACD;;AACD,QAAI,KAAK,IAAL,KAAc,SAAlB,EAA6B;AAC3B,YAAM,IAAI,kBAAJ,CAAuB,qBAAvB,CAAN;AACD;;AACD,QAAI,KAAK,UAAL,KAAoB,SAAxB,EAAmC;AACjC,YAAM,IAAI,kBAAJ,CAAuB,2BAAvB,CAAN;AACD;;AACD,QAAI,KAAK,OAAL,KAAiB,SAArB,EAAgC;AAC9B,YAAM,IAAI,kBAAJ,CAAuB,wBAAvB,CAAN;AACD;;AAED,UAAM,WAAW,GAAgB,IAAI,WAAJ,EAAjC;AAEA,IAAA,WAAW,CAAC,UAAZ,CAAuB,KAAK,OAA5B;AACA,UAAM,aAAa,GAAG,MAAM,CAAC,KAAP,CAAa,CAAb,CAAtB;AACA,IAAA,aAAa,CAAC,aAAd,CAA4B,KAAK,OAAjC,EAA0C,CAA1C;AACA,IAAA,WAAW,CAAC,IAAZ,CAAiB,aAAjB;AACA,IAAA,WAAW,CAAC,IAAZ,CAAiB,KAAK,IAAL,CAAU,SAAV,EAAjB;AACA,IAAA,WAAW,CAAC,UAAZ,CAAuB,KAAK,UAA5B;AACA,IAAA,WAAW,CAAC,UAAZ,CAAuB,KAAK,iBAA5B;AACA,IAAA,WAAW,CAAC,IAAZ,CAAiB,eAAe,CAAC,KAAK,cAAN,CAAhC;AACA,IAAA,WAAW,CAAC,IAAZ,CAAiB,gBAAgB,CAAC,KAAK,OAAN,CAAjC;AAEA,WAAO,WAAW,CAAC,YAAZ,EAAP;AACD;;AAxN2B;AA8N9B,OAAM,SAAU,sBAAV,CAAiC,IAAjC,EAAqE;AACzE,MAAI,YAAJ;;AACA,MAAI,OAAO,IAAP,KAAgB,QAApB,EAA8B;AAC5B,QAAI,IAAI,CAAC,KAAL,CAAW,CAAX,EAAc,CAAd,EAAiB,WAAjB,OAAmC,IAAvC,EAA6C;AAC3C,MAAA,YAAY,GAAG,IAAI,YAAJ,CAAiB,MAAM,CAAC,IAAP,CAAY,IAAI,CAAC,KAAL,CAAW,CAAX,CAAZ,EAA2B,KAA3B,CAAjB,CAAf;AACD,KAFD,MAEO;AACL,MAAA,YAAY,GAAG,IAAI,YAAJ,CAAiB,MAAM,CAAC,IAAP,CAAY,IAAZ,EAAkB,KAAlB,CAAjB,CAAf;AACD;AACF,GAND,MAMO,IAAI,MAAM,CAAC,QAAP,CAAgB,IAAhB,CAAJ,EAA2B;AAChC,IAAA,YAAY,GAAG,IAAI,YAAJ,CAAiB,IAAjB,CAAf;AACD,GAFM,MAEA;AACL,IAAA,YAAY,GAAG,IAAf;AACD;;AACD,QAAM,OAAO,GAAG,YAAY,CAAC,aAAb,CAA2B,kBAA3B,EAA+C,CAAC,IAAG;AACjE,UAAM,IAAI,KAAJ,CAAU,mBAAmB,CAAC,wBAA9B,CAAN;AACD,GAFe,CAAhB;AAGA,QAAM,OAAO,GAAG,YAAY,CAAC,YAAb,EAAhB;AACA,QAAM,IAAI,GAAG,aAAa,CAAC,WAAd,CAA0B,YAA1B,CAAb;AACA,QAAM,UAAU,GAAG,YAAY,CAAC,aAAb,CAA2B,UAA3B,EAAuC,CAAC,IAAG;AAC5D,UAAM,IAAI,KAAJ,CAAU,mBAAmB,CAAC,gBAA9B,CAAN;AACD,GAFkB,CAAnB;AAGA,QAAM,iBAAiB,GAAG,YAAY,CAAC,aAAb,CAA2B,iBAA3B,EAA8C,CAAC,IAAG;AAC1E,UAAM,IAAI,KAAJ,CAAU,mBAAmB,CAAC,uBAA9B,CAAN;AACD,GAFyB,CAA1B;AAGA,QAAM,cAAc,GAAG,iBAAiB,CAAC,YAAD,EAAe,iBAAiB,CAAC,aAAjC,CAAxC;AACA,QAAM,OAAO,GAAG,kBAAkB,CAAC,YAAD,CAAlC;AAEA,SAAO,IAAI,iBAAJ,CACL,OADK,EAEL,IAFK,EAGL,OAHK,EAIL,cAJK,EAKL,iBALK,EAML,UANK,EAOL,OAPK,CAAP;AASD","sourceRoot":"","sourcesContent":["import { Buffer, intToBigInt } from '@stacks/common';\nimport { AnchorMode, AuthType, DEFAULT_CHAIN_ID, PayloadType, PostConditionMode, PubKeyEncoding, StacksMessageType, TransactionVersion, } from './constants';\nimport { Authorization, createMessageSignature, createTransactionAuthField, isSingleSig, nextSignature, } from './authorization';\nimport { BufferArray, cloneDeep, txidFromData } from './utils';\nimport { deserializePayload, serializePayload } from './payload';\nimport { createLPList, deserializeLPList, serializeLPList } from './types';\nimport { isCompressed } from './keys';\nimport { BufferReader } from './bufferReader';\nimport { SerializationError, SigningError } from './errors';\nexport class StacksTransaction {\n    constructor(version, auth, payload, postConditions, postConditionMode, anchorMode, chainId) {\n        this.version = version;\n        this.auth = auth;\n        if ('amount' in payload) {\n            this.payload = Object.assign(Object.assign({}, payload), { amount: intToBigInt(payload.amount, false) });\n        }\n        else {\n            this.payload = payload;\n        }\n        this.chainId = chainId !== null && chainId !== void 0 ? chainId : DEFAULT_CHAIN_ID;\n        this.postConditionMode = postConditionMode !== null && postConditionMode !== void 0 ? postConditionMode : PostConditionMode.Deny;\n        this.postConditions = postConditions !== null && postConditions !== void 0 ? postConditions : createLPList([]);\n        if (anchorMode) {\n            this.anchorMode = anchorMode;\n        }\n        else {\n            switch (payload.payloadType) {\n                case PayloadType.Coinbase:\n                case PayloadType.PoisonMicroblock: {\n                    this.anchorMode = AnchorMode.OnChainOnly;\n                    break;\n                }\n                case PayloadType.ContractCall:\n                case PayloadType.SmartContract:\n                case PayloadType.TokenTransfer: {\n                    this.anchorMode = AnchorMode.Any;\n                    break;\n                }\n            }\n        }\n    }\n    signBegin() {\n        const tx = cloneDeep(this);\n        tx.auth = tx.auth.intoInitialSighashAuth();\n        return tx.txid();\n    }\n    verifyBegin() {\n        const tx = cloneDeep(this);\n        tx.auth = tx.auth.intoInitialSighashAuth();\n        return tx.txid();\n    }\n    createTxWithSignature(signature) {\n        const parsedSig = typeof signature === 'string' ? signature : signature.toString('hex');\n        const tx = cloneDeep(this);\n        if (!tx.auth.spendingCondition) {\n            throw new Error('Cannot set signature on transaction without spending condition');\n        }\n        tx.auth.spendingCondition.signature =\n            createMessageSignature(parsedSig);\n        return tx;\n    }\n    verifyOrigin() {\n        return this.auth.verifyOrigin(this.verifyBegin());\n    }\n    signNextOrigin(sigHash, privateKey) {\n        if (this.auth.spendingCondition === undefined) {\n            throw new Error('\"auth.spendingCondition\" is undefined');\n        }\n        if (this.auth.authType === undefined) {\n            throw new Error('\"auth.authType\" is undefined');\n        }\n        return this.signAndAppend(this.auth.spendingCondition, sigHash, AuthType.Standard, privateKey);\n    }\n    signNextSponsor(sigHash, privateKey) {\n        if (this.auth.sponsorSpendingCondition === undefined) {\n            throw new Error('\"auth.spendingCondition\" is undefined');\n        }\n        if (this.auth.authType === undefined) {\n            throw new Error('\"auth.authType\" is undefined');\n        }\n        return this.signAndAppend(this.auth.sponsorSpendingCondition, sigHash, AuthType.Sponsored, privateKey);\n    }\n    appendPubkey(publicKey) {\n        const cond = this.auth.spendingCondition;\n        if (cond && !isSingleSig(cond)) {\n            const compressed = isCompressed(publicKey);\n            cond.fields.push(createTransactionAuthField(compressed ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed, publicKey));\n        }\n        else {\n            throw new Error(`Can't append public key to a singlesig condition`);\n        }\n    }\n    signAndAppend(condition, curSigHash, authType, privateKey) {\n        const { nextSig, nextSigHash } = nextSignature(curSigHash, authType, condition.fee, condition.nonce, privateKey);\n        if (isSingleSig(condition)) {\n            condition.signature = nextSig;\n        }\n        else {\n            const compressed = privateKey.data.toString('hex').endsWith('01');\n            condition.fields.push(createTransactionAuthField(compressed ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed, nextSig));\n        }\n        return nextSigHash;\n    }\n    txid() {\n        const serialized = this.serialize();\n        return txidFromData(serialized);\n    }\n    setSponsor(sponsorSpendingCondition) {\n        if (this.auth.authType != AuthType.Sponsored) {\n            throw new SigningError('Cannot sponsor sign a non-sponsored transaction');\n        }\n        this.auth.setSponsor(sponsorSpendingCondition);\n    }\n    setFee(amount) {\n        this.auth.setFee(amount);\n    }\n    setNonce(nonce) {\n        this.auth.setNonce(nonce);\n    }\n    setSponsorNonce(nonce) {\n        this.auth.setSponsorNonce(nonce);\n    }\n    serialize() {\n        if (this.version === undefined) {\n            throw new SerializationError('\"version\" is undefined');\n        }\n        if (this.chainId === undefined) {\n            throw new SerializationError('\"chainId\" is undefined');\n        }\n        if (this.auth === undefined) {\n            throw new SerializationError('\"auth\" is undefined');\n        }\n        if (this.anchorMode === undefined) {\n            throw new SerializationError('\"anchorMode\" is undefined');\n        }\n        if (this.payload === undefined) {\n            throw new SerializationError('\"payload\" is undefined');\n        }\n        const bufferArray = new BufferArray();\n        bufferArray.appendByte(this.version);\n        const chainIdBuffer = Buffer.alloc(4);\n        chainIdBuffer.writeUInt32BE(this.chainId, 0);\n        bufferArray.push(chainIdBuffer);\n        bufferArray.push(this.auth.serialize());\n        bufferArray.appendByte(this.anchorMode);\n        bufferArray.appendByte(this.postConditionMode);\n        bufferArray.push(serializeLPList(this.postConditions));\n        bufferArray.push(serializePayload(this.payload));\n        return bufferArray.concatBuffer();\n    }\n}\nexport function deserializeTransaction(data) {\n    let bufferReader;\n    if (typeof data === 'string') {\n        if (data.slice(0, 2).toLowerCase() === '0x') {\n            bufferReader = new BufferReader(Buffer.from(data.slice(2), 'hex'));\n        }\n        else {\n            bufferReader = new BufferReader(Buffer.from(data, 'hex'));\n        }\n    }\n    else if (Buffer.isBuffer(data)) {\n        bufferReader = new BufferReader(data);\n    }\n    else {\n        bufferReader = data;\n    }\n    const version = bufferReader.readUInt8Enum(TransactionVersion, n => {\n        throw new Error(`Could not parse ${n} as TransactionVersion`);\n    });\n    const chainId = bufferReader.readUInt32BE();\n    const auth = Authorization.deserialize(bufferReader);\n    const anchorMode = bufferReader.readUInt8Enum(AnchorMode, n => {\n        throw new Error(`Could not parse ${n} as AnchorMode`);\n    });\n    const postConditionMode = bufferReader.readUInt8Enum(PostConditionMode, n => {\n        throw new Error(`Could not parse ${n} as PostConditionMode`);\n    });\n    const postConditions = deserializeLPList(bufferReader, StacksMessageType.PostCondition);\n    const payload = deserializePayload(bufferReader);\n    return new StacksTransaction(version, auth, payload, postConditions, postConditionMode, anchorMode, chainId);\n}\n//# sourceMappingURL=transaction.js.map"]},"metadata":{},"sourceType":"module"}