{"ast":null,"code":"import { Buffer, intToBigInt, intToBytes } from '@stacks/common';\nimport { COINBASE_BUFFER_LENGTH_BYTES, PayloadType, StacksMessageType } from './constants';\nimport { BufferArray } from './utils';\nimport { createAddress, createMemoString, createLPString, serializeStacksMessage, deserializeAddress, deserializeLPString, deserializeMemoString, codeBodyString } from './types';\nimport { serializeCV, deserializeCV } from './clarity/';\nimport { principalCV } from './clarity/types/principalCV';\nexport function createTokenTransferPayload(recipient, amount, memo) {\n  if (typeof recipient === 'string') {\n    recipient = principalCV(recipient);\n  }\n\n  if (typeof memo === 'string') {\n    memo = createMemoString(memo);\n  }\n\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.TokenTransfer,\n    recipient,\n    amount: intToBigInt(amount, false),\n    memo: memo !== null && memo !== void 0 ? memo : createMemoString('')\n  };\n}\nexport function createContractCallPayload(contractAddress, contractName, functionName, functionArgs) {\n  if (typeof contractAddress === 'string') {\n    contractAddress = createAddress(contractAddress);\n  }\n\n  if (typeof contractName === 'string') {\n    contractName = createLPString(contractName);\n  }\n\n  if (typeof functionName === 'string') {\n    functionName = createLPString(functionName);\n  }\n\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.ContractCall,\n    contractAddress,\n    contractName,\n    functionName,\n    functionArgs\n  };\n}\nexport function createSmartContractPayload(contractName, codeBody) {\n  if (typeof contractName === 'string') {\n    contractName = createLPString(contractName);\n  }\n\n  if (typeof codeBody === 'string') {\n    codeBody = codeBodyString(codeBody);\n  }\n\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.SmartContract,\n    contractName,\n    codeBody\n  };\n}\nexport function createPoisonPayload() {\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.PoisonMicroblock\n  };\n}\nexport function createCoinbasePayload(coinbaseBuffer) {\n  if (coinbaseBuffer.byteLength != COINBASE_BUFFER_LENGTH_BYTES) {\n    throw Error(`Coinbase buffer size must be ${COINBASE_BUFFER_LENGTH_BYTES} bytes`);\n  }\n\n  return {\n    type: StacksMessageType.Payload,\n    payloadType: PayloadType.Coinbase,\n    coinbaseBuffer\n  };\n}\nexport function serializePayload(payload) {\n  const bufferArray = new BufferArray();\n  bufferArray.appendByte(payload.payloadType);\n\n  switch (payload.payloadType) {\n    case PayloadType.TokenTransfer:\n      bufferArray.push(serializeCV(payload.recipient));\n      bufferArray.push(intToBytes(payload.amount, false, 8));\n      bufferArray.push(serializeStacksMessage(payload.memo));\n      break;\n\n    case PayloadType.ContractCall:\n      bufferArray.push(serializeStacksMessage(payload.contractAddress));\n      bufferArray.push(serializeStacksMessage(payload.contractName));\n      bufferArray.push(serializeStacksMessage(payload.functionName));\n      const numArgs = Buffer.alloc(4);\n      numArgs.writeUInt32BE(payload.functionArgs.length, 0);\n      bufferArray.push(numArgs);\n      payload.functionArgs.forEach(arg => {\n        bufferArray.push(serializeCV(arg));\n      });\n      break;\n\n    case PayloadType.SmartContract:\n      bufferArray.push(serializeStacksMessage(payload.contractName));\n      bufferArray.push(serializeStacksMessage(payload.codeBody));\n      break;\n\n    case PayloadType.PoisonMicroblock:\n      break;\n\n    case PayloadType.Coinbase:\n      bufferArray.push(payload.coinbaseBuffer);\n      break;\n  }\n\n  return bufferArray.concatBuffer();\n}\nexport function deserializePayload(bufferReader) {\n  const payloadType = bufferReader.readUInt8Enum(PayloadType, n => {\n    throw new Error(`Cannot recognize PayloadType: ${n}`);\n  });\n\n  switch (payloadType) {\n    case PayloadType.TokenTransfer:\n      const recipient = deserializeCV(bufferReader);\n      const amount = intToBigInt(bufferReader.readBuffer(8), false);\n      const memo = deserializeMemoString(bufferReader);\n      return createTokenTransferPayload(recipient, amount, memo);\n\n    case PayloadType.ContractCall:\n      const contractAddress = deserializeAddress(bufferReader);\n      const contractCallName = deserializeLPString(bufferReader);\n      const functionName = deserializeLPString(bufferReader);\n      const functionArgs = [];\n      const numberOfArgs = bufferReader.readUInt32BE();\n\n      for (let i = 0; i < numberOfArgs; i++) {\n        const clarityValue = deserializeCV(bufferReader);\n        functionArgs.push(clarityValue);\n      }\n\n      return createContractCallPayload(contractAddress, contractCallName, functionName, functionArgs);\n\n    case PayloadType.SmartContract:\n      const smartContractName = deserializeLPString(bufferReader);\n      const codeBody = deserializeLPString(bufferReader, 4, 100000);\n      return createSmartContractPayload(smartContractName, codeBody);\n\n    case PayloadType.PoisonMicroblock:\n      return createPoisonPayload();\n\n    case PayloadType.Coinbase:\n      const coinbaseBuffer = bufferReader.readBuffer(COINBASE_BUFFER_LENGTH_BYTES);\n      return createCoinbasePayload(coinbaseBuffer);\n  }\n}","map":{"version":3,"sources":["../../src/payload.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Buffer, intToBigInt, intToBytes } from '@stacks/common';\nimport { COINBASE_BUFFER_LENGTH_BYTES, PayloadType, StacksMessageType } from './constants';\nimport { BufferArray } from './utils';\nimport { createAddress, createMemoString, createLPString, serializeStacksMessage, deserializeAddress, deserializeLPString, deserializeMemoString, codeBodyString, } from './types';\nimport { serializeCV, deserializeCV } from './clarity/';\nimport { principalCV } from './clarity/types/principalCV';\nexport function createTokenTransferPayload(recipient, amount, memo) {\n    if (typeof recipient === 'string') {\n        recipient = principalCV(recipient);\n    }\n    if (typeof memo === 'string') {\n        memo = createMemoString(memo);\n    }\n    return {\n        type: StacksMessageType.Payload,\n        payloadType: PayloadType.TokenTransfer,\n        recipient,\n        amount: intToBigInt(amount, false),\n        memo: memo !== null && memo !== void 0 ? memo : createMemoString(''),\n    };\n}\nexport function createContractCallPayload(contractAddress, contractName, functionName, functionArgs) {\n    if (typeof contractAddress === 'string') {\n        contractAddress = createAddress(contractAddress);\n    }\n    if (typeof contractName === 'string') {\n        contractName = createLPString(contractName);\n    }\n    if (typeof functionName === 'string') {\n        functionName = createLPString(functionName);\n    }\n    return {\n        type: StacksMessageType.Payload,\n        payloadType: PayloadType.ContractCall,\n        contractAddress,\n        contractName,\n        functionName,\n        functionArgs,\n    };\n}\nexport function createSmartContractPayload(contractName, codeBody) {\n    if (typeof contractName === 'string') {\n        contractName = createLPString(contractName);\n    }\n    if (typeof codeBody === 'string') {\n        codeBody = codeBodyString(codeBody);\n    }\n    return {\n        type: StacksMessageType.Payload,\n        payloadType: PayloadType.SmartContract,\n        contractName,\n        codeBody,\n    };\n}\nexport function createPoisonPayload() {\n    return { type: StacksMessageType.Payload, payloadType: PayloadType.PoisonMicroblock };\n}\nexport function createCoinbasePayload(coinbaseBuffer) {\n    if (coinbaseBuffer.byteLength != COINBASE_BUFFER_LENGTH_BYTES) {\n        throw Error(`Coinbase buffer size must be ${COINBASE_BUFFER_LENGTH_BYTES} bytes`);\n    }\n    return { type: StacksMessageType.Payload, payloadType: PayloadType.Coinbase, coinbaseBuffer };\n}\nexport function serializePayload(payload) {\n    const bufferArray = new BufferArray();\n    bufferArray.appendByte(payload.payloadType);\n    switch (payload.payloadType) {\n        case PayloadType.TokenTransfer:\n            bufferArray.push(serializeCV(payload.recipient));\n            bufferArray.push(intToBytes(payload.amount, false, 8));\n            bufferArray.push(serializeStacksMessage(payload.memo));\n            break;\n        case PayloadType.ContractCall:\n            bufferArray.push(serializeStacksMessage(payload.contractAddress));\n            bufferArray.push(serializeStacksMessage(payload.contractName));\n            bufferArray.push(serializeStacksMessage(payload.functionName));\n            const numArgs = Buffer.alloc(4);\n            numArgs.writeUInt32BE(payload.functionArgs.length, 0);\n            bufferArray.push(numArgs);\n            payload.functionArgs.forEach(arg => {\n                bufferArray.push(serializeCV(arg));\n            });\n            break;\n        case PayloadType.SmartContract:\n            bufferArray.push(serializeStacksMessage(payload.contractName));\n            bufferArray.push(serializeStacksMessage(payload.codeBody));\n            break;\n        case PayloadType.PoisonMicroblock:\n            break;\n        case PayloadType.Coinbase:\n            bufferArray.push(payload.coinbaseBuffer);\n            break;\n    }\n    return bufferArray.concatBuffer();\n}\nexport function deserializePayload(bufferReader) {\n    const payloadType = bufferReader.readUInt8Enum(PayloadType, n => {\n        throw new Error(`Cannot recognize PayloadType: ${n}`);\n    });\n    switch (payloadType) {\n        case PayloadType.TokenTransfer:\n            const recipient = deserializeCV(bufferReader);\n            const amount = intToBigInt(bufferReader.readBuffer(8), false);\n            const memo = deserializeMemoString(bufferReader);\n            return createTokenTransferPayload(recipient, amount, memo);\n        case PayloadType.ContractCall:\n            const contractAddress = deserializeAddress(bufferReader);\n            const contractCallName = deserializeLPString(bufferReader);\n            const functionName = deserializeLPString(bufferReader);\n            const functionArgs = [];\n            const numberOfArgs = bufferReader.readUInt32BE();\n            for (let i = 0; i < numberOfArgs; i++) {\n                const clarityValue = deserializeCV(bufferReader);\n                functionArgs.push(clarityValue);\n            }\n            return createContractCallPayload(contractAddress, contractCallName, functionName, functionArgs);\n        case PayloadType.SmartContract:\n            const smartContractName = deserializeLPString(bufferReader);\n            const codeBody = deserializeLPString(bufferReader, 4, 100000);\n            return createSmartContractPayload(smartContractName, codeBody);\n        case PayloadType.PoisonMicroblock:\n            return createPoisonPayload();\n        case PayloadType.Coinbase:\n            const coinbaseBuffer = bufferReader.readBuffer(COINBASE_BUFFER_LENGTH_BYTES);\n            return createCoinbasePayload(coinbaseBuffer);\n    }\n}\n//# sourceMappingURL=payload.js.map"]},"metadata":{},"sourceType":"module"}