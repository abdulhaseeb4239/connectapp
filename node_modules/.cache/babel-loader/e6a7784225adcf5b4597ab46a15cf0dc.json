{"ast":null,"code":"import { Buffer } from '@stacks/common';\nimport { ec as EllipticCurve } from 'elliptic';\nimport { randomBytes } from './cryptoRandom';\nimport { FailedDecryptionError } from '@stacks/common';\nimport { getPublicKeyFromPrivate } from './keys';\nimport { hashSha256Sync, hashSha512Sync } from './sha2Hash';\nimport { createHmacSha256 } from './hmacSha256';\nimport { createCipher } from './aesCipher';\nimport { getAesCbcOutputLength, getBase64OutputLength } from './utils';\nconst ecurve = new EllipticCurve('secp256k1');\nexport var InvalidPublicKeyReason;\n\n(function (InvalidPublicKeyReason) {\n  InvalidPublicKeyReason[\"InvalidFormat\"] = \"InvalidFormat\";\n  InvalidPublicKeyReason[\"IsNotPoint\"] = \"IsNotPoint\";\n})(InvalidPublicKeyReason || (InvalidPublicKeyReason = {}));\n\nexport async function aes256CbcEncrypt(iv, key, plaintext) {\n  const cipher = await createCipher();\n  const result = await cipher.encrypt('aes-256-cbc', key, iv, plaintext);\n  return result;\n}\n\nasync function aes256CbcDecrypt(iv, key, ciphertext) {\n  const cipher = await createCipher();\n  const result = await cipher.decrypt('aes-256-cbc', key, iv, ciphertext);\n  return result;\n}\n\nasync function hmacSha256(key, content) {\n  const hmacSha256 = await createHmacSha256();\n  return hmacSha256.digest(key, content);\n}\n\nfunction equalConstTime(b1, b2) {\n  if (b1.length !== b2.length) {\n    return false;\n  }\n\n  let res = 0;\n\n  for (let i = 0; i < b1.length; i++) {\n    res |= b1[i] ^ b2[i];\n  }\n\n  return res === 0;\n}\n\nfunction sharedSecretToKeys(sharedSecret) {\n  const hashedSecret = hashSha512Sync(sharedSecret);\n  return {\n    encryptionKey: hashedSecret.slice(0, 32),\n    hmacKey: hashedSecret.slice(32)\n  };\n}\n\nfunction allHexChars(maybe) {\n  return maybe.match(/^[0-9a-f]+$/i) !== null;\n}\n\nfunction isValidPublicKey(pub) {\n  const invalidFormat = {\n    result: false,\n    reason_data: 'Invalid public key format',\n    reason: InvalidPublicKeyReason.InvalidFormat\n  };\n  const invalidPoint = {\n    result: false,\n    reason_data: 'Public key is not a point',\n    reason: InvalidPublicKeyReason.IsNotPoint\n  };\n  if (pub.length !== 66 && pub.length !== 130) return invalidFormat;\n  const firstByte = pub.slice(0, 2);\n  if (pub.length === 130 && firstByte !== '04') return invalidFormat;\n  if (pub.length === 66 && firstByte !== '02' && firstByte !== '03') return invalidFormat;\n  if (!allHexChars(pub)) return invalidFormat;\n  const secp256k1 = new EllipticCurve('secp256k1');\n\n  try {\n    const keyPair = secp256k1.keyFromPublic(Buffer.from(pub, 'hex'));\n    const result = keyPair.validate();\n    return {\n      result: result.result,\n      reason_data: result.reason,\n      reason: result.result ? null : InvalidPublicKeyReason.IsNotPoint\n    };\n  } catch (e) {\n    return invalidPoint;\n  }\n}\n\nexport function getHexFromBN(bnInput) {\n  const hexOut = bnInput.toString('hex', 64);\n\n  if (hexOut.length === 64) {\n    return hexOut;\n  } else if (hexOut.length < 64) {\n    const padding = '0'.repeat(64 - hexOut.length);\n    return `${padding}${hexOut}`;\n  } else {\n    throw new Error('Generated a > 32-byte BN for encryption. Failing.');\n  }\n}\nexport function getBufferFromBN(bnInput) {\n  const result = bnInput.toArrayLike(Buffer, 'be', 32);\n\n  if (result.byteLength !== 32) {\n    throw new Error('Failed to generate a 32-byte BN');\n  }\n\n  return result;\n}\nexport function getCipherObjectWrapper(opts) {\n  const shell = {\n    iv: '',\n    ephemeralPK: '',\n    mac: '',\n    cipherText: '',\n    wasString: !!opts.wasString\n  };\n\n  if (opts.cipherTextEncoding === 'base64') {\n    shell.cipherTextEncoding = 'base64';\n  }\n\n  const ivLength = 32;\n  const ephemeralPKLength = 66;\n  const macLength = 64;\n  return {\n    payloadValuesLength: ivLength + ephemeralPKLength + macLength,\n    payloadShell: JSON.stringify(shell)\n  };\n}\nexport function getSignedCipherObjectWrapper(payloadShell) {\n  const shell = {\n    signature: '',\n    publicKey: '',\n    cipherText: payloadShell\n  };\n  const signatureLength = 144;\n  const publicKeyLength = 66;\n  return {\n    signedPayloadValuesLength: signatureLength + publicKeyLength,\n    signedPayloadShell: JSON.stringify(shell)\n  };\n}\nexport function eciesGetJsonStringLength(opts) {\n  const {\n    payloadShell,\n    payloadValuesLength\n  } = getCipherObjectWrapper(opts);\n  const cipherTextLength = getAesCbcOutputLength(opts.contentLength);\n  let encodedCipherTextLength;\n\n  if (!opts.cipherTextEncoding || opts.cipherTextEncoding === 'hex') {\n    encodedCipherTextLength = cipherTextLength * 2;\n  } else if (opts.cipherTextEncoding === 'base64') {\n    encodedCipherTextLength = getBase64OutputLength(cipherTextLength);\n  } else {\n    throw new Error(`Unexpected cipherTextEncoding \"${opts.cipherTextEncoding}\"`);\n  }\n\n  if (!opts.sign) {\n    return payloadShell.length + payloadValuesLength + encodedCipherTextLength;\n  } else {\n    const {\n      signedPayloadShell,\n      signedPayloadValuesLength\n    } = getSignedCipherObjectWrapper(payloadShell);\n    return signedPayloadShell.length + signedPayloadValuesLength + payloadValuesLength + encodedCipherTextLength;\n  }\n}\nexport async function encryptECIES(publicKey, content, wasString, cipherTextEncoding) {\n  const validity = isValidPublicKey(publicKey);\n\n  if (!validity.result) {\n    throw validity;\n  }\n\n  const ecPK = ecurve.keyFromPublic(publicKey, 'hex').getPublic();\n  const ephemeralSK = ecurve.genKeyPair();\n  const ephemeralPK = Buffer.from(ephemeralSK.getPublic().encodeCompressed());\n  const sharedSecret = ephemeralSK.derive(ecPK);\n  const sharedSecretBuffer = getBufferFromBN(sharedSecret);\n  const sharedKeys = sharedSecretToKeys(sharedSecretBuffer);\n  const initializationVector = randomBytes(16);\n  const cipherText = await aes256CbcEncrypt(initializationVector, sharedKeys.encryptionKey, content);\n  const macData = Buffer.concat([initializationVector, ephemeralPK, cipherText]);\n  const mac = await hmacSha256(sharedKeys.hmacKey, macData);\n  let cipherTextString;\n\n  if (!cipherTextEncoding || cipherTextEncoding === 'hex') {\n    cipherTextString = cipherText.toString('hex');\n  } else if (cipherTextEncoding === 'base64') {\n    cipherTextString = cipherText.toString('base64');\n  } else {\n    throw new Error(`Unexpected cipherTextEncoding \"${cipherTextEncoding}\"`);\n  }\n\n  const result = {\n    iv: initializationVector.toString('hex'),\n    ephemeralPK: ephemeralPK.toString('hex'),\n    cipherText: cipherTextString,\n    mac: mac.toString('hex'),\n    wasString: !!wasString\n  };\n\n  if (cipherTextEncoding && cipherTextEncoding !== 'hex') {\n    result.cipherTextEncoding = cipherTextEncoding;\n  }\n\n  return result;\n}\nexport async function decryptECIES(privateKey, cipherObject) {\n  const ecSK = ecurve.keyFromPrivate(privateKey, 'hex');\n  let ephemeralPK = null;\n\n  try {\n    ephemeralPK = ecurve.keyFromPublic(cipherObject.ephemeralPK, 'hex').getPublic();\n  } catch (error) {\n    throw new FailedDecryptionError('Unable to get public key from cipher object. ' + 'You might be trying to decrypt an unencrypted object.');\n  }\n\n  const sharedSecret = ecSK.derive(ephemeralPK);\n  const sharedSecretBuffer = getBufferFromBN(sharedSecret);\n  const sharedKeys = sharedSecretToKeys(sharedSecretBuffer);\n  const ivBuffer = Buffer.from(cipherObject.iv, 'hex');\n  let cipherTextBuffer;\n\n  if (!cipherObject.cipherTextEncoding || cipherObject.cipherTextEncoding === 'hex') {\n    cipherTextBuffer = Buffer.from(cipherObject.cipherText, 'hex');\n  } else if (cipherObject.cipherTextEncoding === 'base64') {\n    cipherTextBuffer = Buffer.from(cipherObject.cipherText, 'base64');\n  } else {\n    throw new Error(`Unexpected cipherTextEncoding \"${cipherObject.cipherText}\"`);\n  }\n\n  const macData = Buffer.concat([ivBuffer, Buffer.from(ephemeralPK.encodeCompressed()), cipherTextBuffer]);\n  const actualMac = await hmacSha256(sharedKeys.hmacKey, macData);\n  const expectedMac = Buffer.from(cipherObject.mac, 'hex');\n\n  if (!equalConstTime(expectedMac, actualMac)) {\n    throw new FailedDecryptionError('Decryption failed: failure in MAC check');\n  }\n\n  const plainText = await aes256CbcDecrypt(ivBuffer, sharedKeys.encryptionKey, cipherTextBuffer);\n\n  if (cipherObject.wasString) {\n    return plainText.toString();\n  } else {\n    return plainText;\n  }\n}\nexport function signECDSA(privateKey, content) {\n  const contentBuffer = content instanceof Buffer ? content : Buffer.from(content);\n  const ecPrivate = ecurve.keyFromPrivate(privateKey, 'hex');\n  const publicKey = getPublicKeyFromPrivate(privateKey);\n  const contentHash = hashSha256Sync(contentBuffer);\n  const signature = ecPrivate.sign(contentHash);\n  const signatureString = signature.toDER('hex');\n  return {\n    signature: signatureString,\n    publicKey\n  };\n}\n\nfunction getBuffer(content) {\n  if (content instanceof Buffer) return content;else if (content instanceof ArrayBuffer) return Buffer.from(content);else return Buffer.from(content);\n}\n\nexport function verifyECDSA(content, publicKey, signature) {\n  const contentBuffer = getBuffer(content);\n  const ecPublic = ecurve.keyFromPublic(publicKey, 'hex');\n  const contentHash = hashSha256Sync(contentBuffer);\n  return ecPublic.verify(contentHash, signature);\n}","map":{"version":3,"sources":["../../src/ec.ts"],"names":[],"mappings":"AAAA,SAAS,MAAT,QAAuB,gBAAvB;AACA,SAAS,EAAE,IAAI,aAAf,QAAoC,UAApC;AAEA,SAAS,WAAT,QAA4B,gBAA5B;AACA,SAAS,qBAAT,QAAsC,gBAAtC;AACA,SAAS,uBAAT,QAAwC,QAAxC;AACA,SAAS,cAAT,EAAyB,cAAzB,QAA+C,YAA/C;AACA,SAAS,gBAAT,QAAiC,cAAjC;AACA,SAAS,YAAT,QAA6B,aAA7B;AACA,SAAS,qBAAT,EAAgC,qBAAhC,QAA6D,SAA7D;AAEA,MAAM,MAAM,GAAG,IAAI,aAAJ,CAAkB,WAAlB,CAAf;AAuCA,OAAA,IAAY,sBAAZ;;AAAA,CAAA,UAAY,sBAAZ,EAAkC;AAChC,EAAA,sBAAA,CAAA,eAAA,CAAA,GAAA,eAAA;AACA,EAAA,sBAAA,CAAA,YAAA,CAAA,GAAA,YAAA;AACD,CAHD,EAAY,sBAAsB,KAAtB,sBAAsB,GAAA,EAAA,CAAlC;;AAQA,OAAO,eAAe,gBAAf,CACL,EADK,EAEL,GAFK,EAGL,SAHK,EAGY;AAEjB,QAAM,MAAM,GAAG,MAAM,YAAY,EAAjC;AACA,QAAM,MAAM,GAAG,MAAM,MAAM,CAAC,OAAP,CAAe,aAAf,EAA8B,GAA9B,EAAmC,EAAnC,EAAuC,SAAvC,CAArB;AACA,SAAO,MAAP;AACD;;AAKD,eAAe,gBAAf,CAAgC,EAAhC,EAA4C,GAA5C,EAAyD,UAAzD,EAA2E;AACzE,QAAM,MAAM,GAAG,MAAM,YAAY,EAAjC;AACA,QAAM,MAAM,GAAG,MAAM,MAAM,CAAC,OAAP,CAAe,aAAf,EAA8B,GAA9B,EAAmC,EAAnC,EAAuC,UAAvC,CAArB;AACA,SAAO,MAAP;AACD;;AAKD,eAAe,UAAf,CAA0B,GAA1B,EAAuC,OAAvC,EAAsD;AACpD,QAAM,UAAU,GAAG,MAAM,gBAAgB,EAAzC;AACA,SAAO,UAAU,CAAC,MAAX,CAAkB,GAAlB,EAAuB,OAAvB,CAAP;AACD;;AAKD,SAAS,cAAT,CAAwB,EAAxB,EAAoC,EAApC,EAA8C;AAC5C,MAAI,EAAE,CAAC,MAAH,KAAc,EAAE,CAAC,MAArB,EAA6B;AAC3B,WAAO,KAAP;AACD;;AACD,MAAI,GAAG,GAAG,CAAV;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,EAAE,CAAC,MAAvB,EAA+B,CAAC,EAAhC,EAAoC;AAClC,IAAA,GAAG,IAAI,EAAE,CAAC,CAAD,CAAF,GAAQ,EAAE,CAAC,CAAD,CAAjB;AACD;;AACD,SAAO,GAAG,KAAK,CAAf;AACD;;AAKD,SAAS,kBAAT,CAA4B,YAA5B,EAAgD;AAE9C,QAAM,YAAY,GAAG,cAAc,CAAC,YAAD,CAAnC;AACA,SAAO;AACL,IAAA,aAAa,EAAE,YAAY,CAAC,KAAb,CAAmB,CAAnB,EAAsB,EAAtB,CADV;AAEL,IAAA,OAAO,EAAE,YAAY,CAAC,KAAb,CAAmB,EAAnB;AAFJ,GAAP;AAID;;AAKD,SAAS,WAAT,CAAqB,KAArB,EAAkC;AAChC,SAAO,KAAK,CAAC,KAAN,CAAY,cAAZ,MAAgC,IAAvC;AACD;;AAKD,SAAS,gBAAT,CAA0B,GAA1B,EAAqC;AAKnC,QAAM,aAAa,GAAG;AACpB,IAAA,MAAM,EAAE,KADY;AAEpB,IAAA,WAAW,EAAE,2BAFO;AAGpB,IAAA,MAAM,EAAE,sBAAsB,CAAC;AAHX,GAAtB;AAKA,QAAM,YAAY,GAAG;AACnB,IAAA,MAAM,EAAE,KADW;AAEnB,IAAA,WAAW,EAAE,2BAFM;AAGnB,IAAA,MAAM,EAAE,sBAAsB,CAAC;AAHZ,GAArB;AAKA,MAAI,GAAG,CAAC,MAAJ,KAAe,EAAf,IAAqB,GAAG,CAAC,MAAJ,KAAe,GAAxC,EAA6C,OAAO,aAAP;AAE7C,QAAM,SAAS,GAAG,GAAG,CAAC,KAAJ,CAAU,CAAV,EAAa,CAAb,CAAlB;AAGA,MAAI,GAAG,CAAC,MAAJ,KAAe,GAAf,IAAsB,SAAS,KAAK,IAAxC,EAA8C,OAAO,aAAP;AAG9C,MAAI,GAAG,CAAC,MAAJ,KAAe,EAAf,IAAqB,SAAS,KAAK,IAAnC,IAA2C,SAAS,KAAK,IAA7D,EAAmE,OAAO,aAAP;AAEnE,MAAI,CAAC,WAAW,CAAC,GAAD,CAAhB,EAAuB,OAAO,aAAP;AAGvB,QAAM,SAAS,GAAG,IAAI,aAAJ,CAAkB,WAAlB,CAAlB;;AACA,MAAI;AACF,UAAM,OAAO,GAAG,SAAS,CAAC,aAAV,CAAwB,MAAM,CAAC,IAAP,CAAY,GAAZ,EAAiB,KAAjB,CAAxB,CAAhB;AACA,UAAM,MAAM,GAAG,OAAO,CAAC,QAAR,EAAf;AACA,WAAO;AACL,MAAA,MAAM,EAAE,MAAM,CAAC,MADV;AAEL,MAAA,WAAW,EAAE,MAAM,CAAC,MAFf;AAGL,MAAA,MAAM,EAAE,MAAM,CAAC,MAAP,GAAgB,IAAhB,GAAuB,sBAAsB,CAAC;AAHjD,KAAP;AAKD,GARD,CAQE,OAAO,CAAP,EAAU;AACV,WAAO,YAAP;AACD;AACF;;AAOD,OAAM,SAAU,YAAV,CAAuB,OAAvB,EAAkC;AACtC,QAAM,MAAM,GAAG,OAAO,CAAC,QAAR,CAAiB,KAAjB,EAAwB,EAAxB,CAAf;;AACA,MAAI,MAAM,CAAC,MAAP,KAAkB,EAAtB,EAA0B;AACxB,WAAO,MAAP;AACD,GAFD,MAEO,IAAI,MAAM,CAAC,MAAP,GAAgB,EAApB,EAAwB;AAG7B,UAAM,OAAO,GAAG,IAAI,MAAJ,CAAW,KAAK,MAAM,CAAC,MAAvB,CAAhB;AACA,WAAO,GAAG,OAAO,GAAG,MAAM,EAA1B;AACD,GALM,MAKA;AACL,UAAM,IAAI,KAAJ,CAAU,mDAAV,CAAN;AACD;AACF;AAOD,OAAM,SAAU,eAAV,CAA0B,OAA1B,EAAqC;AACzC,QAAM,MAAM,GAAG,OAAO,CAAC,WAAR,CAAoB,MAApB,EAA4B,IAA5B,EAAkC,EAAlC,CAAf;;AACA,MAAI,MAAM,CAAC,UAAP,KAAsB,EAA1B,EAA8B;AAC5B,UAAM,IAAI,KAAJ,CAAU,iCAAV,CAAN;AACD;;AACD,SAAO,MAAP;AACD;AAMD,OAAM,SAAU,sBAAV,CAAiC,IAAjC,EAGL;AAQC,QAAM,KAAK,GAAiB;AAC1B,IAAA,EAAE,EAAE,EADsB;AAE1B,IAAA,WAAW,EAAE,EAFa;AAG1B,IAAA,GAAG,EAAE,EAHqB;AAI1B,IAAA,UAAU,EAAE,EAJc;AAK1B,IAAA,SAAS,EAAE,CAAC,CAAC,IAAI,CAAC;AALQ,GAA5B;;AAOA,MAAI,IAAI,CAAC,kBAAL,KAA4B,QAAhC,EAA0C;AACxC,IAAA,KAAK,CAAC,kBAAN,GAA2B,QAA3B;AACD;;AAED,QAAM,QAAQ,GAAG,EAAjB;AAEA,QAAM,iBAAiB,GAAG,EAA1B;AAEA,QAAM,SAAS,GAAG,EAAlB;AACA,SAAO;AACL,IAAA,mBAAmB,EAAE,QAAQ,GAAG,iBAAX,GAA+B,SAD/C;AAEL,IAAA,YAAY,EAAE,IAAI,CAAC,SAAL,CAAe,KAAf;AAFT,GAAP;AAID;AAOD,OAAM,SAAU,4BAAV,CAAuC,YAAvC,EAA2D;AAS/D,QAAM,KAAK,GAAuB;AAChC,IAAA,SAAS,EAAE,EADqB;AAEhC,IAAA,SAAS,EAAE,EAFqB;AAGhC,IAAA,UAAU,EAAE;AAHoB,GAAlC;AAMA,QAAM,eAAe,GAAG,GAAxB;AAEA,QAAM,eAAe,GAAG,EAAxB;AACA,SAAO;AACL,IAAA,yBAAyB,EAAE,eAAe,GAAG,eADxC;AAEL,IAAA,kBAAkB,EAAE,IAAI,CAAC,SAAL,CAAe,KAAf;AAFf,GAAP;AAID;AAOD,OAAM,SAAU,wBAAV,CAAmC,IAAnC,EAKL;AACC,QAAM;AAAE,IAAA,YAAF;AAAgB,IAAA;AAAhB,MAAwC,sBAAsB,CAAC,IAAD,CAApE;AAGA,QAAM,gBAAgB,GAAG,qBAAqB,CAAC,IAAI,CAAC,aAAN,CAA9C;AAGA,MAAI,uBAAJ;;AACA,MAAI,CAAC,IAAI,CAAC,kBAAN,IAA4B,IAAI,CAAC,kBAAL,KAA4B,KAA5D,EAAmE;AACjE,IAAA,uBAAuB,GAAG,gBAAgB,GAAG,CAA7C;AACD,GAFD,MAEO,IAAI,IAAI,CAAC,kBAAL,KAA4B,QAAhC,EAA0C;AAC/C,IAAA,uBAAuB,GAAG,qBAAqB,CAAC,gBAAD,CAA/C;AACD,GAFM,MAEA;AACL,UAAM,IAAI,KAAJ,CAAU,kCAAkC,IAAI,CAAC,kBAAkB,GAAnE,CAAN;AACD;;AAED,MAAI,CAAC,IAAI,CAAC,IAAV,EAAgB;AAEd,WAAO,YAAY,CAAC,MAAb,GAAsB,mBAAtB,GAA4C,uBAAnD;AACD,GAHD,MAGO;AAEL,UAAM;AAAE,MAAA,kBAAF;AAAsB,MAAA;AAAtB,QACJ,4BAA4B,CAAC,YAAD,CAD9B;AAGA,WACE,kBAAkB,CAAC,MAAnB,GACA,yBADA,GAEA,mBAFA,GAGA,uBAJF;AAMD;AACF;AAeD,OAAO,eAAe,YAAf,CACL,SADK,EAEL,OAFK,EAGL,SAHK,EAIL,kBAJK,EAIkC;AAEvC,QAAM,QAAQ,GAAG,gBAAgB,CAAC,SAAD,CAAjC;;AACA,MAAI,CAAC,QAAQ,CAAC,MAAd,EAAsB;AACpB,UAAM,QAAN;AACD;;AACD,QAAM,IAAI,GAAG,MAAM,CAAC,aAAP,CAAqB,SAArB,EAAgC,KAAhC,EAAuC,SAAvC,EAAb;AACA,QAAM,WAAW,GAAG,MAAM,CAAC,UAAP,EAApB;AACA,QAAM,WAAW,GAAG,MAAM,CAAC,IAAP,CAAY,WAAW,CAAC,SAAZ,GAAwB,gBAAxB,EAAZ,CAApB;AACA,QAAM,YAAY,GAAG,WAAW,CAAC,MAAZ,CAAmB,IAAnB,CAArB;AACA,QAAM,kBAAkB,GAAG,eAAe,CAAC,YAAD,CAA1C;AACA,QAAM,UAAU,GAAG,kBAAkB,CAAC,kBAAD,CAArC;AAEA,QAAM,oBAAoB,GAAG,WAAW,CAAC,EAAD,CAAxC;AAEA,QAAM,UAAU,GAAG,MAAM,gBAAgB,CACvC,oBADuC,EAEvC,UAAU,CAAC,aAF4B,EAGvC,OAHuC,CAAzC;AAMA,QAAM,OAAO,GAAG,MAAM,CAAC,MAAP,CAAc,CAAC,oBAAD,EAAuB,WAAvB,EAAoC,UAApC,CAAd,CAAhB;AACA,QAAM,GAAG,GAAG,MAAM,UAAU,CAAC,UAAU,CAAC,OAAZ,EAAqB,OAArB,CAA5B;AAEA,MAAI,gBAAJ;;AACA,MAAI,CAAC,kBAAD,IAAuB,kBAAkB,KAAK,KAAlD,EAAyD;AACvD,IAAA,gBAAgB,GAAG,UAAU,CAAC,QAAX,CAAoB,KAApB,CAAnB;AACD,GAFD,MAEO,IAAI,kBAAkB,KAAK,QAA3B,EAAqC;AAC1C,IAAA,gBAAgB,GAAG,UAAU,CAAC,QAAX,CAAoB,QAApB,CAAnB;AACD,GAFM,MAEA;AACL,UAAM,IAAI,KAAJ,CAAU,kCAAkC,kBAAkB,GAA9D,CAAN;AACD;;AAED,QAAM,MAAM,GAAiB;AAC3B,IAAA,EAAE,EAAE,oBAAoB,CAAC,QAArB,CAA8B,KAA9B,CADuB;AAE3B,IAAA,WAAW,EAAE,WAAW,CAAC,QAAZ,CAAqB,KAArB,CAFc;AAG3B,IAAA,UAAU,EAAE,gBAHe;AAI3B,IAAA,GAAG,EAAE,GAAG,CAAC,QAAJ,CAAa,KAAb,CAJsB;AAK3B,IAAA,SAAS,EAAE,CAAC,CAAC;AALc,GAA7B;;AAOA,MAAI,kBAAkB,IAAI,kBAAkB,KAAK,KAAjD,EAAwD;AACtD,IAAA,MAAM,CAAC,kBAAP,GAA4B,kBAA5B;AACD;;AACD,SAAO,MAAP;AACD;AAcD,OAAO,eAAe,YAAf,CACL,UADK,EAEL,YAFK,EAEqB;AAE1B,QAAM,IAAI,GAAG,MAAM,CAAC,cAAP,CAAsB,UAAtB,EAAkC,KAAlC,CAAb;AACA,MAAI,WAAW,GAAG,IAAlB;;AACA,MAAI;AACF,IAAA,WAAW,GAAG,MAAM,CAAC,aAAP,CAAqB,YAAY,CAAC,WAAlC,EAA+C,KAA/C,EAAsD,SAAtD,EAAd;AACD,GAFD,CAEE,OAAO,KAAP,EAAc;AACd,UAAM,IAAI,qBAAJ,CACJ,kDACE,uDAFE,CAAN;AAID;;AAED,QAAM,YAAY,GAAG,IAAI,CAAC,MAAL,CAAY,WAAZ,CAArB;AACA,QAAM,kBAAkB,GAAG,eAAe,CAAC,YAAD,CAA1C;AAEA,QAAM,UAAU,GAAG,kBAAkB,CAAC,kBAAD,CAArC;AAEA,QAAM,QAAQ,GAAG,MAAM,CAAC,IAAP,CAAY,YAAY,CAAC,EAAzB,EAA6B,KAA7B,CAAjB;AACA,MAAI,gBAAJ;;AAEA,MAAI,CAAC,YAAY,CAAC,kBAAd,IAAoC,YAAY,CAAC,kBAAb,KAAoC,KAA5E,EAAmF;AACjF,IAAA,gBAAgB,GAAG,MAAM,CAAC,IAAP,CAAY,YAAY,CAAC,UAAzB,EAAqC,KAArC,CAAnB;AACD,GAFD,MAEO,IAAI,YAAY,CAAC,kBAAb,KAAoC,QAAxC,EAAkD;AACvD,IAAA,gBAAgB,GAAG,MAAM,CAAC,IAAP,CAAY,YAAY,CAAC,UAAzB,EAAqC,QAArC,CAAnB;AACD,GAFM,MAEA;AACL,UAAM,IAAI,KAAJ,CAAU,kCAAkC,YAAY,CAAC,UAAU,GAAnE,CAAN;AACD;;AAED,QAAM,OAAO,GAAG,MAAM,CAAC,MAAP,CAAc,CAC5B,QAD4B,EAE5B,MAAM,CAAC,IAAP,CAAY,WAAW,CAAC,gBAAZ,EAAZ,CAF4B,EAG5B,gBAH4B,CAAd,CAAhB;AAKA,QAAM,SAAS,GAAG,MAAM,UAAU,CAAC,UAAU,CAAC,OAAZ,EAAqB,OAArB,CAAlC;AACA,QAAM,WAAW,GAAG,MAAM,CAAC,IAAP,CAAY,YAAY,CAAC,GAAzB,EAA8B,KAA9B,CAApB;;AACA,MAAI,CAAC,cAAc,CAAC,WAAD,EAAc,SAAd,CAAnB,EAA6C;AAC3C,UAAM,IAAI,qBAAJ,CAA0B,yCAA1B,CAAN;AACD;;AACD,QAAM,SAAS,GAAG,MAAM,gBAAgB,CAAC,QAAD,EAAW,UAAU,CAAC,aAAtB,EAAqC,gBAArC,CAAxC;;AAEA,MAAI,YAAY,CAAC,SAAjB,EAA4B;AAC1B,WAAO,SAAS,CAAC,QAAV,EAAP;AACD,GAFD,MAEO;AACL,WAAO,SAAP;AACD;AACF;AAaD,OAAM,SAAU,SAAV,CACJ,UADI,EAEJ,OAFI,EAEoB;AAKxB,QAAM,aAAa,GAAG,OAAO,YAAY,MAAnB,GAA4B,OAA5B,GAAsC,MAAM,CAAC,IAAP,CAAY,OAAZ,CAA5D;AACA,QAAM,SAAS,GAAG,MAAM,CAAC,cAAP,CAAsB,UAAtB,EAAkC,KAAlC,CAAlB;AACA,QAAM,SAAS,GAAG,uBAAuB,CAAC,UAAD,CAAzC;AACA,QAAM,WAAW,GAAG,cAAc,CAAC,aAAD,CAAlC;AACA,QAAM,SAAS,GAAG,SAAS,CAAC,IAAV,CAAe,WAAf,CAAlB;AACA,QAAM,eAAe,GAAW,SAAS,CAAC,KAAV,CAAgB,KAAhB,CAAhC;AACA,SAAO;AACL,IAAA,SAAS,EAAE,eADN;AAEL,IAAA;AAFK,GAAP;AAID;;AAKD,SAAS,SAAT,CAAmB,OAAnB,EAAyD;AACvD,MAAI,OAAO,YAAY,MAAvB,EAA+B,OAAO,OAAP,CAA/B,KACK,IAAI,OAAO,YAAY,WAAvB,EAAoC,OAAO,MAAM,CAAC,IAAP,CAAY,OAAZ,CAAP,CAApC,KACA,OAAO,MAAM,CAAC,IAAP,CAAY,OAAZ,CAAP;AACN;;AAWD,OAAM,SAAU,WAAV,CACJ,OADI,EAEJ,SAFI,EAGJ,SAHI,EAGa;AAEjB,QAAM,aAAa,GAAG,SAAS,CAAC,OAAD,CAA/B;AACA,QAAM,QAAQ,GAAG,MAAM,CAAC,aAAP,CAAqB,SAArB,EAAgC,KAAhC,CAAjB;AACA,QAAM,WAAW,GAAG,cAAc,CAAC,aAAD,CAAlC;AAEA,SAAO,QAAQ,CAAC,MAAT,CAAgB,WAAhB,EAAkC,SAAlC,CAAP;AACD","sourceRoot":"","sourcesContent":["import { Buffer } from '@stacks/common';\nimport { ec as EllipticCurve } from 'elliptic';\nimport { randomBytes } from './cryptoRandom';\nimport { FailedDecryptionError } from '@stacks/common';\nimport { getPublicKeyFromPrivate } from './keys';\nimport { hashSha256Sync, hashSha512Sync } from './sha2Hash';\nimport { createHmacSha256 } from './hmacSha256';\nimport { createCipher } from './aesCipher';\nimport { getAesCbcOutputLength, getBase64OutputLength } from './utils';\nconst ecurve = new EllipticCurve('secp256k1');\nexport var InvalidPublicKeyReason;\n(function (InvalidPublicKeyReason) {\n    InvalidPublicKeyReason[\"InvalidFormat\"] = \"InvalidFormat\";\n    InvalidPublicKeyReason[\"IsNotPoint\"] = \"IsNotPoint\";\n})(InvalidPublicKeyReason || (InvalidPublicKeyReason = {}));\nexport async function aes256CbcEncrypt(iv, key, plaintext) {\n    const cipher = await createCipher();\n    const result = await cipher.encrypt('aes-256-cbc', key, iv, plaintext);\n    return result;\n}\nasync function aes256CbcDecrypt(iv, key, ciphertext) {\n    const cipher = await createCipher();\n    const result = await cipher.decrypt('aes-256-cbc', key, iv, ciphertext);\n    return result;\n}\nasync function hmacSha256(key, content) {\n    const hmacSha256 = await createHmacSha256();\n    return hmacSha256.digest(key, content);\n}\nfunction equalConstTime(b1, b2) {\n    if (b1.length !== b2.length) {\n        return false;\n    }\n    let res = 0;\n    for (let i = 0; i < b1.length; i++) {\n        res |= b1[i] ^ b2[i];\n    }\n    return res === 0;\n}\nfunction sharedSecretToKeys(sharedSecret) {\n    const hashedSecret = hashSha512Sync(sharedSecret);\n    return {\n        encryptionKey: hashedSecret.slice(0, 32),\n        hmacKey: hashedSecret.slice(32),\n    };\n}\nfunction allHexChars(maybe) {\n    return maybe.match(/^[0-9a-f]+$/i) !== null;\n}\nfunction isValidPublicKey(pub) {\n    const invalidFormat = {\n        result: false,\n        reason_data: 'Invalid public key format',\n        reason: InvalidPublicKeyReason.InvalidFormat,\n    };\n    const invalidPoint = {\n        result: false,\n        reason_data: 'Public key is not a point',\n        reason: InvalidPublicKeyReason.IsNotPoint,\n    };\n    if (pub.length !== 66 && pub.length !== 130)\n        return invalidFormat;\n    const firstByte = pub.slice(0, 2);\n    if (pub.length === 130 && firstByte !== '04')\n        return invalidFormat;\n    if (pub.length === 66 && firstByte !== '02' && firstByte !== '03')\n        return invalidFormat;\n    if (!allHexChars(pub))\n        return invalidFormat;\n    const secp256k1 = new EllipticCurve('secp256k1');\n    try {\n        const keyPair = secp256k1.keyFromPublic(Buffer.from(pub, 'hex'));\n        const result = keyPair.validate();\n        return {\n            result: result.result,\n            reason_data: result.reason,\n            reason: result.result ? null : InvalidPublicKeyReason.IsNotPoint,\n        };\n    }\n    catch (e) {\n        return invalidPoint;\n    }\n}\nexport function getHexFromBN(bnInput) {\n    const hexOut = bnInput.toString('hex', 64);\n    if (hexOut.length === 64) {\n        return hexOut;\n    }\n    else if (hexOut.length < 64) {\n        const padding = '0'.repeat(64 - hexOut.length);\n        return `${padding}${hexOut}`;\n    }\n    else {\n        throw new Error('Generated a > 32-byte BN for encryption. Failing.');\n    }\n}\nexport function getBufferFromBN(bnInput) {\n    const result = bnInput.toArrayLike(Buffer, 'be', 32);\n    if (result.byteLength !== 32) {\n        throw new Error('Failed to generate a 32-byte BN');\n    }\n    return result;\n}\nexport function getCipherObjectWrapper(opts) {\n    const shell = {\n        iv: '',\n        ephemeralPK: '',\n        mac: '',\n        cipherText: '',\n        wasString: !!opts.wasString,\n    };\n    if (opts.cipherTextEncoding === 'base64') {\n        shell.cipherTextEncoding = 'base64';\n    }\n    const ivLength = 32;\n    const ephemeralPKLength = 66;\n    const macLength = 64;\n    return {\n        payloadValuesLength: ivLength + ephemeralPKLength + macLength,\n        payloadShell: JSON.stringify(shell),\n    };\n}\nexport function getSignedCipherObjectWrapper(payloadShell) {\n    const shell = {\n        signature: '',\n        publicKey: '',\n        cipherText: payloadShell,\n    };\n    const signatureLength = 144;\n    const publicKeyLength = 66;\n    return {\n        signedPayloadValuesLength: signatureLength + publicKeyLength,\n        signedPayloadShell: JSON.stringify(shell),\n    };\n}\nexport function eciesGetJsonStringLength(opts) {\n    const { payloadShell, payloadValuesLength } = getCipherObjectWrapper(opts);\n    const cipherTextLength = getAesCbcOutputLength(opts.contentLength);\n    let encodedCipherTextLength;\n    if (!opts.cipherTextEncoding || opts.cipherTextEncoding === 'hex') {\n        encodedCipherTextLength = cipherTextLength * 2;\n    }\n    else if (opts.cipherTextEncoding === 'base64') {\n        encodedCipherTextLength = getBase64OutputLength(cipherTextLength);\n    }\n    else {\n        throw new Error(`Unexpected cipherTextEncoding \"${opts.cipherTextEncoding}\"`);\n    }\n    if (!opts.sign) {\n        return payloadShell.length + payloadValuesLength + encodedCipherTextLength;\n    }\n    else {\n        const { signedPayloadShell, signedPayloadValuesLength } = getSignedCipherObjectWrapper(payloadShell);\n        return (signedPayloadShell.length +\n            signedPayloadValuesLength +\n            payloadValuesLength +\n            encodedCipherTextLength);\n    }\n}\nexport async function encryptECIES(publicKey, content, wasString, cipherTextEncoding) {\n    const validity = isValidPublicKey(publicKey);\n    if (!validity.result) {\n        throw validity;\n    }\n    const ecPK = ecurve.keyFromPublic(publicKey, 'hex').getPublic();\n    const ephemeralSK = ecurve.genKeyPair();\n    const ephemeralPK = Buffer.from(ephemeralSK.getPublic().encodeCompressed());\n    const sharedSecret = ephemeralSK.derive(ecPK);\n    const sharedSecretBuffer = getBufferFromBN(sharedSecret);\n    const sharedKeys = sharedSecretToKeys(sharedSecretBuffer);\n    const initializationVector = randomBytes(16);\n    const cipherText = await aes256CbcEncrypt(initializationVector, sharedKeys.encryptionKey, content);\n    const macData = Buffer.concat([initializationVector, ephemeralPK, cipherText]);\n    const mac = await hmacSha256(sharedKeys.hmacKey, macData);\n    let cipherTextString;\n    if (!cipherTextEncoding || cipherTextEncoding === 'hex') {\n        cipherTextString = cipherText.toString('hex');\n    }\n    else if (cipherTextEncoding === 'base64') {\n        cipherTextString = cipherText.toString('base64');\n    }\n    else {\n        throw new Error(`Unexpected cipherTextEncoding \"${cipherTextEncoding}\"`);\n    }\n    const result = {\n        iv: initializationVector.toString('hex'),\n        ephemeralPK: ephemeralPK.toString('hex'),\n        cipherText: cipherTextString,\n        mac: mac.toString('hex'),\n        wasString: !!wasString,\n    };\n    if (cipherTextEncoding && cipherTextEncoding !== 'hex') {\n        result.cipherTextEncoding = cipherTextEncoding;\n    }\n    return result;\n}\nexport async function decryptECIES(privateKey, cipherObject) {\n    const ecSK = ecurve.keyFromPrivate(privateKey, 'hex');\n    let ephemeralPK = null;\n    try {\n        ephemeralPK = ecurve.keyFromPublic(cipherObject.ephemeralPK, 'hex').getPublic();\n    }\n    catch (error) {\n        throw new FailedDecryptionError('Unable to get public key from cipher object. ' +\n            'You might be trying to decrypt an unencrypted object.');\n    }\n    const sharedSecret = ecSK.derive(ephemeralPK);\n    const sharedSecretBuffer = getBufferFromBN(sharedSecret);\n    const sharedKeys = sharedSecretToKeys(sharedSecretBuffer);\n    const ivBuffer = Buffer.from(cipherObject.iv, 'hex');\n    let cipherTextBuffer;\n    if (!cipherObject.cipherTextEncoding || cipherObject.cipherTextEncoding === 'hex') {\n        cipherTextBuffer = Buffer.from(cipherObject.cipherText, 'hex');\n    }\n    else if (cipherObject.cipherTextEncoding === 'base64') {\n        cipherTextBuffer = Buffer.from(cipherObject.cipherText, 'base64');\n    }\n    else {\n        throw new Error(`Unexpected cipherTextEncoding \"${cipherObject.cipherText}\"`);\n    }\n    const macData = Buffer.concat([\n        ivBuffer,\n        Buffer.from(ephemeralPK.encodeCompressed()),\n        cipherTextBuffer,\n    ]);\n    const actualMac = await hmacSha256(sharedKeys.hmacKey, macData);\n    const expectedMac = Buffer.from(cipherObject.mac, 'hex');\n    if (!equalConstTime(expectedMac, actualMac)) {\n        throw new FailedDecryptionError('Decryption failed: failure in MAC check');\n    }\n    const plainText = await aes256CbcDecrypt(ivBuffer, sharedKeys.encryptionKey, cipherTextBuffer);\n    if (cipherObject.wasString) {\n        return plainText.toString();\n    }\n    else {\n        return plainText;\n    }\n}\nexport function signECDSA(privateKey, content) {\n    const contentBuffer = content instanceof Buffer ? content : Buffer.from(content);\n    const ecPrivate = ecurve.keyFromPrivate(privateKey, 'hex');\n    const publicKey = getPublicKeyFromPrivate(privateKey);\n    const contentHash = hashSha256Sync(contentBuffer);\n    const signature = ecPrivate.sign(contentHash);\n    const signatureString = signature.toDER('hex');\n    return {\n        signature: signatureString,\n        publicKey,\n    };\n}\nfunction getBuffer(content) {\n    if (content instanceof Buffer)\n        return content;\n    else if (content instanceof ArrayBuffer)\n        return Buffer.from(content);\n    else\n        return Buffer.from(content);\n}\nexport function verifyECDSA(content, publicKey, signature) {\n    const contentBuffer = getBuffer(content);\n    const ecPublic = ecurve.keyFromPublic(publicKey, 'hex');\n    const contentHash = hashSha256Sync(contentBuffer);\n    return ecPublic.verify(contentHash, signature);\n}\n//# sourceMappingURL=ec.js.map"]},"metadata":{},"sourceType":"module"}