{"ast":null,"code":"import { Buffer, intToBigInt } from '@stacks/common';\nimport { StacksTransaction } from './transaction';\nimport { StacksMainnet, StacksTestnet } from '@stacks/network';\nimport { createTokenTransferPayload, createSmartContractPayload, createContractCallPayload } from './payload';\nimport { StandardAuthorization, SponsoredAuthorization, createSingleSigSpendingCondition, createMultiSigSpendingCondition } from './authorization';\nimport { publicKeyToString, createStacksPrivateKey, getPublicKey, publicKeyToAddress, pubKeyfromPrivKey, publicKeyFromBuffer } from './keys';\nimport { TransactionSigner } from './signer';\nimport { createSTXPostCondition, createFungiblePostCondition, createNonFungiblePostCondition } from './postcondition';\nimport { AddressHashMode, AddressVersion, PostConditionMode, PayloadType, TransactionVersion } from './constants';\nimport { createLPList, createStandardPrincipal, createContractPrincipal } from './types';\nimport { cvToHex, parseReadOnlyResponse, omit, validateTxId } from './utils';\nimport { fetchPrivate } from '@stacks/common';\nimport { validateContractCall } from './contract-abi';\nimport { c32address } from 'c32check';\nexport async function getNonce(address, network) {\n  const defaultNetwork = new StacksMainnet();\n  const url = network ? network.getAccountApiUrl(address) : defaultNetwork.getAccountApiUrl(address);\n  const response = await fetchPrivate(url);\n\n  if (!response.ok) {\n    let msg = '';\n\n    try {\n      msg = await response.text();\n    } catch (error) {}\n\n    throw new Error(`Error fetching nonce. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n\n  const responseText = await response.text();\n  const result = JSON.parse(responseText);\n  return BigInt(result.nonce);\n}\nexport async function estimateTransfer(transaction, network) {\n  if (transaction.payload.payloadType !== PayloadType.TokenTransfer) {\n    throw new Error(`Transaction fee estimation only possible with ${PayloadType[PayloadType.TokenTransfer]} transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`);\n  }\n\n  const requestHeaders = {\n    Accept: 'application/text'\n  };\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders\n  };\n  const defaultNetwork = new StacksMainnet();\n  const url = network ? network.getTransferFeeEstimateApiUrl() : defaultNetwork.getTransferFeeEstimateApiUrl();\n  const response = await fetchPrivate(url, fetchOptions);\n\n  if (!response.ok) {\n    let msg = '';\n\n    try {\n      msg = await response.text();\n    } catch (error) {}\n\n    throw new Error(`Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n\n  const feeRateResult = await response.text();\n  const txBytes = BigInt(transaction.serialize().byteLength);\n  const feeRate = BigInt(feeRateResult);\n  return feeRate * txBytes;\n}\nexport async function broadcastTransaction(transaction, network, attachment) {\n  const rawTx = transaction.serialize();\n  const url = network.getBroadcastApiUrl();\n  return broadcastRawTransaction(rawTx, url, attachment);\n}\nexport async function broadcastRawTransaction(rawTx, url, attachment) {\n  const options = {\n    method: 'POST',\n    headers: {\n      'Content-Type': attachment ? 'application/json' : 'application/octet-stream'\n    },\n    body: attachment ? JSON.stringify({\n      tx: rawTx.toString('hex'),\n      attachment: attachment.toString('hex')\n    }) : rawTx\n  };\n  const response = await fetchPrivate(url, options);\n\n  if (!response.ok) {\n    try {\n      return await response.json();\n    } catch (e) {\n      throw Error(`Failed to broadcast transaction: ${e.message}`);\n    }\n  }\n\n  const text = await response.text();\n  const txid = text.replace(/[\"]+/g, '');\n  const isValidTxId = validateTxId(txid);\n\n  if (isValidTxId) {\n    return {\n      txid: txid\n    };\n  } else {\n    throw new Error(text);\n  }\n}\nexport async function getAbi(address, contractName, network) {\n  const options = {\n    method: 'GET'\n  };\n  const url = network.getAbiApiUrl(address, contractName);\n  const response = await fetchPrivate(url, options);\n\n  if (!response.ok) {\n    let msg = '';\n\n    try {\n      msg = await response.text();\n    } catch (error) {}\n\n    throw new Error(`Error fetching contract ABI for contract \"${contractName}\" at address ${address}. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n\n  return JSON.parse(await response.text());\n}\nexport async function makeUnsignedSTXTokenTransfer(txOptions) {\n  const defaultOptions = {\n    fee: BigInt(0),\n    nonce: BigInt(0),\n    network: new StacksMainnet(),\n    postConditionMode: PostConditionMode.Deny,\n    memo: '',\n    sponsored: false\n  };\n  const options = Object.assign(defaultOptions, txOptions);\n  const payload = createTokenTransferPayload(options.recipient, options.amount, options.memo);\n  let authorization = null;\n  let spendingCondition = null;\n\n  if ('publicKey' in options) {\n    spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);\n  } else {\n    spendingCondition = createMultiSigSpendingCondition(AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);\n  }\n\n  if (options.sponsored) {\n    authorization = new SponsoredAuthorization(spendingCondition);\n  } else {\n    authorization = new StandardAuthorization(spendingCondition);\n  }\n\n  const postConditions = [];\n\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n\n  const lpPostConditions = createLPList(postConditions);\n  const transaction = new StacksTransaction(options.network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, options.network.chainId);\n\n  if (txOptions.fee === undefined || txOptions.fee === null) {\n    const txFee = await estimateTransfer(transaction, options.network);\n    transaction.setFee(txFee);\n  }\n\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\n    const addressVersion = options.network.version === TransactionVersion.Mainnet ? AddressVersion.MainnetSingleSig : AddressVersion.TestnetSingleSig;\n    const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition.signer);\n    const txNonce = await getNonce(senderAddress, options.network);\n    transaction.setNonce(txNonce);\n  }\n\n  return transaction;\n}\nexport async function makeSTXTokenTransfer(txOptions) {\n  if ('senderKey' in txOptions) {\n    const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n    const options = omit(txOptions, 'senderKey');\n    const transaction = await makeUnsignedSTXTokenTransfer(Object.assign({\n      publicKey\n    }, options));\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n    return transaction;\n  } else {\n    const options = omit(txOptions, 'signerKeys');\n    const transaction = await makeUnsignedSTXTokenTransfer(options);\n    const signer = new TransactionSigner(transaction);\n    let pubKeys = txOptions.publicKeys;\n\n    for (const key of txOptions.signerKeys) {\n      const pubKey = pubKeyfromPrivKey(key);\n      pubKeys = pubKeys.filter(pk => pk !== pubKey.data.toString('hex'));\n      signer.signOrigin(createStacksPrivateKey(key));\n    }\n\n    for (const key of pubKeys) {\n      signer.appendOrigin(publicKeyFromBuffer(Buffer.from(key, 'hex')));\n    }\n\n    return transaction;\n  }\n}\nexport async function estimateContractDeploy(transaction, network) {\n  if (transaction.payload.payloadType !== PayloadType.SmartContract) {\n    throw new Error(`Contract deploy fee estimation only possible with ${PayloadType[PayloadType.SmartContract]} transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`);\n  }\n\n  const requestHeaders = {\n    Accept: 'application/text'\n  };\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders\n  };\n  const defaultNetwork = new StacksMainnet();\n  const url = network ? network.getTransferFeeEstimateApiUrl() : defaultNetwork.getTransferFeeEstimateApiUrl();\n  const response = await fetchPrivate(url, fetchOptions);\n\n  if (!response.ok) {\n    let msg = '';\n\n    try {\n      msg = await response.text();\n    } catch (error) {}\n\n    throw new Error(`Error estimating contract deploy fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n\n  const feeRateResult = await response.text();\n  const txBytes = intToBigInt(transaction.serialize().byteLength, false);\n  const feeRate = intToBigInt(feeRateResult, false);\n  return feeRate * txBytes;\n}\nexport async function makeContractDeploy(txOptions) {\n  const defaultOptions = {\n    fee: BigInt(0),\n    nonce: BigInt(0),\n    network: new StacksMainnet(),\n    postConditionMode: PostConditionMode.Deny,\n    sponsored: false\n  };\n  const options = Object.assign(defaultOptions, txOptions);\n  const payload = createSmartContractPayload(options.contractName, options.codeBody);\n  const addressHashMode = AddressHashMode.SerializeP2PKH;\n  const privKey = createStacksPrivateKey(options.senderKey);\n  const pubKey = getPublicKey(privKey);\n  let authorization = null;\n  const spendingCondition = createSingleSigSpendingCondition(addressHashMode, publicKeyToString(pubKey), options.nonce, options.fee);\n\n  if (options.sponsored) {\n    authorization = new SponsoredAuthorization(spendingCondition);\n  } else {\n    authorization = new StandardAuthorization(spendingCondition);\n  }\n\n  const postConditions = [];\n\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n\n  const lpPostConditions = createLPList(postConditions);\n  const transaction = new StacksTransaction(options.network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, options.network.chainId);\n\n  if (txOptions.fee === undefined || txOptions.fee === null) {\n    const txFee = await estimateContractDeploy(transaction, options.network);\n    transaction.setFee(txFee);\n  }\n\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\n    const addressVersion = options.network.version === TransactionVersion.Mainnet ? AddressVersion.MainnetSingleSig : AddressVersion.TestnetSingleSig;\n    const senderAddress = publicKeyToAddress(addressVersion, pubKey);\n    const txNonce = await getNonce(senderAddress, options.network);\n    transaction.setNonce(txNonce);\n  }\n\n  if (options.senderKey) {\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n  }\n\n  return transaction;\n}\nexport async function estimateContractFunctionCall(transaction, network) {\n  if (transaction.payload.payloadType !== PayloadType.ContractCall) {\n    throw new Error(`Contract call fee estimation only possible with ${PayloadType[PayloadType.ContractCall]} transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`);\n  }\n\n  const requestHeaders = {\n    Accept: 'application/text'\n  };\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders\n  };\n  const defaultNetwork = new StacksMainnet();\n  const url = network ? network.getTransferFeeEstimateApiUrl() : defaultNetwork.getTransferFeeEstimateApiUrl();\n  const response = await fetchPrivate(url, fetchOptions);\n\n  if (!response.ok) {\n    let msg = '';\n\n    try {\n      msg = await response.text();\n    } catch (error) {}\n\n    throw new Error(`Error estimating contract call fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n\n  const feeRateResult = await response.text();\n  const txBytes = intToBigInt(transaction.serialize().byteLength, false);\n  const feeRate = intToBigInt(feeRateResult, false);\n  return feeRate * txBytes;\n}\nexport async function makeUnsignedContractCall(txOptions) {\n  const defaultOptions = {\n    fee: BigInt(0),\n    nonce: BigInt(0),\n    network: new StacksMainnet(),\n    postConditionMode: PostConditionMode.Deny,\n    sponsored: false\n  };\n  const options = Object.assign(defaultOptions, txOptions);\n  const payload = createContractCallPayload(options.contractAddress, options.contractName, options.functionName, options.functionArgs);\n\n  if (options === null || options === void 0 ? void 0 : options.validateWithAbi) {\n    let abi;\n\n    if (typeof options.validateWithAbi === 'boolean') {\n      if (options === null || options === void 0 ? void 0 : options.network) {\n        abi = await getAbi(options.contractAddress, options.contractName, options.network);\n      } else {\n        throw new Error('Network option must be provided in order to validate with ABI');\n      }\n    } else {\n      abi = options.validateWithAbi;\n    }\n\n    validateContractCall(payload, abi);\n  }\n\n  let spendingCondition = null;\n  let authorization = null;\n\n  if ('publicKey' in options) {\n    spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);\n  } else {\n    spendingCondition = createMultiSigSpendingCondition(AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);\n  }\n\n  if (options.sponsored) {\n    authorization = new SponsoredAuthorization(spendingCondition);\n  } else {\n    authorization = new StandardAuthorization(spendingCondition);\n  }\n\n  const postConditions = [];\n\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n\n  const lpPostConditions = createLPList(postConditions);\n  const transaction = new StacksTransaction(options.network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, options.network.chainId);\n\n  if (txOptions.fee === undefined || txOptions.fee === null) {\n    const txFee = await estimateContractFunctionCall(transaction, options.network);\n    transaction.setFee(txFee);\n  }\n\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\n    const addressVersion = options.network.version === TransactionVersion.Mainnet ? AddressVersion.MainnetSingleSig : AddressVersion.TestnetSingleSig;\n    const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition.signer);\n    const txNonce = await getNonce(senderAddress, options.network);\n    transaction.setNonce(txNonce);\n  }\n\n  return transaction;\n}\nexport async function makeContractCall(txOptions) {\n  if ('senderKey' in txOptions) {\n    const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n    const options = omit(txOptions, 'senderKey');\n    const transaction = await makeUnsignedContractCall(Object.assign({\n      publicKey\n    }, options));\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n    return transaction;\n  } else {\n    const options = omit(txOptions, 'signerKeys');\n    const transaction = await makeUnsignedContractCall(options);\n    const signer = new TransactionSigner(transaction);\n    let pubKeys = txOptions.publicKeys;\n\n    for (const key of txOptions.signerKeys) {\n      const pubKey = pubKeyfromPrivKey(key);\n      pubKeys = pubKeys.filter(pk => pk !== pubKey.data.toString('hex'));\n      signer.signOrigin(createStacksPrivateKey(key));\n    }\n\n    for (const key of pubKeys) {\n      signer.appendOrigin(publicKeyFromBuffer(Buffer.from(key, 'hex')));\n    }\n\n    return transaction;\n  }\n}\nexport function makeStandardSTXPostCondition(address, conditionCode, amount) {\n  return createSTXPostCondition(createStandardPrincipal(address), conditionCode, amount);\n}\nexport function makeContractSTXPostCondition(address, contractName, conditionCode, amount) {\n  return createSTXPostCondition(createContractPrincipal(address, contractName), conditionCode, amount);\n}\nexport function makeStandardFungiblePostCondition(address, conditionCode, amount, assetInfo) {\n  return createFungiblePostCondition(createStandardPrincipal(address), conditionCode, amount, assetInfo);\n}\nexport function makeContractFungiblePostCondition(address, contractName, conditionCode, amount, assetInfo) {\n  return createFungiblePostCondition(createContractPrincipal(address, contractName), conditionCode, amount, assetInfo);\n}\nexport function makeStandardNonFungiblePostCondition(address, conditionCode, assetInfo, assetName) {\n  return createNonFungiblePostCondition(createStandardPrincipal(address), conditionCode, assetInfo, assetName);\n}\nexport function makeContractNonFungiblePostCondition(address, contractName, conditionCode, assetInfo, assetName) {\n  return createNonFungiblePostCondition(createContractPrincipal(address, contractName), conditionCode, assetInfo, assetName);\n}\nexport async function callReadOnlyFunction(readOnlyFunctionOptions) {\n  const defaultOptions = {\n    network: new StacksMainnet()\n  };\n  const options = Object.assign(defaultOptions, readOnlyFunctionOptions);\n  const {\n    contractName,\n    contractAddress,\n    functionName,\n    functionArgs,\n    network,\n    senderAddress\n  } = options;\n  const url = network.getReadOnlyFunctionCallApiUrl(contractAddress, contractName, functionName);\n  const args = functionArgs.map(arg => cvToHex(arg));\n  const body = JSON.stringify({\n    sender: senderAddress,\n    arguments: args\n  });\n  const response = await fetchPrivate(url, {\n    method: 'POST',\n    body,\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  });\n\n  if (!response.ok) {\n    let msg = '';\n\n    try {\n      msg = await response.text();\n    } catch (error) {}\n\n    throw new Error(`Error calling read-only function. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n\n  return response.json().then(responseJson => parseReadOnlyResponse(responseJson));\n}\nexport async function sponsorTransaction(sponsorOptions) {\n  var _a;\n\n  const defaultOptions = {\n    fee: 0,\n    sponsorNonce: 0,\n    sponsorAddressHashmode: AddressHashMode.SerializeP2PKH\n  };\n  const options = Object.assign(defaultOptions, sponsorOptions);\n  const network = (_a = sponsorOptions.network) !== null && _a !== void 0 ? _a : options.transaction.version === TransactionVersion.Mainnet ? new StacksMainnet() : new StacksTestnet();\n  const sponsorPubKey = pubKeyfromPrivKey(options.sponsorPrivateKey);\n\n  if (sponsorOptions.fee === undefined || sponsorOptions.fee === null) {\n    let txFee = BigInt(0);\n\n    switch (options.transaction.payload.payloadType) {\n      case PayloadType.TokenTransfer:\n        txFee = await estimateTransfer(options.transaction, network);\n        break;\n\n      case PayloadType.SmartContract:\n        txFee = await estimateContractDeploy(options.transaction, network);\n        break;\n\n      case PayloadType.ContractCall:\n        txFee = await estimateContractFunctionCall(options.transaction, network);\n        break;\n\n      default:\n        throw new Error(`Sponsored transactions not supported for transaction type ${PayloadType[options.transaction.payload.payloadType]}`);\n    }\n\n    options.transaction.setFee(txFee);\n    options.fee = txFee;\n  }\n\n  if (sponsorOptions.sponsorNonce === undefined || sponsorOptions.sponsorNonce === null) {\n    const addressVersion = network.version === TransactionVersion.Mainnet ? AddressVersion.MainnetSingleSig : AddressVersion.TestnetSingleSig;\n    const senderAddress = publicKeyToAddress(addressVersion, sponsorPubKey);\n    const sponsorNonce = await getNonce(senderAddress, network);\n    options.sponsorNonce = sponsorNonce;\n  }\n\n  const sponsorSpendingCondition = createSingleSigSpendingCondition(options.sponsorAddressHashmode, publicKeyToString(sponsorPubKey), options.sponsorNonce, options.fee);\n  options.transaction.setSponsor(sponsorSpendingCondition);\n  const privKey = createStacksPrivateKey(options.sponsorPrivateKey);\n  const signer = TransactionSigner.createSponsorSigner(options.transaction, sponsorSpendingCondition);\n  signer.signSponsor(privKey);\n  return options.transaction;\n}","map":{"version":3,"sources":["../../src/builders.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Buffer, intToBigInt } from '@stacks/common';\nimport { StacksTransaction } from './transaction';\nimport { StacksMainnet, StacksTestnet } from '@stacks/network';\nimport { createTokenTransferPayload, createSmartContractPayload, createContractCallPayload, } from './payload';\nimport { StandardAuthorization, SponsoredAuthorization, createSingleSigSpendingCondition, createMultiSigSpendingCondition, } from './authorization';\nimport { publicKeyToString, createStacksPrivateKey, getPublicKey, publicKeyToAddress, pubKeyfromPrivKey, publicKeyFromBuffer, } from './keys';\nimport { TransactionSigner } from './signer';\nimport { createSTXPostCondition, createFungiblePostCondition, createNonFungiblePostCondition, } from './postcondition';\nimport { AddressHashMode, AddressVersion, PostConditionMode, PayloadType, TransactionVersion, } from './constants';\nimport { createLPList, createStandardPrincipal, createContractPrincipal } from './types';\nimport { cvToHex, parseReadOnlyResponse, omit, validateTxId } from './utils';\nimport { fetchPrivate } from '@stacks/common';\nimport { validateContractCall } from './contract-abi';\nimport { c32address } from 'c32check';\nexport async function getNonce(address, network) {\n    const defaultNetwork = new StacksMainnet();\n    const url = network\n        ? network.getAccountApiUrl(address)\n        : defaultNetwork.getAccountApiUrl(address);\n    const response = await fetchPrivate(url);\n    if (!response.ok) {\n        let msg = '';\n        try {\n            msg = await response.text();\n        }\n        catch (error) { }\n        throw new Error(`Error fetching nonce. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n    }\n    const responseText = await response.text();\n    const result = JSON.parse(responseText);\n    return BigInt(result.nonce);\n}\nexport async function estimateTransfer(transaction, network) {\n    if (transaction.payload.payloadType !== PayloadType.TokenTransfer) {\n        throw new Error(`Transaction fee estimation only possible with ${PayloadType[PayloadType.TokenTransfer]} transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`);\n    }\n    const requestHeaders = {\n        Accept: 'application/text',\n    };\n    const fetchOptions = {\n        method: 'GET',\n        headers: requestHeaders,\n    };\n    const defaultNetwork = new StacksMainnet();\n    const url = network\n        ? network.getTransferFeeEstimateApiUrl()\n        : defaultNetwork.getTransferFeeEstimateApiUrl();\n    const response = await fetchPrivate(url, fetchOptions);\n    if (!response.ok) {\n        let msg = '';\n        try {\n            msg = await response.text();\n        }\n        catch (error) { }\n        throw new Error(`Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n    }\n    const feeRateResult = await response.text();\n    const txBytes = BigInt(transaction.serialize().byteLength);\n    const feeRate = BigInt(feeRateResult);\n    return feeRate * txBytes;\n}\nexport async function broadcastTransaction(transaction, network, attachment) {\n    const rawTx = transaction.serialize();\n    const url = network.getBroadcastApiUrl();\n    return broadcastRawTransaction(rawTx, url, attachment);\n}\nexport async function broadcastRawTransaction(rawTx, url, attachment) {\n    const options = {\n        method: 'POST',\n        headers: { 'Content-Type': attachment ? 'application/json' : 'application/octet-stream' },\n        body: attachment\n            ? JSON.stringify({\n                tx: rawTx.toString('hex'),\n                attachment: attachment.toString('hex'),\n            })\n            : rawTx,\n    };\n    const response = await fetchPrivate(url, options);\n    if (!response.ok) {\n        try {\n            return (await response.json());\n        }\n        catch (e) {\n            throw Error(`Failed to broadcast transaction: ${e.message}`);\n        }\n    }\n    const text = await response.text();\n    const txid = text.replace(/[\"]+/g, '');\n    const isValidTxId = validateTxId(txid);\n    if (isValidTxId) {\n        return {\n            txid: txid,\n        };\n    }\n    else {\n        throw new Error(text);\n    }\n}\nexport async function getAbi(address, contractName, network) {\n    const options = {\n        method: 'GET',\n    };\n    const url = network.getAbiApiUrl(address, contractName);\n    const response = await fetchPrivate(url, options);\n    if (!response.ok) {\n        let msg = '';\n        try {\n            msg = await response.text();\n        }\n        catch (error) { }\n        throw new Error(`Error fetching contract ABI for contract \"${contractName}\" at address ${address}. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n    }\n    return JSON.parse(await response.text());\n}\nexport async function makeUnsignedSTXTokenTransfer(txOptions) {\n    const defaultOptions = {\n        fee: BigInt(0),\n        nonce: BigInt(0),\n        network: new StacksMainnet(),\n        postConditionMode: PostConditionMode.Deny,\n        memo: '',\n        sponsored: false,\n    };\n    const options = Object.assign(defaultOptions, txOptions);\n    const payload = createTokenTransferPayload(options.recipient, options.amount, options.memo);\n    let authorization = null;\n    let spendingCondition = null;\n    if ('publicKey' in options) {\n        spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);\n    }\n    else {\n        spendingCondition = createMultiSigSpendingCondition(AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);\n    }\n    if (options.sponsored) {\n        authorization = new SponsoredAuthorization(spendingCondition);\n    }\n    else {\n        authorization = new StandardAuthorization(spendingCondition);\n    }\n    const postConditions = [];\n    if (options.postConditions && options.postConditions.length > 0) {\n        options.postConditions.forEach(postCondition => {\n            postConditions.push(postCondition);\n        });\n    }\n    const lpPostConditions = createLPList(postConditions);\n    const transaction = new StacksTransaction(options.network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, options.network.chainId);\n    if (txOptions.fee === undefined || txOptions.fee === null) {\n        const txFee = await estimateTransfer(transaction, options.network);\n        transaction.setFee(txFee);\n    }\n    if (txOptions.nonce === undefined || txOptions.nonce === null) {\n        const addressVersion = options.network.version === TransactionVersion.Mainnet\n            ? AddressVersion.MainnetSingleSig\n            : AddressVersion.TestnetSingleSig;\n        const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition.signer);\n        const txNonce = await getNonce(senderAddress, options.network);\n        transaction.setNonce(txNonce);\n    }\n    return transaction;\n}\nexport async function makeSTXTokenTransfer(txOptions) {\n    if ('senderKey' in txOptions) {\n        const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n        const options = omit(txOptions, 'senderKey');\n        const transaction = await makeUnsignedSTXTokenTransfer(Object.assign({ publicKey }, options));\n        const privKey = createStacksPrivateKey(txOptions.senderKey);\n        const signer = new TransactionSigner(transaction);\n        signer.signOrigin(privKey);\n        return transaction;\n    }\n    else {\n        const options = omit(txOptions, 'signerKeys');\n        const transaction = await makeUnsignedSTXTokenTransfer(options);\n        const signer = new TransactionSigner(transaction);\n        let pubKeys = txOptions.publicKeys;\n        for (const key of txOptions.signerKeys) {\n            const pubKey = pubKeyfromPrivKey(key);\n            pubKeys = pubKeys.filter(pk => pk !== pubKey.data.toString('hex'));\n            signer.signOrigin(createStacksPrivateKey(key));\n        }\n        for (const key of pubKeys) {\n            signer.appendOrigin(publicKeyFromBuffer(Buffer.from(key, 'hex')));\n        }\n        return transaction;\n    }\n}\nexport async function estimateContractDeploy(transaction, network) {\n    if (transaction.payload.payloadType !== PayloadType.SmartContract) {\n        throw new Error(`Contract deploy fee estimation only possible with ${PayloadType[PayloadType.SmartContract]} transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`);\n    }\n    const requestHeaders = {\n        Accept: 'application/text',\n    };\n    const fetchOptions = {\n        method: 'GET',\n        headers: requestHeaders,\n    };\n    const defaultNetwork = new StacksMainnet();\n    const url = network\n        ? network.getTransferFeeEstimateApiUrl()\n        : defaultNetwork.getTransferFeeEstimateApiUrl();\n    const response = await fetchPrivate(url, fetchOptions);\n    if (!response.ok) {\n        let msg = '';\n        try {\n            msg = await response.text();\n        }\n        catch (error) { }\n        throw new Error(`Error estimating contract deploy fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n    }\n    const feeRateResult = await response.text();\n    const txBytes = intToBigInt(transaction.serialize().byteLength, false);\n    const feeRate = intToBigInt(feeRateResult, false);\n    return feeRate * txBytes;\n}\nexport async function makeContractDeploy(txOptions) {\n    const defaultOptions = {\n        fee: BigInt(0),\n        nonce: BigInt(0),\n        network: new StacksMainnet(),\n        postConditionMode: PostConditionMode.Deny,\n        sponsored: false,\n    };\n    const options = Object.assign(defaultOptions, txOptions);\n    const payload = createSmartContractPayload(options.contractName, options.codeBody);\n    const addressHashMode = AddressHashMode.SerializeP2PKH;\n    const privKey = createStacksPrivateKey(options.senderKey);\n    const pubKey = getPublicKey(privKey);\n    let authorization = null;\n    const spendingCondition = createSingleSigSpendingCondition(addressHashMode, publicKeyToString(pubKey), options.nonce, options.fee);\n    if (options.sponsored) {\n        authorization = new SponsoredAuthorization(spendingCondition);\n    }\n    else {\n        authorization = new StandardAuthorization(spendingCondition);\n    }\n    const postConditions = [];\n    if (options.postConditions && options.postConditions.length > 0) {\n        options.postConditions.forEach(postCondition => {\n            postConditions.push(postCondition);\n        });\n    }\n    const lpPostConditions = createLPList(postConditions);\n    const transaction = new StacksTransaction(options.network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, options.network.chainId);\n    if (txOptions.fee === undefined || txOptions.fee === null) {\n        const txFee = await estimateContractDeploy(transaction, options.network);\n        transaction.setFee(txFee);\n    }\n    if (txOptions.nonce === undefined || txOptions.nonce === null) {\n        const addressVersion = options.network.version === TransactionVersion.Mainnet\n            ? AddressVersion.MainnetSingleSig\n            : AddressVersion.TestnetSingleSig;\n        const senderAddress = publicKeyToAddress(addressVersion, pubKey);\n        const txNonce = await getNonce(senderAddress, options.network);\n        transaction.setNonce(txNonce);\n    }\n    if (options.senderKey) {\n        const signer = new TransactionSigner(transaction);\n        signer.signOrigin(privKey);\n    }\n    return transaction;\n}\nexport async function estimateContractFunctionCall(transaction, network) {\n    if (transaction.payload.payloadType !== PayloadType.ContractCall) {\n        throw new Error(`Contract call fee estimation only possible with ${PayloadType[PayloadType.ContractCall]} transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`);\n    }\n    const requestHeaders = {\n        Accept: 'application/text',\n    };\n    const fetchOptions = {\n        method: 'GET',\n        headers: requestHeaders,\n    };\n    const defaultNetwork = new StacksMainnet();\n    const url = network\n        ? network.getTransferFeeEstimateApiUrl()\n        : defaultNetwork.getTransferFeeEstimateApiUrl();\n    const response = await fetchPrivate(url, fetchOptions);\n    if (!response.ok) {\n        let msg = '';\n        try {\n            msg = await response.text();\n        }\n        catch (error) { }\n        throw new Error(`Error estimating contract call fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n    }\n    const feeRateResult = await response.text();\n    const txBytes = intToBigInt(transaction.serialize().byteLength, false);\n    const feeRate = intToBigInt(feeRateResult, false);\n    return feeRate * txBytes;\n}\nexport async function makeUnsignedContractCall(txOptions) {\n    const defaultOptions = {\n        fee: BigInt(0),\n        nonce: BigInt(0),\n        network: new StacksMainnet(),\n        postConditionMode: PostConditionMode.Deny,\n        sponsored: false,\n    };\n    const options = Object.assign(defaultOptions, txOptions);\n    const payload = createContractCallPayload(options.contractAddress, options.contractName, options.functionName, options.functionArgs);\n    if (options === null || options === void 0 ? void 0 : options.validateWithAbi) {\n        let abi;\n        if (typeof options.validateWithAbi === 'boolean') {\n            if (options === null || options === void 0 ? void 0 : options.network) {\n                abi = await getAbi(options.contractAddress, options.contractName, options.network);\n            }\n            else {\n                throw new Error('Network option must be provided in order to validate with ABI');\n            }\n        }\n        else {\n            abi = options.validateWithAbi;\n        }\n        validateContractCall(payload, abi);\n    }\n    let spendingCondition = null;\n    let authorization = null;\n    if ('publicKey' in options) {\n        spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);\n    }\n    else {\n        spendingCondition = createMultiSigSpendingCondition(AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);\n    }\n    if (options.sponsored) {\n        authorization = new SponsoredAuthorization(spendingCondition);\n    }\n    else {\n        authorization = new StandardAuthorization(spendingCondition);\n    }\n    const postConditions = [];\n    if (options.postConditions && options.postConditions.length > 0) {\n        options.postConditions.forEach(postCondition => {\n            postConditions.push(postCondition);\n        });\n    }\n    const lpPostConditions = createLPList(postConditions);\n    const transaction = new StacksTransaction(options.network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, options.network.chainId);\n    if (txOptions.fee === undefined || txOptions.fee === null) {\n        const txFee = await estimateContractFunctionCall(transaction, options.network);\n        transaction.setFee(txFee);\n    }\n    if (txOptions.nonce === undefined || txOptions.nonce === null) {\n        const addressVersion = options.network.version === TransactionVersion.Mainnet\n            ? AddressVersion.MainnetSingleSig\n            : AddressVersion.TestnetSingleSig;\n        const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition.signer);\n        const txNonce = await getNonce(senderAddress, options.network);\n        transaction.setNonce(txNonce);\n    }\n    return transaction;\n}\nexport async function makeContractCall(txOptions) {\n    if ('senderKey' in txOptions) {\n        const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n        const options = omit(txOptions, 'senderKey');\n        const transaction = await makeUnsignedContractCall(Object.assign({ publicKey }, options));\n        const privKey = createStacksPrivateKey(txOptions.senderKey);\n        const signer = new TransactionSigner(transaction);\n        signer.signOrigin(privKey);\n        return transaction;\n    }\n    else {\n        const options = omit(txOptions, 'signerKeys');\n        const transaction = await makeUnsignedContractCall(options);\n        const signer = new TransactionSigner(transaction);\n        let pubKeys = txOptions.publicKeys;\n        for (const key of txOptions.signerKeys) {\n            const pubKey = pubKeyfromPrivKey(key);\n            pubKeys = pubKeys.filter(pk => pk !== pubKey.data.toString('hex'));\n            signer.signOrigin(createStacksPrivateKey(key));\n        }\n        for (const key of pubKeys) {\n            signer.appendOrigin(publicKeyFromBuffer(Buffer.from(key, 'hex')));\n        }\n        return transaction;\n    }\n}\nexport function makeStandardSTXPostCondition(address, conditionCode, amount) {\n    return createSTXPostCondition(createStandardPrincipal(address), conditionCode, amount);\n}\nexport function makeContractSTXPostCondition(address, contractName, conditionCode, amount) {\n    return createSTXPostCondition(createContractPrincipal(address, contractName), conditionCode, amount);\n}\nexport function makeStandardFungiblePostCondition(address, conditionCode, amount, assetInfo) {\n    return createFungiblePostCondition(createStandardPrincipal(address), conditionCode, amount, assetInfo);\n}\nexport function makeContractFungiblePostCondition(address, contractName, conditionCode, amount, assetInfo) {\n    return createFungiblePostCondition(createContractPrincipal(address, contractName), conditionCode, amount, assetInfo);\n}\nexport function makeStandardNonFungiblePostCondition(address, conditionCode, assetInfo, assetName) {\n    return createNonFungiblePostCondition(createStandardPrincipal(address), conditionCode, assetInfo, assetName);\n}\nexport function makeContractNonFungiblePostCondition(address, contractName, conditionCode, assetInfo, assetName) {\n    return createNonFungiblePostCondition(createContractPrincipal(address, contractName), conditionCode, assetInfo, assetName);\n}\nexport async function callReadOnlyFunction(readOnlyFunctionOptions) {\n    const defaultOptions = {\n        network: new StacksMainnet(),\n    };\n    const options = Object.assign(defaultOptions, readOnlyFunctionOptions);\n    const { contractName, contractAddress, functionName, functionArgs, network, senderAddress } = options;\n    const url = network.getReadOnlyFunctionCallApiUrl(contractAddress, contractName, functionName);\n    const args = functionArgs.map(arg => cvToHex(arg));\n    const body = JSON.stringify({\n        sender: senderAddress,\n        arguments: args,\n    });\n    const response = await fetchPrivate(url, {\n        method: 'POST',\n        body,\n        headers: {\n            'Content-Type': 'application/json',\n        },\n    });\n    if (!response.ok) {\n        let msg = '';\n        try {\n            msg = await response.text();\n        }\n        catch (error) { }\n        throw new Error(`Error calling read-only function. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n    }\n    return response.json().then(responseJson => parseReadOnlyResponse(responseJson));\n}\nexport async function sponsorTransaction(sponsorOptions) {\n    var _a;\n    const defaultOptions = {\n        fee: 0,\n        sponsorNonce: 0,\n        sponsorAddressHashmode: AddressHashMode.SerializeP2PKH,\n    };\n    const options = Object.assign(defaultOptions, sponsorOptions);\n    const network = (_a = sponsorOptions.network) !== null && _a !== void 0 ? _a : (options.transaction.version === TransactionVersion.Mainnet\n        ? new StacksMainnet()\n        : new StacksTestnet());\n    const sponsorPubKey = pubKeyfromPrivKey(options.sponsorPrivateKey);\n    if (sponsorOptions.fee === undefined || sponsorOptions.fee === null) {\n        let txFee = BigInt(0);\n        switch (options.transaction.payload.payloadType) {\n            case PayloadType.TokenTransfer:\n                txFee = await estimateTransfer(options.transaction, network);\n                break;\n            case PayloadType.SmartContract:\n                txFee = await estimateContractDeploy(options.transaction, network);\n                break;\n            case PayloadType.ContractCall:\n                txFee = await estimateContractFunctionCall(options.transaction, network);\n                break;\n            default:\n                throw new Error(`Sponsored transactions not supported for transaction type ${PayloadType[options.transaction.payload.payloadType]}`);\n        }\n        options.transaction.setFee(txFee);\n        options.fee = txFee;\n    }\n    if (sponsorOptions.sponsorNonce === undefined || sponsorOptions.sponsorNonce === null) {\n        const addressVersion = network.version === TransactionVersion.Mainnet\n            ? AddressVersion.MainnetSingleSig\n            : AddressVersion.TestnetSingleSig;\n        const senderAddress = publicKeyToAddress(addressVersion, sponsorPubKey);\n        const sponsorNonce = await getNonce(senderAddress, network);\n        options.sponsorNonce = sponsorNonce;\n    }\n    const sponsorSpendingCondition = createSingleSigSpendingCondition(options.sponsorAddressHashmode, publicKeyToString(sponsorPubKey), options.sponsorNonce, options.fee);\n    options.transaction.setSponsor(sponsorSpendingCondition);\n    const privKey = createStacksPrivateKey(options.sponsorPrivateKey);\n    const signer = TransactionSigner.createSponsorSigner(options.transaction, sponsorSpendingCondition);\n    signer.signSponsor(privKey);\n    return options.transaction;\n}\n//# sourceMappingURL=builders.js.map"]},"metadata":{},"sourceType":"module"}