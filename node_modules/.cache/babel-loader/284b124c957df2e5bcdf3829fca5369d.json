{"ast":null,"code":"import { Buffer } from '@stacks/common';\nimport Ripemd160Polyfill from 'ripemd160-min';\nimport { isNodeCryptoAvailable } from './cryptoUtils';\nexport class Ripemd160PolyfillDigest {\n  digest(data) {\n    const instance = new Ripemd160Polyfill();\n    instance.update(data);\n    const hash = instance.digest();\n\n    if (Array.isArray(hash)) {\n      return Buffer.from(hash);\n    } else {\n      return Buffer.from(hash.buffer);\n    }\n  }\n\n}\nexport class NodeCryptoRipemd160Digest {\n  constructor(nodeCryptoCreateHash) {\n    this.nodeCryptoCreateHash = nodeCryptoCreateHash;\n  }\n\n  digest(data) {\n    try {\n      return this.nodeCryptoCreateHash('rmd160').update(data).digest();\n    } catch (error) {\n      try {\n        return this.nodeCryptoCreateHash('ripemd160').update(data).digest();\n      } catch (_err) {\n        console.log(error);\n        console.log('Node.js `crypto.createHash` exists but failing to digest for ripemd160, falling back to js implementation');\n        const polyfill = new Ripemd160PolyfillDigest();\n        return polyfill.digest(data);\n      }\n    }\n  }\n\n}\nexport function createHashRipemd160() {\n  const nodeCryptoCreateHash = isNodeCryptoAvailable(nodeCrypto => {\n    if (typeof nodeCrypto.createHash === 'function') {\n      return nodeCrypto.createHash;\n    }\n\n    return false;\n  });\n\n  if (nodeCryptoCreateHash) {\n    return new NodeCryptoRipemd160Digest(nodeCryptoCreateHash);\n  } else {\n    return new Ripemd160PolyfillDigest();\n  }\n}\nexport function hashRipemd160(data) {\n  const hash = createHashRipemd160();\n  return hash.digest(data);\n}","map":{"version":3,"sources":["../../src/hashRipemd160.ts"],"names":[],"mappings":"AAAA,SAAS,MAAT,QAAuB,gBAAvB;AACA,OAAO,iBAAP,MAA8B,eAA9B;AACA,SAAS,qBAAT,QAAsC,eAAtC;AAQA,OAAM,MAAO,uBAAP,CAA8B;AAClC,EAAA,MAAM,CAAC,IAAD,EAAa;AACjB,UAAM,QAAQ,GAAG,IAAI,iBAAJ,EAAjB;AACA,IAAA,QAAQ,CAAC,MAAT,CAAgB,IAAhB;AACA,UAAM,IAAI,GAAG,QAAQ,CAAC,MAAT,EAAb;;AACA,QAAI,KAAK,CAAC,OAAN,CAAc,IAAd,CAAJ,EAAyB;AACvB,aAAO,MAAM,CAAC,IAAP,CAAY,IAAZ,CAAP;AACD,KAFD,MAEO;AACL,aAAO,MAAM,CAAC,IAAP,CAAY,IAAI,CAAC,MAAjB,CAAP;AACD;AACF;;AAViC;AAapC,OAAM,MAAO,yBAAP,CAAgC;AAGpC,EAAA,WAAA,CAAY,oBAAZ,EAAsD;AACpD,SAAK,oBAAL,GAA4B,oBAA5B;AACD;;AAED,EAAA,MAAM,CAAC,IAAD,EAAa;AACjB,QAAI;AACF,aAAO,KAAK,oBAAL,CAA0B,QAA1B,EAAoC,MAApC,CAA2C,IAA3C,EAAiD,MAAjD,EAAP;AACD,KAFD,CAEE,OAAO,KAAP,EAAc;AACd,UAAI;AACF,eAAO,KAAK,oBAAL,CAA0B,WAA1B,EAAuC,MAAvC,CAA8C,IAA9C,EAAoD,MAApD,EAAP;AACD,OAFD,CAEE,OAAO,IAAP,EAAa;AACb,QAAA,OAAO,CAAC,GAAR,CAAY,KAAZ;AACA,QAAA,OAAO,CAAC,GAAR,CACE,2GADF;AAGA,cAAM,QAAQ,GAAG,IAAI,uBAAJ,EAAjB;AACA,eAAO,QAAQ,CAAC,MAAT,CAAgB,IAAhB,CAAP;AACD;AACF;AACF;;AAtBmC;AAyBtC,OAAM,SAAU,mBAAV,GAA6B;AACjC,QAAM,oBAAoB,GAAG,qBAAqB,CAAC,UAAU,IAAG;AAC9D,QAAI,OAAO,UAAU,CAAC,UAAlB,KAAiC,UAArC,EAAiD;AAC/C,aAAO,UAAU,CAAC,UAAlB;AACD;;AACD,WAAO,KAAP;AACD,GALiD,CAAlD;;AAMA,MAAI,oBAAJ,EAA0B;AACxB,WAAO,IAAI,yBAAJ,CAA8B,oBAA9B,CAAP;AACD,GAFD,MAEO;AACL,WAAO,IAAI,uBAAJ,EAAP;AACD;AACF;AAED,OAAM,SAAU,aAAV,CAAwB,IAAxB,EAAoC;AACxC,QAAM,IAAI,GAAG,mBAAmB,EAAhC;AACA,SAAO,IAAI,CAAC,MAAL,CAAY,IAAZ,CAAP;AACD","sourceRoot":"","sourcesContent":["import { Buffer } from '@stacks/common';\nimport Ripemd160Polyfill from 'ripemd160-min';\nimport { isNodeCryptoAvailable } from './cryptoUtils';\nexport class Ripemd160PolyfillDigest {\n    digest(data) {\n        const instance = new Ripemd160Polyfill();\n        instance.update(data);\n        const hash = instance.digest();\n        if (Array.isArray(hash)) {\n            return Buffer.from(hash);\n        }\n        else {\n            return Buffer.from(hash.buffer);\n        }\n    }\n}\nexport class NodeCryptoRipemd160Digest {\n    constructor(nodeCryptoCreateHash) {\n        this.nodeCryptoCreateHash = nodeCryptoCreateHash;\n    }\n    digest(data) {\n        try {\n            return this.nodeCryptoCreateHash('rmd160').update(data).digest();\n        }\n        catch (error) {\n            try {\n                return this.nodeCryptoCreateHash('ripemd160').update(data).digest();\n            }\n            catch (_err) {\n                console.log(error);\n                console.log('Node.js `crypto.createHash` exists but failing to digest for ripemd160, falling back to js implementation');\n                const polyfill = new Ripemd160PolyfillDigest();\n                return polyfill.digest(data);\n            }\n        }\n    }\n}\nexport function createHashRipemd160() {\n    const nodeCryptoCreateHash = isNodeCryptoAvailable(nodeCrypto => {\n        if (typeof nodeCrypto.createHash === 'function') {\n            return nodeCrypto.createHash;\n        }\n        return false;\n    });\n    if (nodeCryptoCreateHash) {\n        return new NodeCryptoRipemd160Digest(nodeCryptoCreateHash);\n    }\n    else {\n        return new Ripemd160PolyfillDigest();\n    }\n}\nexport function hashRipemd160(data) {\n    const hash = createHashRipemd160();\n    return hash.digest(data);\n}\n//# sourceMappingURL=hashRipemd160.js.map"]},"metadata":{},"sourceType":"module"}