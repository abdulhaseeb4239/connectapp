{"ast":null,"code":"import { Buffer } from '@stacks/common';\nimport { MAX_STRING_LENGTH_BYTES, MEMO_MAX_LENGTH_BYTES, AddressHashMode, AddressVersion, TransactionVersion, StacksMessageType, PostConditionPrincipalID } from './constants';\nimport { serializePublicKey, deserializePublicKey, isCompressed } from './keys';\nimport { BufferArray, intToHexString, hexStringToInt, exceedsMaxLengthBytes, hashP2PKH, rightPadHexToLength, hashP2SH } from './utils';\nimport { c32addressDecode, c32address } from 'c32check';\nimport { serializePostCondition, deserializePostCondition } from './postcondition';\nimport { deserializePayload, serializePayload } from './payload';\nimport { DeserializationError } from './errors';\nimport { deserializeTransactionAuthField, deserializeMessageSignature, serializeMessageSignature, serializeTransactionAuthField } from './authorization';\nexport function serializeStacksMessage(message) {\n  switch (message.type) {\n    case StacksMessageType.Address:\n      return serializeAddress(message);\n\n    case StacksMessageType.Principal:\n      return serializePrincipal(message);\n\n    case StacksMessageType.LengthPrefixedString:\n      return serializeLPString(message);\n\n    case StacksMessageType.MemoString:\n      return serializeMemoString(message);\n\n    case StacksMessageType.AssetInfo:\n      return serializeAssetInfo(message);\n\n    case StacksMessageType.PostCondition:\n      return serializePostCondition(message);\n\n    case StacksMessageType.PublicKey:\n      return serializePublicKey(message);\n\n    case StacksMessageType.LengthPrefixedList:\n      return serializeLPList(message);\n\n    case StacksMessageType.Payload:\n      return serializePayload(message);\n\n    case StacksMessageType.TransactionAuthField:\n      return serializeTransactionAuthField(message);\n\n    case StacksMessageType.MessageSignature:\n      return serializeMessageSignature(message);\n  }\n}\nexport function deserializeStacksMessage(bufferReader, type, listType) {\n  switch (type) {\n    case StacksMessageType.Address:\n      return deserializeAddress(bufferReader);\n\n    case StacksMessageType.Principal:\n      return deserializePrincipal(bufferReader);\n\n    case StacksMessageType.LengthPrefixedString:\n      return deserializeLPString(bufferReader);\n\n    case StacksMessageType.MemoString:\n      return deserializeMemoString(bufferReader);\n\n    case StacksMessageType.AssetInfo:\n      return deserializeAssetInfo(bufferReader);\n\n    case StacksMessageType.PostCondition:\n      return deserializePostCondition(bufferReader);\n\n    case StacksMessageType.PublicKey:\n      return deserializePublicKey(bufferReader);\n\n    case StacksMessageType.Payload:\n      return deserializePayload(bufferReader);\n\n    case StacksMessageType.LengthPrefixedList:\n      if (!listType) {\n        throw new DeserializationError('No List Type specified');\n      }\n\n      return deserializeLPList(bufferReader, listType);\n\n    case StacksMessageType.MessageSignature:\n      return deserializeMessageSignature(bufferReader);\n\n    default:\n      throw new Error('Could not recognize StacksMessageType');\n  }\n}\nexport function createAddress(c32AddressString) {\n  const addressData = c32addressDecode(c32AddressString);\n  return {\n    type: StacksMessageType.Address,\n    version: addressData[0],\n    hash160: addressData[1]\n  };\n}\nexport function createEmptyAddress() {\n  return {\n    type: StacksMessageType.Address,\n    version: AddressVersion.MainnetSingleSig,\n    hash160: '0'.repeat(40)\n  };\n}\nexport function addressFromVersionHash(version, hash) {\n  return {\n    type: StacksMessageType.Address,\n    version,\n    hash160: hash\n  };\n}\nexport function addressHashModeToVersion(hashMode, txVersion) {\n  switch (hashMode) {\n    case AddressHashMode.SerializeP2PKH:\n      switch (txVersion) {\n        case TransactionVersion.Mainnet:\n          return AddressVersion.MainnetSingleSig;\n\n        case TransactionVersion.Testnet:\n          return AddressVersion.TestnetSingleSig;\n\n        default:\n          throw new Error(`Unexpected txVersion ${JSON.stringify(txVersion)} for hashMode ${hashMode}`);\n      }\n\n    case AddressHashMode.SerializeP2SH:\n    case AddressHashMode.SerializeP2WPKH:\n    case AddressHashMode.SerializeP2WSH:\n      switch (txVersion) {\n        case TransactionVersion.Mainnet:\n          return AddressVersion.MainnetMultiSig;\n\n        case TransactionVersion.Testnet:\n          return AddressVersion.TestnetMultiSig;\n\n        default:\n          throw new Error(`Unexpected txVersion ${JSON.stringify(txVersion)} for hashMode ${hashMode}`);\n      }\n\n    default:\n      throw new Error(`Unexpected hashMode ${JSON.stringify(hashMode)}`);\n  }\n}\nexport function addressFromHashMode(hashMode, txVersion, data) {\n  const version = addressHashModeToVersion(hashMode, txVersion);\n  return addressFromVersionHash(version, data);\n}\nexport function addressFromPublicKeys(version, hashMode, numSigs, publicKeys) {\n  if (publicKeys.length === 0) {\n    throw Error('Invalid number of public keys');\n  }\n\n  if (hashMode === AddressHashMode.SerializeP2PKH || hashMode === AddressHashMode.SerializeP2WPKH) {\n    if (publicKeys.length !== 1 || numSigs !== 1) {\n      throw Error('Invalid number of public keys or signatures');\n    }\n  }\n\n  if (hashMode === AddressHashMode.SerializeP2WPKH || hashMode === AddressHashMode.SerializeP2WSH) {\n    for (let i = 0; i < publicKeys.length; i++) {\n      if (!isCompressed(publicKeys[i])) {\n        throw Error('Public keys must be compressed for segwit');\n      }\n    }\n  }\n\n  switch (hashMode) {\n    case AddressHashMode.SerializeP2PKH:\n      return addressFromVersionHash(version, hashP2PKH(publicKeys[0].data));\n\n    case AddressHashMode.SerializeP2SH:\n      return addressFromVersionHash(version, hashP2SH(numSigs, publicKeys.map(serializePublicKey)));\n\n    default:\n      throw Error(`Not yet implemented: address construction using public keys for hash mode: ${hashMode}`);\n  }\n}\nexport function addressToString(address) {\n  return c32address(address.version, address.hash160).toString();\n}\nexport function serializeAddress(address) {\n  const bufferArray = new BufferArray();\n  bufferArray.appendHexString(intToHexString(address.version, 1));\n  bufferArray.appendHexString(address.hash160);\n  return bufferArray.concatBuffer();\n}\nexport function deserializeAddress(bufferReader) {\n  const version = hexStringToInt(bufferReader.readBuffer(1).toString('hex'));\n  const data = bufferReader.readBuffer(20).toString('hex');\n  return {\n    type: StacksMessageType.Address,\n    version,\n    hash160: data\n  };\n}\nexport function parsePrincipalString(principalString) {\n  if (principalString.includes('.')) {\n    const [address, contractName] = principalString.split('.');\n    return createContractPrincipal(address, contractName);\n  } else {\n    return createStandardPrincipal(principalString);\n  }\n}\nexport function createStandardPrincipal(addressString) {\n  const addr = createAddress(addressString);\n  return {\n    type: StacksMessageType.Principal,\n    prefix: PostConditionPrincipalID.Standard,\n    address: addr\n  };\n}\nexport function createContractPrincipal(addressString, contractName) {\n  const addr = createAddress(addressString);\n  const name = createLPString(contractName);\n  return {\n    type: StacksMessageType.Principal,\n    prefix: PostConditionPrincipalID.Contract,\n    address: addr,\n    contractName: name\n  };\n}\nexport function serializePrincipal(principal) {\n  const bufferArray = new BufferArray();\n  bufferArray.push(Buffer.from([principal.prefix]));\n  bufferArray.push(serializeAddress(principal.address));\n\n  if (principal.prefix === PostConditionPrincipalID.Contract) {\n    bufferArray.push(serializeLPString(principal.contractName));\n  }\n\n  return bufferArray.concatBuffer();\n}\nexport function deserializePrincipal(bufferReader) {\n  const prefix = bufferReader.readUInt8Enum(PostConditionPrincipalID, _ => {\n    throw new DeserializationError('Unexpected Principal payload type: ${n}');\n  });\n  const address = deserializeAddress(bufferReader);\n\n  if (prefix === PostConditionPrincipalID.Standard) {\n    return {\n      type: StacksMessageType.Principal,\n      prefix,\n      address\n    };\n  }\n\n  const contractName = deserializeLPString(bufferReader);\n  return {\n    type: StacksMessageType.Principal,\n    prefix,\n    address,\n    contractName\n  };\n}\nexport function createLPString(content, lengthPrefixBytes, maxLengthBytes) {\n  const prefixLength = lengthPrefixBytes || 1;\n  const maxLength = maxLengthBytes || MAX_STRING_LENGTH_BYTES;\n\n  if (exceedsMaxLengthBytes(content, maxLength)) {\n    throw new Error(`String length exceeds maximum bytes ${maxLength.toString()}`);\n  }\n\n  return {\n    type: StacksMessageType.LengthPrefixedString,\n    content,\n    lengthPrefixBytes: prefixLength,\n    maxLengthBytes: maxLength\n  };\n}\nexport function serializeLPString(lps) {\n  const bufferArray = new BufferArray();\n  const contentBuffer = Buffer.from(lps.content);\n  const length = contentBuffer.byteLength;\n  bufferArray.appendHexString(intToHexString(length, lps.lengthPrefixBytes));\n  bufferArray.push(contentBuffer);\n  return bufferArray.concatBuffer();\n}\nexport function deserializeLPString(bufferReader, prefixBytes, maxLength) {\n  prefixBytes = prefixBytes ? prefixBytes : 1;\n  const length = hexStringToInt(bufferReader.readBuffer(prefixBytes).toString('hex'));\n  const content = bufferReader.readBuffer(length).toString();\n  return createLPString(content, prefixBytes, maxLength !== null && maxLength !== void 0 ? maxLength : 128);\n}\nexport function codeBodyString(content) {\n  return createLPString(content, 4, 100000);\n}\nexport function createMemoString(content) {\n  if (content && exceedsMaxLengthBytes(content, MEMO_MAX_LENGTH_BYTES)) {\n    throw new Error(`Memo exceeds maximum length of ${MEMO_MAX_LENGTH_BYTES.toString()} bytes`);\n  }\n\n  return {\n    type: StacksMessageType.MemoString,\n    content\n  };\n}\nexport function serializeMemoString(memoString) {\n  const bufferArray = new BufferArray();\n  const contentBuffer = Buffer.from(memoString.content);\n  const paddedContent = rightPadHexToLength(contentBuffer.toString('hex'), MEMO_MAX_LENGTH_BYTES * 2);\n  bufferArray.push(Buffer.from(paddedContent, 'hex'));\n  return bufferArray.concatBuffer();\n}\nexport function deserializeMemoString(bufferReader) {\n  const content = bufferReader.readBuffer(MEMO_MAX_LENGTH_BYTES).toString();\n  return {\n    type: StacksMessageType.MemoString,\n    content\n  };\n}\nexport function parseAssetInfoString(id) {\n  const [assetAddress, assetContractName, assetTokenName] = id.split(/\\.|::/);\n  const assetInfo = createAssetInfo(assetAddress, assetContractName, assetTokenName);\n  return assetInfo;\n}\nexport function createAssetInfo(addressString, contractName, assetName) {\n  return {\n    type: StacksMessageType.AssetInfo,\n    address: createAddress(addressString),\n    contractName: createLPString(contractName),\n    assetName: createLPString(assetName)\n  };\n}\nexport function serializeAssetInfo(info) {\n  const bufferArray = new BufferArray();\n  bufferArray.push(serializeAddress(info.address));\n  bufferArray.push(serializeLPString(info.contractName));\n  bufferArray.push(serializeLPString(info.assetName));\n  return bufferArray.concatBuffer();\n}\nexport function deserializeAssetInfo(bufferReader) {\n  return {\n    type: StacksMessageType.AssetInfo,\n    address: deserializeAddress(bufferReader),\n    contractName: deserializeLPString(bufferReader),\n    assetName: deserializeLPString(bufferReader)\n  };\n}\nexport function createLPList(values, lengthPrefixBytes) {\n  return {\n    type: StacksMessageType.LengthPrefixedList,\n    lengthPrefixBytes: lengthPrefixBytes || 4,\n    values\n  };\n}\nexport function serializeLPList(lpList) {\n  const list = lpList.values;\n  const bufferArray = new BufferArray();\n  bufferArray.appendHexString(intToHexString(list.length, lpList.lengthPrefixBytes));\n\n  for (let index = 0; index < list.length; index++) {\n    bufferArray.push(serializeStacksMessage(list[index]));\n  }\n\n  return bufferArray.concatBuffer();\n}\nexport function deserializeLPList(bufferReader, type, lengthPrefixBytes) {\n  const length = hexStringToInt(bufferReader.readBuffer(lengthPrefixBytes || 4).toString('hex'));\n  const l = [];\n\n  for (let index = 0; index < length; index++) {\n    switch (type) {\n      case StacksMessageType.Address:\n        l.push(deserializeAddress(bufferReader));\n        break;\n\n      case StacksMessageType.LengthPrefixedString:\n        l.push(deserializeLPString(bufferReader));\n        break;\n\n      case StacksMessageType.MemoString:\n        l.push(deserializeMemoString(bufferReader));\n        break;\n\n      case StacksMessageType.AssetInfo:\n        l.push(deserializeAssetInfo(bufferReader));\n        break;\n\n      case StacksMessageType.PostCondition:\n        l.push(deserializePostCondition(bufferReader));\n        break;\n\n      case StacksMessageType.PublicKey:\n        l.push(deserializePublicKey(bufferReader));\n        break;\n\n      case StacksMessageType.TransactionAuthField:\n        l.push(deserializeTransactionAuthField(bufferReader));\n        break;\n    }\n  }\n\n  return createLPList(l, lengthPrefixBytes);\n}","map":{"version":3,"sources":["../../src/types.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Buffer } from '@stacks/common';\nimport { MAX_STRING_LENGTH_BYTES, MEMO_MAX_LENGTH_BYTES, AddressHashMode, AddressVersion, TransactionVersion, StacksMessageType, PostConditionPrincipalID, } from './constants';\nimport { serializePublicKey, deserializePublicKey, isCompressed } from './keys';\nimport { BufferArray, intToHexString, hexStringToInt, exceedsMaxLengthBytes, hashP2PKH, rightPadHexToLength, hashP2SH, } from './utils';\nimport { c32addressDecode, c32address } from 'c32check';\nimport { serializePostCondition, deserializePostCondition } from './postcondition';\nimport { deserializePayload, serializePayload } from './payload';\nimport { DeserializationError } from './errors';\nimport { deserializeTransactionAuthField, deserializeMessageSignature, serializeMessageSignature, serializeTransactionAuthField, } from './authorization';\nexport function serializeStacksMessage(message) {\n    switch (message.type) {\n        case StacksMessageType.Address:\n            return serializeAddress(message);\n        case StacksMessageType.Principal:\n            return serializePrincipal(message);\n        case StacksMessageType.LengthPrefixedString:\n            return serializeLPString(message);\n        case StacksMessageType.MemoString:\n            return serializeMemoString(message);\n        case StacksMessageType.AssetInfo:\n            return serializeAssetInfo(message);\n        case StacksMessageType.PostCondition:\n            return serializePostCondition(message);\n        case StacksMessageType.PublicKey:\n            return serializePublicKey(message);\n        case StacksMessageType.LengthPrefixedList:\n            return serializeLPList(message);\n        case StacksMessageType.Payload:\n            return serializePayload(message);\n        case StacksMessageType.TransactionAuthField:\n            return serializeTransactionAuthField(message);\n        case StacksMessageType.MessageSignature:\n            return serializeMessageSignature(message);\n    }\n}\nexport function deserializeStacksMessage(bufferReader, type, listType) {\n    switch (type) {\n        case StacksMessageType.Address:\n            return deserializeAddress(bufferReader);\n        case StacksMessageType.Principal:\n            return deserializePrincipal(bufferReader);\n        case StacksMessageType.LengthPrefixedString:\n            return deserializeLPString(bufferReader);\n        case StacksMessageType.MemoString:\n            return deserializeMemoString(bufferReader);\n        case StacksMessageType.AssetInfo:\n            return deserializeAssetInfo(bufferReader);\n        case StacksMessageType.PostCondition:\n            return deserializePostCondition(bufferReader);\n        case StacksMessageType.PublicKey:\n            return deserializePublicKey(bufferReader);\n        case StacksMessageType.Payload:\n            return deserializePayload(bufferReader);\n        case StacksMessageType.LengthPrefixedList:\n            if (!listType) {\n                throw new DeserializationError('No List Type specified');\n            }\n            return deserializeLPList(bufferReader, listType);\n        case StacksMessageType.MessageSignature:\n            return deserializeMessageSignature(bufferReader);\n        default:\n            throw new Error('Could not recognize StacksMessageType');\n    }\n}\nexport function createAddress(c32AddressString) {\n    const addressData = c32addressDecode(c32AddressString);\n    return {\n        type: StacksMessageType.Address,\n        version: addressData[0],\n        hash160: addressData[1],\n    };\n}\nexport function createEmptyAddress() {\n    return {\n        type: StacksMessageType.Address,\n        version: AddressVersion.MainnetSingleSig,\n        hash160: '0'.repeat(40),\n    };\n}\nexport function addressFromVersionHash(version, hash) {\n    return { type: StacksMessageType.Address, version, hash160: hash };\n}\nexport function addressHashModeToVersion(hashMode, txVersion) {\n    switch (hashMode) {\n        case AddressHashMode.SerializeP2PKH:\n            switch (txVersion) {\n                case TransactionVersion.Mainnet:\n                    return AddressVersion.MainnetSingleSig;\n                case TransactionVersion.Testnet:\n                    return AddressVersion.TestnetSingleSig;\n                default:\n                    throw new Error(`Unexpected txVersion ${JSON.stringify(txVersion)} for hashMode ${hashMode}`);\n            }\n        case AddressHashMode.SerializeP2SH:\n        case AddressHashMode.SerializeP2WPKH:\n        case AddressHashMode.SerializeP2WSH:\n            switch (txVersion) {\n                case TransactionVersion.Mainnet:\n                    return AddressVersion.MainnetMultiSig;\n                case TransactionVersion.Testnet:\n                    return AddressVersion.TestnetMultiSig;\n                default:\n                    throw new Error(`Unexpected txVersion ${JSON.stringify(txVersion)} for hashMode ${hashMode}`);\n            }\n        default:\n            throw new Error(`Unexpected hashMode ${JSON.stringify(hashMode)}`);\n    }\n}\nexport function addressFromHashMode(hashMode, txVersion, data) {\n    const version = addressHashModeToVersion(hashMode, txVersion);\n    return addressFromVersionHash(version, data);\n}\nexport function addressFromPublicKeys(version, hashMode, numSigs, publicKeys) {\n    if (publicKeys.length === 0) {\n        throw Error('Invalid number of public keys');\n    }\n    if (hashMode === AddressHashMode.SerializeP2PKH || hashMode === AddressHashMode.SerializeP2WPKH) {\n        if (publicKeys.length !== 1 || numSigs !== 1) {\n            throw Error('Invalid number of public keys or signatures');\n        }\n    }\n    if (hashMode === AddressHashMode.SerializeP2WPKH || hashMode === AddressHashMode.SerializeP2WSH) {\n        for (let i = 0; i < publicKeys.length; i++) {\n            if (!isCompressed(publicKeys[i])) {\n                throw Error('Public keys must be compressed for segwit');\n            }\n        }\n    }\n    switch (hashMode) {\n        case AddressHashMode.SerializeP2PKH:\n            return addressFromVersionHash(version, hashP2PKH(publicKeys[0].data));\n        case AddressHashMode.SerializeP2SH:\n            return addressFromVersionHash(version, hashP2SH(numSigs, publicKeys.map(serializePublicKey)));\n        default:\n            throw Error(`Not yet implemented: address construction using public keys for hash mode: ${hashMode}`);\n    }\n}\nexport function addressToString(address) {\n    return c32address(address.version, address.hash160).toString();\n}\nexport function serializeAddress(address) {\n    const bufferArray = new BufferArray();\n    bufferArray.appendHexString(intToHexString(address.version, 1));\n    bufferArray.appendHexString(address.hash160);\n    return bufferArray.concatBuffer();\n}\nexport function deserializeAddress(bufferReader) {\n    const version = hexStringToInt(bufferReader.readBuffer(1).toString('hex'));\n    const data = bufferReader.readBuffer(20).toString('hex');\n    return { type: StacksMessageType.Address, version, hash160: data };\n}\nexport function parsePrincipalString(principalString) {\n    if (principalString.includes('.')) {\n        const [address, contractName] = principalString.split('.');\n        return createContractPrincipal(address, contractName);\n    }\n    else {\n        return createStandardPrincipal(principalString);\n    }\n}\nexport function createStandardPrincipal(addressString) {\n    const addr = createAddress(addressString);\n    return {\n        type: StacksMessageType.Principal,\n        prefix: PostConditionPrincipalID.Standard,\n        address: addr,\n    };\n}\nexport function createContractPrincipal(addressString, contractName) {\n    const addr = createAddress(addressString);\n    const name = createLPString(contractName);\n    return {\n        type: StacksMessageType.Principal,\n        prefix: PostConditionPrincipalID.Contract,\n        address: addr,\n        contractName: name,\n    };\n}\nexport function serializePrincipal(principal) {\n    const bufferArray = new BufferArray();\n    bufferArray.push(Buffer.from([principal.prefix]));\n    bufferArray.push(serializeAddress(principal.address));\n    if (principal.prefix === PostConditionPrincipalID.Contract) {\n        bufferArray.push(serializeLPString(principal.contractName));\n    }\n    return bufferArray.concatBuffer();\n}\nexport function deserializePrincipal(bufferReader) {\n    const prefix = bufferReader.readUInt8Enum(PostConditionPrincipalID, _ => {\n        throw new DeserializationError('Unexpected Principal payload type: ${n}');\n    });\n    const address = deserializeAddress(bufferReader);\n    if (prefix === PostConditionPrincipalID.Standard) {\n        return { type: StacksMessageType.Principal, prefix, address };\n    }\n    const contractName = deserializeLPString(bufferReader);\n    return {\n        type: StacksMessageType.Principal,\n        prefix,\n        address,\n        contractName,\n    };\n}\nexport function createLPString(content, lengthPrefixBytes, maxLengthBytes) {\n    const prefixLength = lengthPrefixBytes || 1;\n    const maxLength = maxLengthBytes || MAX_STRING_LENGTH_BYTES;\n    if (exceedsMaxLengthBytes(content, maxLength)) {\n        throw new Error(`String length exceeds maximum bytes ${maxLength.toString()}`);\n    }\n    return {\n        type: StacksMessageType.LengthPrefixedString,\n        content,\n        lengthPrefixBytes: prefixLength,\n        maxLengthBytes: maxLength,\n    };\n}\nexport function serializeLPString(lps) {\n    const bufferArray = new BufferArray();\n    const contentBuffer = Buffer.from(lps.content);\n    const length = contentBuffer.byteLength;\n    bufferArray.appendHexString(intToHexString(length, lps.lengthPrefixBytes));\n    bufferArray.push(contentBuffer);\n    return bufferArray.concatBuffer();\n}\nexport function deserializeLPString(bufferReader, prefixBytes, maxLength) {\n    prefixBytes = prefixBytes ? prefixBytes : 1;\n    const length = hexStringToInt(bufferReader.readBuffer(prefixBytes).toString('hex'));\n    const content = bufferReader.readBuffer(length).toString();\n    return createLPString(content, prefixBytes, maxLength !== null && maxLength !== void 0 ? maxLength : 128);\n}\nexport function codeBodyString(content) {\n    return createLPString(content, 4, 100000);\n}\nexport function createMemoString(content) {\n    if (content && exceedsMaxLengthBytes(content, MEMO_MAX_LENGTH_BYTES)) {\n        throw new Error(`Memo exceeds maximum length of ${MEMO_MAX_LENGTH_BYTES.toString()} bytes`);\n    }\n    return { type: StacksMessageType.MemoString, content };\n}\nexport function serializeMemoString(memoString) {\n    const bufferArray = new BufferArray();\n    const contentBuffer = Buffer.from(memoString.content);\n    const paddedContent = rightPadHexToLength(contentBuffer.toString('hex'), MEMO_MAX_LENGTH_BYTES * 2);\n    bufferArray.push(Buffer.from(paddedContent, 'hex'));\n    return bufferArray.concatBuffer();\n}\nexport function deserializeMemoString(bufferReader) {\n    const content = bufferReader.readBuffer(MEMO_MAX_LENGTH_BYTES).toString();\n    return { type: StacksMessageType.MemoString, content };\n}\nexport function parseAssetInfoString(id) {\n    const [assetAddress, assetContractName, assetTokenName] = id.split(/\\.|::/);\n    const assetInfo = createAssetInfo(assetAddress, assetContractName, assetTokenName);\n    return assetInfo;\n}\nexport function createAssetInfo(addressString, contractName, assetName) {\n    return {\n        type: StacksMessageType.AssetInfo,\n        address: createAddress(addressString),\n        contractName: createLPString(contractName),\n        assetName: createLPString(assetName),\n    };\n}\nexport function serializeAssetInfo(info) {\n    const bufferArray = new BufferArray();\n    bufferArray.push(serializeAddress(info.address));\n    bufferArray.push(serializeLPString(info.contractName));\n    bufferArray.push(serializeLPString(info.assetName));\n    return bufferArray.concatBuffer();\n}\nexport function deserializeAssetInfo(bufferReader) {\n    return {\n        type: StacksMessageType.AssetInfo,\n        address: deserializeAddress(bufferReader),\n        contractName: deserializeLPString(bufferReader),\n        assetName: deserializeLPString(bufferReader),\n    };\n}\nexport function createLPList(values, lengthPrefixBytes) {\n    return {\n        type: StacksMessageType.LengthPrefixedList,\n        lengthPrefixBytes: lengthPrefixBytes || 4,\n        values,\n    };\n}\nexport function serializeLPList(lpList) {\n    const list = lpList.values;\n    const bufferArray = new BufferArray();\n    bufferArray.appendHexString(intToHexString(list.length, lpList.lengthPrefixBytes));\n    for (let index = 0; index < list.length; index++) {\n        bufferArray.push(serializeStacksMessage(list[index]));\n    }\n    return bufferArray.concatBuffer();\n}\nexport function deserializeLPList(bufferReader, type, lengthPrefixBytes) {\n    const length = hexStringToInt(bufferReader.readBuffer(lengthPrefixBytes || 4).toString('hex'));\n    const l = [];\n    for (let index = 0; index < length; index++) {\n        switch (type) {\n            case StacksMessageType.Address:\n                l.push(deserializeAddress(bufferReader));\n                break;\n            case StacksMessageType.LengthPrefixedString:\n                l.push(deserializeLPString(bufferReader));\n                break;\n            case StacksMessageType.MemoString:\n                l.push(deserializeMemoString(bufferReader));\n                break;\n            case StacksMessageType.AssetInfo:\n                l.push(deserializeAssetInfo(bufferReader));\n                break;\n            case StacksMessageType.PostCondition:\n                l.push(deserializePostCondition(bufferReader));\n                break;\n            case StacksMessageType.PublicKey:\n                l.push(deserializePublicKey(bufferReader));\n                break;\n            case StacksMessageType.TransactionAuthField:\n                l.push(deserializeTransactionAuthField(bufferReader));\n                break;\n        }\n    }\n    return createLPList(l, lengthPrefixBytes);\n}\n//# sourceMappingURL=types.js.map"]},"metadata":{},"sourceType":"module"}