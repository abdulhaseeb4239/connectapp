{"ast":null,"code":"import { Buffer } from '@stacks/common';\nimport { sha256, sha512 } from 'sha.js';\nimport { getCryptoLib } from './cryptoUtils';\nexport class NodeCryptoSha2Hash {\n  constructor(createHash) {\n    this.createHash = createHash;\n  }\n\n  async digest(data, algorithm = 'sha256') {\n    try {\n      const result = this.createHash(algorithm).update(data).digest();\n      return Promise.resolve(result);\n    } catch (error) {\n      console.log(error);\n      console.log(`Error performing ${algorithm} digest with Node.js 'crypto.createHash', falling back to JS implementation.`);\n      return Promise.resolve(algorithm === 'sha256' ? hashSha256Sync(data) : hashSha512Sync(data));\n    }\n  }\n\n}\nexport class WebCryptoSha2Hash {\n  constructor(subtleCrypto) {\n    this.subtleCrypto = subtleCrypto;\n  }\n\n  async digest(data, algorithm = 'sha256') {\n    let algo;\n\n    if (algorithm === 'sha256') {\n      algo = 'SHA-256';\n    } else if (algorithm === 'sha512') {\n      algo = 'SHA-512';\n    } else {\n      throw new Error(`Unsupported hash algorithm ${algorithm}`);\n    }\n\n    try {\n      const hash = await this.subtleCrypto.digest(algo, data);\n      return Buffer.from(hash);\n    } catch (error) {\n      console.log(error);\n      console.log(`Error performing ${algorithm} digest with WebCrypto, falling back to JS implementation.`);\n      return Promise.resolve(algorithm === 'sha256' ? hashSha256Sync(data) : hashSha512Sync(data));\n    }\n  }\n\n}\nexport async function createSha2Hash() {\n  const cryptoLib = await getCryptoLib();\n\n  if (cryptoLib.name === 'subtleCrypto') {\n    return new WebCryptoSha2Hash(cryptoLib.lib);\n  } else {\n    return new NodeCryptoSha2Hash(cryptoLib.lib.createHash);\n  }\n}\nexport function hashSha256Sync(data) {\n  const hash = new sha256();\n  hash.update(data);\n  return hash.digest();\n}\nexport function hashSha512Sync(data) {\n  const hash = new sha512();\n  hash.update(data);\n  return hash.digest();\n}","map":{"version":3,"sources":["../../src/sha2Hash.ts"],"names":[],"mappings":"AAAA,SAAS,MAAT,QAAuB,gBAAvB;AACA,SAAS,MAAT,EAAiB,MAAjB,QAA+B,QAA/B;AACA,SAAS,YAAT,QAA6B,eAA7B;AAQA,OAAM,MAAO,kBAAP,CAAyB;AAG7B,EAAA,WAAA,CAAY,UAAZ,EAA4C;AAC1C,SAAK,UAAL,GAAkB,UAAlB;AACD;;AAEW,QAAN,MAAM,CAAC,IAAD,EAAe,SAAS,GAAG,QAA3B,EAAmC;AAC7C,QAAI;AACF,YAAM,MAAM,GAAG,KAAK,UAAL,CAAgB,SAAhB,EAA2B,MAA3B,CAAkC,IAAlC,EAAwC,MAAxC,EAAf;AACA,aAAO,OAAO,CAAC,OAAR,CAAgB,MAAhB,CAAP;AACD,KAHD,CAGE,OAAO,KAAP,EAAc;AACd,MAAA,OAAO,CAAC,GAAR,CAAY,KAAZ;AACA,MAAA,OAAO,CAAC,GAAR,CACE,oBAAoB,SAAS,8EAD/B;AAGA,aAAO,OAAO,CAAC,OAAR,CAAgB,SAAS,KAAK,QAAd,GAAyB,cAAc,CAAC,IAAD,CAAvC,GAAgD,cAAc,CAAC,IAAD,CAA9E,CAAP;AACD;AACF;;AAlB4B;AAqB/B,OAAM,MAAO,iBAAP,CAAwB;AAG5B,EAAA,WAAA,CAAY,YAAZ,EAAsC;AACpC,SAAK,YAAL,GAAoB,YAApB;AACD;;AAEW,QAAN,MAAM,CAAC,IAAD,EAAe,SAAS,GAAG,QAA3B,EAAmC;AAC7C,QAAI,IAAJ;;AACA,QAAI,SAAS,KAAK,QAAlB,EAA4B;AAC1B,MAAA,IAAI,GAAG,SAAP;AACD,KAFD,MAEO,IAAI,SAAS,KAAK,QAAlB,EAA4B;AACjC,MAAA,IAAI,GAAG,SAAP;AACD,KAFM,MAEA;AACL,YAAM,IAAI,KAAJ,CAAU,8BAA8B,SAAS,EAAjD,CAAN;AACD;;AACD,QAAI;AACF,YAAM,IAAI,GAAG,MAAM,KAAK,YAAL,CAAkB,MAAlB,CAAyB,IAAzB,EAA+B,IAA/B,CAAnB;AACA,aAAO,MAAM,CAAC,IAAP,CAAY,IAAZ,CAAP;AACD,KAHD,CAGE,OAAO,KAAP,EAAc;AACd,MAAA,OAAO,CAAC,GAAR,CAAY,KAAZ;AACA,MAAA,OAAO,CAAC,GAAR,CACE,oBAAoB,SAAS,4DAD/B;AAGA,aAAO,OAAO,CAAC,OAAR,CAAgB,SAAS,KAAK,QAAd,GAAyB,cAAc,CAAC,IAAD,CAAvC,GAAgD,cAAc,CAAC,IAAD,CAA9E,CAAP;AACD;AACF;;AA1B2B;AA6B9B,OAAO,eAAe,cAAf,GAA6B;AAClC,QAAM,SAAS,GAAG,MAAM,YAAY,EAApC;;AACA,MAAI,SAAS,CAAC,IAAV,KAAmB,cAAvB,EAAuC;AACrC,WAAO,IAAI,iBAAJ,CAAsB,SAAS,CAAC,GAAhC,CAAP;AACD,GAFD,MAEO;AACL,WAAO,IAAI,kBAAJ,CAAuB,SAAS,CAAC,GAAV,CAAc,UAArC,CAAP;AACD;AACF;AAED,OAAM,SAAU,cAAV,CAAyB,IAAzB,EAAqC;AACzC,QAAM,IAAI,GAAG,IAAI,MAAJ,EAAb;AACA,EAAA,IAAI,CAAC,MAAL,CAAY,IAAZ;AACA,SAAO,IAAI,CAAC,MAAL,EAAP;AACD;AAED,OAAM,SAAU,cAAV,CAAyB,IAAzB,EAAqC;AACzC,QAAM,IAAI,GAAG,IAAI,MAAJ,EAAb;AACA,EAAA,IAAI,CAAC,MAAL,CAAY,IAAZ;AACA,SAAO,IAAI,CAAC,MAAL,EAAP;AACD","sourceRoot":"","sourcesContent":["import { Buffer } from '@stacks/common';\nimport { sha256, sha512 } from 'sha.js';\nimport { getCryptoLib } from './cryptoUtils';\nexport class NodeCryptoSha2Hash {\n    constructor(createHash) {\n        this.createHash = createHash;\n    }\n    async digest(data, algorithm = 'sha256') {\n        try {\n            const result = this.createHash(algorithm).update(data).digest();\n            return Promise.resolve(result);\n        }\n        catch (error) {\n            console.log(error);\n            console.log(`Error performing ${algorithm} digest with Node.js 'crypto.createHash', falling back to JS implementation.`);\n            return Promise.resolve(algorithm === 'sha256' ? hashSha256Sync(data) : hashSha512Sync(data));\n        }\n    }\n}\nexport class WebCryptoSha2Hash {\n    constructor(subtleCrypto) {\n        this.subtleCrypto = subtleCrypto;\n    }\n    async digest(data, algorithm = 'sha256') {\n        let algo;\n        if (algorithm === 'sha256') {\n            algo = 'SHA-256';\n        }\n        else if (algorithm === 'sha512') {\n            algo = 'SHA-512';\n        }\n        else {\n            throw new Error(`Unsupported hash algorithm ${algorithm}`);\n        }\n        try {\n            const hash = await this.subtleCrypto.digest(algo, data);\n            return Buffer.from(hash);\n        }\n        catch (error) {\n            console.log(error);\n            console.log(`Error performing ${algorithm} digest with WebCrypto, falling back to JS implementation.`);\n            return Promise.resolve(algorithm === 'sha256' ? hashSha256Sync(data) : hashSha512Sync(data));\n        }\n    }\n}\nexport async function createSha2Hash() {\n    const cryptoLib = await getCryptoLib();\n    if (cryptoLib.name === 'subtleCrypto') {\n        return new WebCryptoSha2Hash(cryptoLib.lib);\n    }\n    else {\n        return new NodeCryptoSha2Hash(cryptoLib.lib.createHash);\n    }\n}\nexport function hashSha256Sync(data) {\n    const hash = new sha256();\n    hash.update(data);\n    return hash.digest();\n}\nexport function hashSha512Sync(data) {\n    const hash = new sha512();\n    hash.update(data);\n    return hash.digest();\n}\n//# sourceMappingURL=sha2Hash.js.map"]},"metadata":{},"sourceType":"module"}