{"ast":null,"code":"import { decodeToken, TokenVerifier } from 'jsontokens';\nimport { getAddressFromDID } from './dids';\nimport { publicKeyToAddress } from '@stacks/encryption';\nimport { fetchPrivate, isSameOriginAbsoluteUrl } from '@stacks/common';\nimport { fetchAppManifest } from './provider';\nimport { c32ToB58 } from 'c32check';\nexport function doSignaturesMatchPublicKeys(token) {\n  const payload = decodeToken(token).payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  const publicKeys = payload.public_keys;\n\n  if (publicKeys.length === 1) {\n    const publicKey = publicKeys[0];\n\n    try {\n      const tokenVerifier = new TokenVerifier('ES256k', publicKey);\n      return tokenVerifier.verify(token);\n    } catch (e) {\n      return false;\n    }\n  } else {\n    throw new Error('Multiple public keys are not supported');\n  }\n}\nexport function doPublicKeysMatchIssuer(token) {\n  const payload = decodeToken(token).payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  const publicKeys = payload.public_keys;\n  const addressFromIssuer = getAddressFromDID(payload.iss);\n\n  if (publicKeys.length === 1) {\n    const addressFromPublicKeys = publicKeyToAddress(publicKeys[0]);\n\n    if (addressFromPublicKeys === addressFromIssuer) {\n      return true;\n    }\n  } else {\n    throw new Error('Multiple public keys are not supported');\n  }\n\n  return false;\n}\nexport async function doPublicKeysMatchUsername(token, nameLookupURL) {\n  try {\n    const payload = decodeToken(token).payload;\n\n    if (typeof payload === 'string') {\n      throw new Error('Unexpected token payload type of string');\n    }\n\n    if (!payload.username) {\n      return true;\n    }\n\n    if (payload.username === null) {\n      return true;\n    }\n\n    if (nameLookupURL === null) {\n      return false;\n    }\n\n    const username = payload.username;\n    const url = `${nameLookupURL.replace(/\\/$/, '')}/${username}`;\n    const response = await fetchPrivate(url);\n    const responseText = await response.text();\n    const responseJSON = JSON.parse(responseText);\n\n    if (responseJSON.hasOwnProperty('address')) {\n      const nameOwningAddress = responseJSON.address;\n      let nameOwningAddressBtc = nameOwningAddress;\n\n      try {\n        nameOwningAddressBtc = c32ToB58(nameOwningAddress, 0);\n      } catch (_a) {}\n\n      const addressFromIssuer = getAddressFromDID(payload.iss);\n\n      if (nameOwningAddressBtc === addressFromIssuer) {\n        return true;\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  } catch (error) {\n    console.log(error);\n    console.log('Error checking `doPublicKeysMatchUsername`');\n    return false;\n  }\n}\nexport function isIssuanceDateValid(token) {\n  const payload = decodeToken(token).payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  if (payload.iat) {\n    if (typeof payload.iat !== 'number') {\n      return false;\n    }\n\n    const issuedAt = new Date(payload.iat * 1000);\n\n    if (new Date().getTime() < issuedAt.getTime()) {\n      return false;\n    } else {\n      return true;\n    }\n  } else {\n    return true;\n  }\n}\nexport function isExpirationDateValid(token) {\n  const payload = decodeToken(token).payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  if (payload.exp) {\n    if (typeof payload.exp !== 'number') {\n      return false;\n    }\n\n    const expiresAt = new Date(payload.exp * 1000);\n\n    if (new Date().getTime() > expiresAt.getTime()) {\n      return false;\n    } else {\n      return true;\n    }\n  } else {\n    return true;\n  }\n}\nexport function isManifestUriValid(token) {\n  const payload = decodeToken(token).payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  return isSameOriginAbsoluteUrl(payload.domain_name, payload.manifest_uri);\n}\nexport function isRedirectUriValid(token) {\n  const payload = decodeToken(token).payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  return isSameOriginAbsoluteUrl(payload.domain_name, payload.redirect_uri);\n}\nexport async function verifyAuthRequest(token) {\n  if (decodeToken(token).header.alg === 'none') {\n    throw new Error('Token must be signed in order to be verified');\n  }\n\n  const values = await Promise.all([isExpirationDateValid(token), isIssuanceDateValid(token), doSignaturesMatchPublicKeys(token), doPublicKeysMatchIssuer(token), isManifestUriValid(token), isRedirectUriValid(token)]);\n  return values.every(val => val);\n}\nexport async function verifyAuthRequestAndLoadManifest(token) {\n  const valid = await verifyAuthRequest(token);\n\n  if (!valid) {\n    throw new Error('Token is an invalid auth request');\n  }\n\n  return fetchAppManifest(token);\n}\nexport async function verifyAuthResponse(token, nameLookupURL, fallbackLookupURLs) {\n  const values = await Promise.all([isExpirationDateValid(token), isIssuanceDateValid(token), doSignaturesMatchPublicKeys(token), doPublicKeysMatchIssuer(token)]);\n  const usernameMatchings = await Promise.all([nameLookupURL].concat(fallbackLookupURLs || []).map(url => doPublicKeysMatchUsername(token, url)));\n  const someUsernameMatches = usernameMatchings.includes(true);\n  return !!someUsernameMatches && values.every(val => val);\n}","map":{"version":3,"sources":["../../src/verification.ts"],"names":[],"mappings":"AAAA,SAAS,WAAT,EAAsB,aAAtB,QAA2C,YAA3C;AACA,SAAS,iBAAT,QAAkC,QAAlC;AACA,SAAS,kBAAT,QAAmC,oBAAnC;AACA,SAAS,YAAT,EAAuB,uBAAvB,QAAsD,gBAAtD;AACA,SAAS,gBAAT,QAAiC,YAAjC;AACA,SAAS,QAAT,QAAyB,UAAzB;AAYA,OAAM,SAAU,2BAAV,CAAsC,KAAtC,EAAmD;AACvD,QAAM,OAAO,GAAG,WAAW,CAAC,KAAD,CAAX,CAAmB,OAAnC;;AACA,MAAI,OAAO,OAAP,KAAmB,QAAvB,EAAiC;AAC/B,UAAM,IAAI,KAAJ,CAAU,yCAAV,CAAN;AACD;;AACD,QAAM,UAAU,GAAG,OAAO,CAAC,WAA3B;;AACA,MAAI,UAAU,CAAC,MAAX,KAAsB,CAA1B,EAA6B;AAC3B,UAAM,SAAS,GAAG,UAAU,CAAC,CAAD,CAA5B;;AACA,QAAI;AACF,YAAM,aAAa,GAAG,IAAI,aAAJ,CAAkB,QAAlB,EAA4B,SAA5B,CAAtB;AACA,aAAO,aAAa,CAAC,MAAd,CAAqB,KAArB,CAAP;AACD,KAHD,CAGE,OAAO,CAAP,EAAU;AACV,aAAO,KAAP;AACD;AACF,GARD,MAQO;AACL,UAAM,IAAI,KAAJ,CAAU,wCAAV,CAAN;AACD;AACF;AAaD,OAAM,SAAU,uBAAV,CAAkC,KAAlC,EAA+C;AACnD,QAAM,OAAO,GAAG,WAAW,CAAC,KAAD,CAAX,CAAmB,OAAnC;;AACA,MAAI,OAAO,OAAP,KAAmB,QAAvB,EAAiC;AAC/B,UAAM,IAAI,KAAJ,CAAU,yCAAV,CAAN;AACD;;AACD,QAAM,UAAU,GAAG,OAAO,CAAC,WAA3B;AACA,QAAM,iBAAiB,GAAG,iBAAiB,CAAC,OAAO,CAAC,GAAT,CAA3C;;AAEA,MAAI,UAAU,CAAC,MAAX,KAAsB,CAA1B,EAA6B;AAC3B,UAAM,qBAAqB,GAAG,kBAAkB,CAAC,UAAU,CAAC,CAAD,CAAX,CAAhD;;AACA,QAAI,qBAAqB,KAAK,iBAA9B,EAAiD;AAC/C,aAAO,IAAP;AACD;AACF,GALD,MAKO;AACL,UAAM,IAAI,KAAJ,CAAU,wCAAV,CAAN;AACD;;AAED,SAAO,KAAP;AACD;AAgBD,OAAO,eAAe,yBAAf,CACL,KADK,EAEL,aAFK,EAEgB;AAErB,MAAI;AACF,UAAM,OAAO,GAAG,WAAW,CAAC,KAAD,CAAX,CAAmB,OAAnC;;AACA,QAAI,OAAO,OAAP,KAAmB,QAAvB,EAAiC;AAC/B,YAAM,IAAI,KAAJ,CAAU,yCAAV,CAAN;AACD;;AACD,QAAI,CAAC,OAAO,CAAC,QAAb,EAAuB;AACrB,aAAO,IAAP;AACD;;AAED,QAAI,OAAO,CAAC,QAAR,KAAqB,IAAzB,EAA+B;AAC7B,aAAO,IAAP;AACD;;AAED,QAAI,aAAa,KAAK,IAAtB,EAA4B;AAC1B,aAAO,KAAP;AACD;;AAED,UAAM,QAAQ,GAAG,OAAO,CAAC,QAAzB;AACA,UAAM,GAAG,GAAG,GAAG,aAAa,CAAC,OAAd,CAAsB,KAAtB,EAA6B,EAA7B,CAAgC,IAAI,QAAQ,EAA3D;AACA,UAAM,QAAQ,GAAG,MAAM,YAAY,CAAC,GAAD,CAAnC;AACA,UAAM,YAAY,GAAG,MAAM,QAAQ,CAAC,IAAT,EAA3B;AACA,UAAM,YAAY,GAAG,IAAI,CAAC,KAAL,CAAW,YAAX,CAArB;;AACA,QAAI,YAAY,CAAC,cAAb,CAA4B,SAA5B,CAAJ,EAA4C;AAC1C,YAAM,iBAAiB,GAAG,YAAY,CAAC,OAAvC;AACA,UAAI,oBAAoB,GAAG,iBAA3B;;AACA,UAAI;AAGF,QAAA,oBAAoB,GAAG,QAAQ,CAAC,iBAAD,EAAoB,CAApB,CAA/B;AACD,OAJD,CAIE,OAAA,EAAA,EAAM,CAAE;;AACV,YAAM,iBAAiB,GAAG,iBAAiB,CAAC,OAAO,CAAC,GAAT,CAA3C;;AACA,UAAI,oBAAoB,KAAK,iBAA7B,EAAgD;AAC9C,eAAO,IAAP;AACD,OAFD,MAEO;AACL,eAAO,KAAP;AACD;AACF,KAdD,MAcO;AACL,aAAO,KAAP;AACD;AACF,GAvCD,CAuCE,OAAO,KAAP,EAAc;AACd,IAAA,OAAO,CAAC,GAAR,CAAY,KAAZ;AACA,IAAA,OAAO,CAAC,GAAR,CAAY,4CAAZ;AACA,WAAO,KAAP;AACD;AACF;AAYD,OAAM,SAAU,mBAAV,CAA8B,KAA9B,EAA2C;AAC/C,QAAM,OAAO,GAAG,WAAW,CAAC,KAAD,CAAX,CAAmB,OAAnC;;AACA,MAAI,OAAO,OAAP,KAAmB,QAAvB,EAAiC;AAC/B,UAAM,IAAI,KAAJ,CAAU,yCAAV,CAAN;AACD;;AACD,MAAI,OAAO,CAAC,GAAZ,EAAiB;AACf,QAAI,OAAO,OAAO,CAAC,GAAf,KAAuB,QAA3B,EAAqC;AACnC,aAAO,KAAP;AACD;;AACD,UAAM,QAAQ,GAAG,IAAI,IAAJ,CAAS,OAAO,CAAC,GAAR,GAAc,IAAvB,CAAjB;;AACA,QAAI,IAAI,IAAJ,GAAW,OAAX,KAAuB,QAAQ,CAAC,OAAT,EAA3B,EAA+C;AAC7C,aAAO,KAAP;AACD,KAFD,MAEO;AACL,aAAO,IAAP;AACD;AACF,GAVD,MAUO;AACL,WAAO,IAAP;AACD;AACF;AAWD,OAAM,SAAU,qBAAV,CAAgC,KAAhC,EAA6C;AACjD,QAAM,OAAO,GAAG,WAAW,CAAC,KAAD,CAAX,CAAmB,OAAnC;;AACA,MAAI,OAAO,OAAP,KAAmB,QAAvB,EAAiC;AAC/B,UAAM,IAAI,KAAJ,CAAU,yCAAV,CAAN;AACD;;AACD,MAAI,OAAO,CAAC,GAAZ,EAAiB;AACf,QAAI,OAAO,OAAO,CAAC,GAAf,KAAuB,QAA3B,EAAqC;AACnC,aAAO,KAAP;AACD;;AACD,UAAM,SAAS,GAAG,IAAI,IAAJ,CAAS,OAAO,CAAC,GAAR,GAAc,IAAvB,CAAlB;;AACA,QAAI,IAAI,IAAJ,GAAW,OAAX,KAAuB,SAAS,CAAC,OAAV,EAA3B,EAAgD;AAC9C,aAAO,KAAP;AACD,KAFD,MAEO;AACL,aAAO,IAAP;AACD;AACF,GAVD,MAUO;AACL,WAAO,IAAP;AACD;AACF;AASD,OAAM,SAAU,kBAAV,CAA6B,KAA7B,EAA0C;AAC9C,QAAM,OAAO,GAAG,WAAW,CAAC,KAAD,CAAX,CAAmB,OAAnC;;AACA,MAAI,OAAO,OAAP,KAAmB,QAAvB,EAAiC;AAC/B,UAAM,IAAI,KAAJ,CAAU,yCAAV,CAAN;AACD;;AACD,SAAO,uBAAuB,CAAC,OAAO,CAAC,WAAT,EAAgC,OAAO,CAAC,YAAxC,CAA9B;AACD;AASD,OAAM,SAAU,kBAAV,CAA6B,KAA7B,EAA0C;AAC9C,QAAM,OAAO,GAAG,WAAW,CAAC,KAAD,CAAX,CAAmB,OAAnC;;AACA,MAAI,OAAO,OAAP,KAAmB,QAAvB,EAAiC;AAC/B,UAAM,IAAI,KAAJ,CAAU,yCAAV,CAAN;AACD;;AACD,SAAO,uBAAuB,CAAC,OAAO,CAAC,WAAT,EAAgC,OAAO,CAAC,YAAxC,CAA9B;AACD;AAiBD,OAAO,eAAe,iBAAf,CAAiC,KAAjC,EAA8C;AACnD,MAAI,WAAW,CAAC,KAAD,CAAX,CAAmB,MAAnB,CAA0B,GAA1B,KAAkC,MAAtC,EAA8C;AAC5C,UAAM,IAAI,KAAJ,CAAU,8CAAV,CAAN;AACD;;AACD,QAAM,MAAM,GAAG,MAAM,OAAO,CAAC,GAAR,CAAY,CAC/B,qBAAqB,CAAC,KAAD,CADU,EAE/B,mBAAmB,CAAC,KAAD,CAFY,EAG/B,2BAA2B,CAAC,KAAD,CAHI,EAI/B,uBAAuB,CAAC,KAAD,CAJQ,EAK/B,kBAAkB,CAAC,KAAD,CALa,EAM/B,kBAAkB,CAAC,KAAD,CANa,CAAZ,CAArB;AAQA,SAAO,MAAM,CAAC,KAAP,CAAa,GAAG,IAAI,GAApB,CAAP;AACD;AAWD,OAAO,eAAe,gCAAf,CAAgD,KAAhD,EAA6D;AAClE,QAAM,KAAK,GAAG,MAAM,iBAAiB,CAAC,KAAD,CAArC;;AACA,MAAI,CAAC,KAAL,EAAY;AACV,UAAM,IAAI,KAAJ,CAAU,kCAAV,CAAN;AACD;;AACD,SAAO,gBAAgB,CAAC,KAAD,CAAvB;AACD;AAYD,OAAO,eAAe,kBAAf,CACL,KADK,EAEL,aAFK,EAGL,kBAHK,EAGwB;AAE7B,QAAM,MAAM,GAAG,MAAM,OAAO,CAAC,GAAR,CAAY,CAC/B,qBAAqB,CAAC,KAAD,CADU,EAE/B,mBAAmB,CAAC,KAAD,CAFY,EAG/B,2BAA2B,CAAC,KAAD,CAHI,EAI/B,uBAAuB,CAAC,KAAD,CAJQ,CAAZ,CAArB;AAMA,QAAM,iBAAiB,GAAG,MAAM,OAAO,CAAC,GAAR,CAC9B,CAAC,aAAD,EACG,MADH,CACU,kBAAkB,IAAI,EADhC,EAEG,GAFH,CAEO,GAAG,IAAI,yBAAyB,CAAC,KAAD,EAAQ,GAAR,CAFvC,CAD8B,CAAhC;AAKA,QAAM,mBAAmB,GAAG,iBAAiB,CAAC,QAAlB,CAA2B,IAA3B,CAA5B;AACA,SAAO,CAAC,CAAC,mBAAF,IAAyB,MAAM,CAAC,KAAP,CAAa,GAAG,IAAI,GAApB,CAAhC;AACD","sourceRoot":"","sourcesContent":["import { decodeToken, TokenVerifier } from 'jsontokens';\nimport { getAddressFromDID } from './dids';\nimport { publicKeyToAddress } from '@stacks/encryption';\nimport { fetchPrivate, isSameOriginAbsoluteUrl } from '@stacks/common';\nimport { fetchAppManifest } from './provider';\nimport { c32ToB58 } from 'c32check';\nexport function doSignaturesMatchPublicKeys(token) {\n    const payload = decodeToken(token).payload;\n    if (typeof payload === 'string') {\n        throw new Error('Unexpected token payload type of string');\n    }\n    const publicKeys = payload.public_keys;\n    if (publicKeys.length === 1) {\n        const publicKey = publicKeys[0];\n        try {\n            const tokenVerifier = new TokenVerifier('ES256k', publicKey);\n            return tokenVerifier.verify(token);\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    else {\n        throw new Error('Multiple public keys are not supported');\n    }\n}\nexport function doPublicKeysMatchIssuer(token) {\n    const payload = decodeToken(token).payload;\n    if (typeof payload === 'string') {\n        throw new Error('Unexpected token payload type of string');\n    }\n    const publicKeys = payload.public_keys;\n    const addressFromIssuer = getAddressFromDID(payload.iss);\n    if (publicKeys.length === 1) {\n        const addressFromPublicKeys = publicKeyToAddress(publicKeys[0]);\n        if (addressFromPublicKeys === addressFromIssuer) {\n            return true;\n        }\n    }\n    else {\n        throw new Error('Multiple public keys are not supported');\n    }\n    return false;\n}\nexport async function doPublicKeysMatchUsername(token, nameLookupURL) {\n    try {\n        const payload = decodeToken(token).payload;\n        if (typeof payload === 'string') {\n            throw new Error('Unexpected token payload type of string');\n        }\n        if (!payload.username) {\n            return true;\n        }\n        if (payload.username === null) {\n            return true;\n        }\n        if (nameLookupURL === null) {\n            return false;\n        }\n        const username = payload.username;\n        const url = `${nameLookupURL.replace(/\\/$/, '')}/${username}`;\n        const response = await fetchPrivate(url);\n        const responseText = await response.text();\n        const responseJSON = JSON.parse(responseText);\n        if (responseJSON.hasOwnProperty('address')) {\n            const nameOwningAddress = responseJSON.address;\n            let nameOwningAddressBtc = nameOwningAddress;\n            try {\n                nameOwningAddressBtc = c32ToB58(nameOwningAddress, 0);\n            }\n            catch (_a) { }\n            const addressFromIssuer = getAddressFromDID(payload.iss);\n            if (nameOwningAddressBtc === addressFromIssuer) {\n                return true;\n            }\n            else {\n                return false;\n            }\n        }\n        else {\n            return false;\n        }\n    }\n    catch (error) {\n        console.log(error);\n        console.log('Error checking `doPublicKeysMatchUsername`');\n        return false;\n    }\n}\nexport function isIssuanceDateValid(token) {\n    const payload = decodeToken(token).payload;\n    if (typeof payload === 'string') {\n        throw new Error('Unexpected token payload type of string');\n    }\n    if (payload.iat) {\n        if (typeof payload.iat !== 'number') {\n            return false;\n        }\n        const issuedAt = new Date(payload.iat * 1000);\n        if (new Date().getTime() < issuedAt.getTime()) {\n            return false;\n        }\n        else {\n            return true;\n        }\n    }\n    else {\n        return true;\n    }\n}\nexport function isExpirationDateValid(token) {\n    const payload = decodeToken(token).payload;\n    if (typeof payload === 'string') {\n        throw new Error('Unexpected token payload type of string');\n    }\n    if (payload.exp) {\n        if (typeof payload.exp !== 'number') {\n            return false;\n        }\n        const expiresAt = new Date(payload.exp * 1000);\n        if (new Date().getTime() > expiresAt.getTime()) {\n            return false;\n        }\n        else {\n            return true;\n        }\n    }\n    else {\n        return true;\n    }\n}\nexport function isManifestUriValid(token) {\n    const payload = decodeToken(token).payload;\n    if (typeof payload === 'string') {\n        throw new Error('Unexpected token payload type of string');\n    }\n    return isSameOriginAbsoluteUrl(payload.domain_name, payload.manifest_uri);\n}\nexport function isRedirectUriValid(token) {\n    const payload = decodeToken(token).payload;\n    if (typeof payload === 'string') {\n        throw new Error('Unexpected token payload type of string');\n    }\n    return isSameOriginAbsoluteUrl(payload.domain_name, payload.redirect_uri);\n}\nexport async function verifyAuthRequest(token) {\n    if (decodeToken(token).header.alg === 'none') {\n        throw new Error('Token must be signed in order to be verified');\n    }\n    const values = await Promise.all([\n        isExpirationDateValid(token),\n        isIssuanceDateValid(token),\n        doSignaturesMatchPublicKeys(token),\n        doPublicKeysMatchIssuer(token),\n        isManifestUriValid(token),\n        isRedirectUriValid(token),\n    ]);\n    return values.every(val => val);\n}\nexport async function verifyAuthRequestAndLoadManifest(token) {\n    const valid = await verifyAuthRequest(token);\n    if (!valid) {\n        throw new Error('Token is an invalid auth request');\n    }\n    return fetchAppManifest(token);\n}\nexport async function verifyAuthResponse(token, nameLookupURL, fallbackLookupURLs) {\n    const values = await Promise.all([\n        isExpirationDateValid(token),\n        isIssuanceDateValid(token),\n        doSignaturesMatchPublicKeys(token),\n        doPublicKeysMatchIssuer(token),\n    ]);\n    const usernameMatchings = await Promise.all([nameLookupURL]\n        .concat(fallbackLookupURLs || [])\n        .map(url => doPublicKeysMatchUsername(token, url)));\n    const someUsernameMatches = usernameMatchings.includes(true);\n    return !!someUsernameMatches && values.every(val => val);\n}\n//# sourceMappingURL=verification.js.map"]},"metadata":{},"sourceType":"module"}