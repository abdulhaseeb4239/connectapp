{"ast":null,"code":"import { Buffer } from '@stacks/common';\nimport { getCryptoLib } from './cryptoUtils';\nexport class NodeCryptoPbkdf2 {\n  constructor(nodePbkdf2) {\n    this.nodePbkdf2 = nodePbkdf2;\n  }\n\n  async derive(password, salt, iterations, keyLength, digest) {\n    if (digest !== 'sha512' && digest !== 'sha256') {\n      throw new Error(`Unsupported digest \"${digest}\" for Pbkdf2`);\n    }\n\n    return new Promise((resolve, reject) => {\n      this.nodePbkdf2(password, salt, iterations, keyLength, digest, (error, result) => {\n        if (error) {\n          reject(error);\n        }\n\n        resolve(result);\n      });\n    });\n  }\n\n}\nexport class WebCryptoPbkdf2 {\n  constructor(subtleCrypto) {\n    this.subtleCrypto = subtleCrypto;\n  }\n\n  async derive(password, salt, iterations, keyLength, digest) {\n    let algo;\n\n    if (digest === 'sha256') {\n      algo = 'SHA-256';\n    } else if (digest === 'sha512') {\n      algo = 'SHA-512';\n    } else {\n      throw new Error(`Unsupported Pbkdf2 digest algorithm \"${digest}\"`);\n    }\n\n    let result;\n    const passwordBytes = Buffer.from(password, 'utf8');\n\n    try {\n      const key = await this.subtleCrypto.importKey('raw', passwordBytes, 'PBKDF2', false, ['deriveBits']);\n      result = await this.subtleCrypto.deriveBits({\n        name: 'PBKDF2',\n        salt,\n        iterations,\n        hash: {\n          name: algo\n        }\n      }, key, keyLength * 8);\n    } catch (error) {\n      const partialWebCrypto = new WebCryptoPartialPbkdf2(this.subtleCrypto);\n      return partialWebCrypto.derive(password, salt, iterations, keyLength, digest);\n    }\n\n    return Buffer.from(result);\n  }\n\n}\nexport class WebCryptoPartialPbkdf2 {\n  constructor(subtleCrypto) {\n    this.subtleCrypto = subtleCrypto;\n  }\n\n  async derive(password, salt, iterations, keyLength, digest) {\n    if (digest !== 'sha512' && digest !== 'sha256') {\n      throw new Error(`Unsupported digest \"${digest}\" for Pbkdf2`);\n    }\n\n    const key = Buffer.from(password, 'utf8');\n    const algo = digest === 'sha512' ? 'SHA-512' : 'SHA-256';\n    const algoOpts = {\n      name: 'HMAC',\n      hash: algo\n    };\n\n    const hmacDigest = (key, data) => this.subtleCrypto.importKey('raw', key, algoOpts, true, ['sign']).then(cryptoKey => this.subtleCrypto.sign(algoOpts, cryptoKey, data)).then(result => new Uint8Array(result));\n\n    const DK = new Uint8Array(keyLength);\n    const saltLength = salt.length;\n    const block1 = new Uint8Array(saltLength + 4);\n    block1.set(salt);\n    let destPos = 0;\n    const hLen = digest === 'sha512' ? 64 : 32;\n    const l = Math.ceil(keyLength / hLen);\n\n    function writeUInt32BE(data, value, offset) {\n      value = +value;\n      offset >>>= 0;\n      data[offset] = value >>> 24;\n      data[offset + 1] = value >>> 16;\n      data[offset + 2] = value >>> 8;\n      data[offset + 3] = value & 0xff;\n      return offset + 4;\n    }\n\n    for (let i = 1; i <= l; i++) {\n      writeUInt32BE(block1, i, saltLength);\n      const T = await hmacDigest(key, block1);\n      let U = T;\n\n      for (let j = 1; j < iterations; j++) {\n        U = await hmacDigest(key, U);\n\n        for (let k = 0; k < hLen; k++) {\n          T[k] ^= U[k];\n        }\n      }\n\n      DK.set(T.subarray(0, DK.byteLength - destPos), destPos);\n      destPos += hLen;\n    }\n\n    return Buffer.from(DK.buffer);\n  }\n\n}\nexport async function createPbkdf2() {\n  const cryptoLib = await getCryptoLib();\n\n  if (cryptoLib.name === 'subtleCrypto') {\n    return new WebCryptoPbkdf2(cryptoLib.lib);\n  } else {\n    return new NodeCryptoPbkdf2(cryptoLib.lib.pbkdf2);\n  }\n}","map":{"version":3,"sources":["../../src/pbkdf2.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Buffer } from '@stacks/common';\nimport { getCryptoLib } from './cryptoUtils';\nexport class NodeCryptoPbkdf2 {\n    constructor(nodePbkdf2) {\n        this.nodePbkdf2 = nodePbkdf2;\n    }\n    async derive(password, salt, iterations, keyLength, digest) {\n        if (digest !== 'sha512' && digest !== 'sha256') {\n            throw new Error(`Unsupported digest \"${digest}\" for Pbkdf2`);\n        }\n        return new Promise((resolve, reject) => {\n            this.nodePbkdf2(password, salt, iterations, keyLength, digest, (error, result) => {\n                if (error) {\n                    reject(error);\n                }\n                resolve(result);\n            });\n        });\n    }\n}\nexport class WebCryptoPbkdf2 {\n    constructor(subtleCrypto) {\n        this.subtleCrypto = subtleCrypto;\n    }\n    async derive(password, salt, iterations, keyLength, digest) {\n        let algo;\n        if (digest === 'sha256') {\n            algo = 'SHA-256';\n        }\n        else if (digest === 'sha512') {\n            algo = 'SHA-512';\n        }\n        else {\n            throw new Error(`Unsupported Pbkdf2 digest algorithm \"${digest}\"`);\n        }\n        let result;\n        const passwordBytes = Buffer.from(password, 'utf8');\n        try {\n            const key = await this.subtleCrypto.importKey('raw', passwordBytes, 'PBKDF2', false, [\n                'deriveBits',\n            ]);\n            result = await this.subtleCrypto.deriveBits({\n                name: 'PBKDF2',\n                salt,\n                iterations,\n                hash: { name: algo },\n            }, key, keyLength * 8);\n        }\n        catch (error) {\n            const partialWebCrypto = new WebCryptoPartialPbkdf2(this.subtleCrypto);\n            return partialWebCrypto.derive(password, salt, iterations, keyLength, digest);\n        }\n        return Buffer.from(result);\n    }\n}\nexport class WebCryptoPartialPbkdf2 {\n    constructor(subtleCrypto) {\n        this.subtleCrypto = subtleCrypto;\n    }\n    async derive(password, salt, iterations, keyLength, digest) {\n        if (digest !== 'sha512' && digest !== 'sha256') {\n            throw new Error(`Unsupported digest \"${digest}\" for Pbkdf2`);\n        }\n        const key = Buffer.from(password, 'utf8');\n        const algo = digest === 'sha512' ? 'SHA-512' : 'SHA-256';\n        const algoOpts = { name: 'HMAC', hash: algo };\n        const hmacDigest = (key, data) => this.subtleCrypto\n            .importKey('raw', key, algoOpts, true, ['sign'])\n            .then(cryptoKey => this.subtleCrypto.sign(algoOpts, cryptoKey, data))\n            .then(result => new Uint8Array(result));\n        const DK = new Uint8Array(keyLength);\n        const saltLength = salt.length;\n        const block1 = new Uint8Array(saltLength + 4);\n        block1.set(salt);\n        let destPos = 0;\n        const hLen = digest === 'sha512' ? 64 : 32;\n        const l = Math.ceil(keyLength / hLen);\n        function writeUInt32BE(data, value, offset) {\n            value = +value;\n            offset >>>= 0;\n            data[offset] = value >>> 24;\n            data[offset + 1] = value >>> 16;\n            data[offset + 2] = value >>> 8;\n            data[offset + 3] = value & 0xff;\n            return offset + 4;\n        }\n        for (let i = 1; i <= l; i++) {\n            writeUInt32BE(block1, i, saltLength);\n            const T = await hmacDigest(key, block1);\n            let U = T;\n            for (let j = 1; j < iterations; j++) {\n                U = await hmacDigest(key, U);\n                for (let k = 0; k < hLen; k++) {\n                    T[k] ^= U[k];\n                }\n            }\n            DK.set(T.subarray(0, DK.byteLength - destPos), destPos);\n            destPos += hLen;\n        }\n        return Buffer.from(DK.buffer);\n    }\n}\nexport async function createPbkdf2() {\n    const cryptoLib = await getCryptoLib();\n    if (cryptoLib.name === 'subtleCrypto') {\n        return new WebCryptoPbkdf2(cryptoLib.lib);\n    }\n    else {\n        return new NodeCryptoPbkdf2(cryptoLib.lib.pbkdf2);\n    }\n}\n//# sourceMappingURL=pbkdf2.js.map"]},"metadata":{},"sourceType":"module"}