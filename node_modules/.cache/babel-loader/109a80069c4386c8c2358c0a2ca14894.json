{"ast":null,"code":"import { Buffer, intToBigInt, intToBytes } from '@stacks/common';\nimport { AddressHashMode, AuthType, PubKeyEncoding, RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, StacksMessageType } from './constants';\nimport { BufferArray, cloneDeep, leftPadHex, txidFromData } from './utils';\nimport { addressFromPublicKeys, createEmptyAddress, createLPList, deserializeLPList, serializeLPList } from './types';\nimport { compressPublicKey, createStacksPublicKey, deserializePublicKey, getPublicKey, isCompressed, publicKeyFromSignature, serializePublicKey, signWithKey } from './keys';\nimport { DeserializationError, SerializationError, SigningError } from './errors';\n\nclass Deserializable {\n  static deserialize(bufferReader) {\n    const message = new this();\n    message.deserialize(bufferReader);\n    return message;\n  }\n\n}\n\nexport function createMessageSignature(signature) {\n  const length = Buffer.from(signature, 'hex').byteLength;\n\n  if (length != RECOVERABLE_ECDSA_SIG_LENGTH_BYTES) {\n    throw Error('Invalid signature');\n  }\n\n  return {\n    type: StacksMessageType.MessageSignature,\n    data: signature\n  };\n}\nexport function emptyMessageSignature() {\n  return {\n    type: StacksMessageType.MessageSignature,\n    data: Buffer.alloc(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, 0x00).toString('hex')\n  };\n}\nexport function serializeMessageSignature(messageSignature) {\n  const bufferArray = new BufferArray();\n  bufferArray.appendHexString(messageSignature.data);\n  return bufferArray.concatBuffer();\n}\nexport function deserializeMessageSignature(bufferReader) {\n  return createMessageSignature(bufferReader.readBuffer(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES).toString('hex'));\n}\nvar AuthFieldType;\n\n(function (AuthFieldType) {\n  AuthFieldType[AuthFieldType[\"PublicKeyCompressed\"] = 0] = \"PublicKeyCompressed\";\n  AuthFieldType[AuthFieldType[\"PublicKeyUncompressed\"] = 1] = \"PublicKeyUncompressed\";\n  AuthFieldType[AuthFieldType[\"SignatureCompressed\"] = 2] = \"SignatureCompressed\";\n  AuthFieldType[AuthFieldType[\"SignatureUncompressed\"] = 3] = \"SignatureUncompressed\";\n})(AuthFieldType || (AuthFieldType = {}));\n\nexport function createTransactionAuthField(pubKeyEncoding, contents) {\n  return {\n    pubKeyEncoding,\n    type: StacksMessageType.TransactionAuthField,\n    contents\n  };\n}\nexport function serializeTransactionAuthField(field) {\n  const bufferArray = new BufferArray();\n\n  switch (field.contents.type) {\n    case StacksMessageType.PublicKey:\n      if (field.pubKeyEncoding == PubKeyEncoding.Compressed) {\n        bufferArray.appendByte(AuthFieldType.PublicKeyCompressed);\n        bufferArray.push(serializePublicKey(field.contents));\n      } else {\n        bufferArray.appendByte(AuthFieldType.PublicKeyUncompressed);\n        bufferArray.push(serializePublicKey(compressPublicKey(field.contents.data)));\n      }\n\n      break;\n\n    case StacksMessageType.MessageSignature:\n      if (field.pubKeyEncoding == PubKeyEncoding.Compressed) {\n        bufferArray.appendByte(AuthFieldType.SignatureCompressed);\n      } else {\n        bufferArray.appendByte(AuthFieldType.SignatureUncompressed);\n      }\n\n      bufferArray.push(serializeMessageSignature(field.contents));\n      break;\n  }\n\n  return bufferArray.concatBuffer();\n}\nexport function deserializeTransactionAuthField(bufferReader) {\n  const authFieldType = bufferReader.readUInt8Enum(AuthFieldType, n => {\n    throw new DeserializationError(`Could not read ${n} as AuthFieldType`);\n  });\n\n  switch (authFieldType) {\n    case AuthFieldType.PublicKeyCompressed:\n      return createTransactionAuthField(PubKeyEncoding.Compressed, deserializePublicKey(bufferReader));\n\n    case AuthFieldType.PublicKeyUncompressed:\n      return createTransactionAuthField(PubKeyEncoding.Uncompressed, deserializePublicKey(bufferReader));\n\n    case AuthFieldType.SignatureCompressed:\n      return createTransactionAuthField(PubKeyEncoding.Compressed, deserializeMessageSignature(bufferReader));\n\n    case AuthFieldType.SignatureUncompressed:\n      return createTransactionAuthField(PubKeyEncoding.Uncompressed, deserializeMessageSignature(bufferReader));\n\n    default:\n      throw new Error(`Unknown auth field type: ${JSON.stringify(authFieldType)}`);\n  }\n}\nexport function createSingleSigSpendingCondition(hashMode, pubKey, nonce, fee) {\n  const signer = addressFromPublicKeys(0, hashMode, 1, [createStacksPublicKey(pubKey)]).hash160;\n  const keyEncoding = isCompressed(createStacksPublicKey(pubKey)) ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed;\n  return {\n    hashMode,\n    signer,\n    nonce: intToBigInt(nonce, false),\n    fee: intToBigInt(fee, false),\n    keyEncoding,\n    signature: emptyMessageSignature()\n  };\n}\nexport function createMultiSigSpendingCondition(hashMode, numSigs, pubKeys, nonce, fee) {\n  const stacksPublicKeys = pubKeys.map(createStacksPublicKey);\n  const signer = addressFromPublicKeys(0, hashMode, numSigs, stacksPublicKeys).hash160;\n  return {\n    hashMode,\n    signer,\n    nonce: intToBigInt(nonce, false),\n    fee: intToBigInt(fee, false),\n    fields: [],\n    signaturesRequired: numSigs\n  };\n}\nexport function isSingleSig(condition) {\n  return 'signature' in condition;\n}\n\nfunction clearCondition(condition) {\n  const cloned = cloneDeep(condition);\n  cloned.nonce = 0;\n  cloned.fee = 0;\n\n  if (isSingleSig(cloned)) {\n    cloned.signature = emptyMessageSignature();\n  } else {\n    cloned.fields = [];\n  }\n\n  return Object.assign(Object.assign({}, cloned), {\n    nonce: BigInt(0),\n    fee: BigInt(0)\n  });\n}\n\nexport function serializeSingleSigSpendingCondition(condition) {\n  const bufferArray = new BufferArray();\n  bufferArray.appendByte(condition.hashMode);\n  bufferArray.appendHexString(condition.signer);\n  bufferArray.push(intToBytes(condition.nonce, false, 8));\n  bufferArray.push(intToBytes(condition.fee, false, 8));\n  bufferArray.appendByte(condition.keyEncoding);\n  bufferArray.push(serializeMessageSignature(condition.signature));\n  return bufferArray.concatBuffer();\n}\nexport function serializeMultiSigSpendingCondition(condition) {\n  const bufferArray = new BufferArray();\n  bufferArray.appendByte(condition.hashMode);\n  bufferArray.appendHexString(condition.signer);\n  bufferArray.push(intToBytes(condition.nonce, false, 8));\n  bufferArray.push(intToBytes(condition.fee, false, 8));\n  const fields = createLPList(condition.fields);\n  bufferArray.push(serializeLPList(fields));\n  const numSigs = Buffer.alloc(2);\n  numSigs.writeUInt16BE(condition.signaturesRequired, 0);\n  bufferArray.push(numSigs);\n  return bufferArray.concatBuffer();\n}\nexport function deserializeSingleSigSpendingCondition(hashMode, bufferReader) {\n  const signer = bufferReader.readBuffer(20).toString('hex');\n  const nonce = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n  const fee = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n  const keyEncoding = bufferReader.readUInt8Enum(PubKeyEncoding, n => {\n    throw new DeserializationError(`Could not parse ${n} as PubKeyEncoding`);\n  });\n  const signature = deserializeMessageSignature(bufferReader);\n  return {\n    hashMode,\n    signer,\n    nonce,\n    fee,\n    keyEncoding,\n    signature\n  };\n}\nexport function deserializeMultiSigSpendingCondition(hashMode, bufferReader) {\n  const signer = bufferReader.readBuffer(20).toString('hex');\n  const nonce = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n  const fee = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n  const fields = deserializeLPList(bufferReader, StacksMessageType.TransactionAuthField).values;\n  const signaturesRequired = bufferReader.readUInt16BE();\n  return {\n    hashMode,\n    signer,\n    nonce,\n    fee,\n    fields,\n    signaturesRequired\n  };\n}\nexport function serializeSpendingCondition(condition) {\n  if (isSingleSig(condition)) {\n    return serializeSingleSigSpendingCondition(condition);\n  } else {\n    return serializeMultiSigSpendingCondition(condition);\n  }\n}\nexport function deserializeSpendingCondition(bufferReader) {\n  const hashMode = bufferReader.readUInt8Enum(AddressHashMode, n => {\n    throw new DeserializationError(`Could not parse ${n} as AddressHashMode`);\n  });\n\n  if (hashMode === AddressHashMode.SerializeP2PKH || hashMode === AddressHashMode.SerializeP2WPKH) {\n    return deserializeSingleSigSpendingCondition(hashMode, bufferReader);\n  } else {\n    return deserializeMultiSigSpendingCondition(hashMode, bufferReader);\n  }\n}\nexport function makeSigHashPreSign(curSigHash, authType, fee, nonce) {\n  const hashLength = 32 + 1 + 8 + 8;\n  const sigHash = curSigHash + Buffer.from([authType]).toString('hex') + intToBytes(fee, false, 8).toString('hex') + intToBytes(nonce, false, 8).toString('hex');\n\n  if (Buffer.from(sigHash, 'hex').byteLength !== hashLength) {\n    throw Error('Invalid signature hash length');\n  }\n\n  return txidFromData(Buffer.from(sigHash, 'hex'));\n}\n\nfunction makeSigHashPostSign(curSigHash, pubKey, signature) {\n  const hashLength = 32 + 1 + RECOVERABLE_ECDSA_SIG_LENGTH_BYTES;\n  const pubKeyEncoding = isCompressed(pubKey) ? PubKeyEncoding.Compressed : PubKeyEncoding.Uncompressed;\n  const sigHash = curSigHash + leftPadHex(pubKeyEncoding.toString(16)) + signature.data;\n  const sigHashBuffer = Buffer.from(sigHash, 'hex');\n\n  if (sigHashBuffer.byteLength > hashLength) {\n    throw Error('Invalid signature hash length');\n  }\n\n  return txidFromData(sigHashBuffer);\n}\n\nexport function nextSignature(curSigHash, authType, fee, nonce, privateKey) {\n  const sigHashPreSign = makeSigHashPreSign(curSigHash, authType, fee, nonce);\n  const signature = signWithKey(privateKey, sigHashPreSign);\n  const publicKey = getPublicKey(privateKey);\n  const nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);\n  return {\n    nextSig: signature,\n    nextSigHash\n  };\n}\nexport function nextVerification(initialSigHash, authType, fee, nonce, pubKeyEncoding, signature) {\n  const sigHashPreSign = makeSigHashPreSign(initialSigHash, authType, fee, nonce);\n  const publicKey = createStacksPublicKey(publicKeyFromSignature(sigHashPreSign, signature, pubKeyEncoding));\n  const nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);\n  return {\n    pubKey: publicKey,\n    nextSigHash\n  };\n}\n\nfunction newInitialSigHash() {\n  const spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, '', 0, 0);\n  spendingCondition.signer = createEmptyAddress().hash160;\n  spendingCondition.keyEncoding = PubKeyEncoding.Compressed;\n  spendingCondition.signature = emptyMessageSignature();\n  return spendingCondition;\n}\n\nfunction verify(condition, initialSigHash, authType) {\n  if (isSingleSig(condition)) {\n    return verifySingleSig(condition, initialSigHash, authType);\n  } else {\n    return '';\n  }\n}\n\nfunction verifySingleSig(condition, initialSigHash, authType) {\n  const {\n    nextSigHash\n  } = nextVerification(initialSigHash, authType, condition.fee, condition.nonce, condition.keyEncoding, condition.signature);\n  return nextSigHash;\n}\n\nexport class Authorization extends Deserializable {\n  constructor(authType, spendingConditions, sponsorSpendingCondition) {\n    super();\n    this.authType = authType;\n\n    if (spendingConditions) {\n      this.spendingCondition = Object.assign(Object.assign({}, spendingConditions), {\n        nonce: intToBigInt(spendingConditions.nonce, false),\n        fee: intToBigInt(spendingConditions.fee, false)\n      });\n    }\n\n    if (sponsorSpendingCondition) {\n      this.sponsorSpendingCondition = Object.assign(Object.assign({}, sponsorSpendingCondition), {\n        nonce: intToBigInt(sponsorSpendingCondition.nonce, false),\n        fee: intToBigInt(sponsorSpendingCondition.fee, false)\n      });\n    }\n  }\n\n  intoInitialSighashAuth() {\n    if (this.spendingCondition) {\n      switch (this.authType) {\n        case AuthType.Standard:\n          return new Authorization(AuthType.Standard, clearCondition(this.spendingCondition));\n\n        case AuthType.Sponsored:\n          return new Authorization(AuthType.Sponsored, clearCondition(this.spendingCondition), newInitialSigHash());\n\n        default:\n          throw new SigningError('Unexpected authorization type for signing');\n      }\n    }\n\n    throw new Error('Authorization missing SpendingCondition');\n  }\n\n  setFee(amount) {\n    switch (this.authType) {\n      case AuthType.Standard:\n        this.spendingCondition.fee = intToBigInt(amount, false);\n        break;\n\n      case AuthType.Sponsored:\n        this.sponsorSpendingCondition.fee = intToBigInt(amount, false);\n        break;\n    }\n  }\n\n  getFee() {\n    switch (this.authType) {\n      case AuthType.Standard:\n        return this.spendingCondition.fee;\n\n      case AuthType.Sponsored:\n        return this.sponsorSpendingCondition.fee;\n\n      default:\n        return BigInt(0);\n    }\n  }\n\n  setNonce(nonce) {\n    this.spendingCondition.nonce = intToBigInt(nonce, false);\n  }\n\n  setSponsorNonce(nonce) {\n    this.sponsorSpendingCondition.nonce = intToBigInt(nonce, false);\n  }\n\n  setSponsor(sponsorSpendingCondition) {\n    this.sponsorSpendingCondition = Object.assign(Object.assign({}, sponsorSpendingCondition), {\n      nonce: intToBigInt(sponsorSpendingCondition.nonce, false),\n      fee: intToBigInt(sponsorSpendingCondition.fee, false)\n    });\n  }\n\n  verifyOrigin(initialSigHash) {\n    switch (this.authType) {\n      case AuthType.Standard:\n        return verify(this.spendingCondition, initialSigHash, AuthType.Standard);\n\n      case AuthType.Sponsored:\n        return verify(this.spendingCondition, initialSigHash, AuthType.Standard);\n\n      default:\n        throw new SigningError('Invalid origin auth type');\n    }\n  }\n\n  serialize() {\n    const bufferArray = new BufferArray();\n\n    if (this.authType === undefined) {\n      throw new SerializationError('\"authType\" is undefined');\n    }\n\n    bufferArray.appendByte(this.authType);\n\n    switch (this.authType) {\n      case AuthType.Standard:\n        if (this.spendingCondition === undefined) {\n          throw new SerializationError('\"spendingCondition\" is undefined');\n        }\n\n        bufferArray.push(serializeSpendingCondition(this.spendingCondition));\n        break;\n\n      case AuthType.Sponsored:\n        if (this.spendingCondition === undefined) {\n          throw new SerializationError('\"spendingCondition\" is undefined');\n        }\n\n        if (this.sponsorSpendingCondition === undefined) {\n          throw new SerializationError('\"spendingCondition\" is undefined');\n        }\n\n        bufferArray.push(serializeSpendingCondition(this.spendingCondition));\n        bufferArray.push(serializeSpendingCondition(this.sponsorSpendingCondition));\n        break;\n\n      default:\n        throw new SerializationError(`Unexpected transaction AuthType while serializing: ${JSON.stringify(this.authType)}`);\n    }\n\n    return bufferArray.concatBuffer();\n  }\n\n  deserialize(bufferReader) {\n    this.authType = bufferReader.readUInt8Enum(AuthType, n => {\n      throw new DeserializationError(`Could not parse ${n} as AuthType`);\n    });\n\n    switch (this.authType) {\n      case AuthType.Standard:\n        this.spendingCondition = deserializeSpendingCondition(bufferReader);\n        break;\n\n      case AuthType.Sponsored:\n        this.spendingCondition = deserializeSpendingCondition(bufferReader);\n        this.sponsorSpendingCondition = deserializeSpendingCondition(bufferReader);\n        break;\n\n      default:\n        throw new DeserializationError(`Unexpected transaction AuthType while deserializing: ${JSON.stringify(this.authType)}`);\n    }\n  }\n\n}\nexport class StandardAuthorization extends Authorization {\n  constructor(spendingCondition) {\n    super(AuthType.Standard, spendingCondition);\n  }\n\n}\nexport class SponsoredAuthorization extends Authorization {\n  constructor(originSpendingCondition, sponsorSpendingCondition) {\n    let sponsorSC = sponsorSpendingCondition;\n\n    if (!sponsorSC) {\n      sponsorSC = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, '0'.repeat(66), 0, 0);\n    }\n\n    super(AuthType.Sponsored, originSpendingCondition, sponsorSC);\n  }\n\n}","map":{"version":3,"sources":["../../src/authorization.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Buffer, intToBigInt, intToBytes } from '@stacks/common';\nimport { AddressHashMode, AuthType, PubKeyEncoding, RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, StacksMessageType, } from './constants';\nimport { BufferArray, cloneDeep, leftPadHex, txidFromData } from './utils';\nimport { addressFromPublicKeys, createEmptyAddress, createLPList, deserializeLPList, serializeLPList, } from './types';\nimport { compressPublicKey, createStacksPublicKey, deserializePublicKey, getPublicKey, isCompressed, publicKeyFromSignature, serializePublicKey, signWithKey, } from './keys';\nimport { DeserializationError, SerializationError, SigningError } from './errors';\nclass Deserializable {\n    static deserialize(bufferReader) {\n        const message = new this();\n        message.deserialize(bufferReader);\n        return message;\n    }\n}\nexport function createMessageSignature(signature) {\n    const length = Buffer.from(signature, 'hex').byteLength;\n    if (length != RECOVERABLE_ECDSA_SIG_LENGTH_BYTES) {\n        throw Error('Invalid signature');\n    }\n    return {\n        type: StacksMessageType.MessageSignature,\n        data: signature,\n    };\n}\nexport function emptyMessageSignature() {\n    return {\n        type: StacksMessageType.MessageSignature,\n        data: Buffer.alloc(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, 0x00).toString('hex'),\n    };\n}\nexport function serializeMessageSignature(messageSignature) {\n    const bufferArray = new BufferArray();\n    bufferArray.appendHexString(messageSignature.data);\n    return bufferArray.concatBuffer();\n}\nexport function deserializeMessageSignature(bufferReader) {\n    return createMessageSignature(bufferReader.readBuffer(RECOVERABLE_ECDSA_SIG_LENGTH_BYTES).toString('hex'));\n}\nvar AuthFieldType;\n(function (AuthFieldType) {\n    AuthFieldType[AuthFieldType[\"PublicKeyCompressed\"] = 0] = \"PublicKeyCompressed\";\n    AuthFieldType[AuthFieldType[\"PublicKeyUncompressed\"] = 1] = \"PublicKeyUncompressed\";\n    AuthFieldType[AuthFieldType[\"SignatureCompressed\"] = 2] = \"SignatureCompressed\";\n    AuthFieldType[AuthFieldType[\"SignatureUncompressed\"] = 3] = \"SignatureUncompressed\";\n})(AuthFieldType || (AuthFieldType = {}));\nexport function createTransactionAuthField(pubKeyEncoding, contents) {\n    return {\n        pubKeyEncoding,\n        type: StacksMessageType.TransactionAuthField,\n        contents,\n    };\n}\nexport function serializeTransactionAuthField(field) {\n    const bufferArray = new BufferArray();\n    switch (field.contents.type) {\n        case StacksMessageType.PublicKey:\n            if (field.pubKeyEncoding == PubKeyEncoding.Compressed) {\n                bufferArray.appendByte(AuthFieldType.PublicKeyCompressed);\n                bufferArray.push(serializePublicKey(field.contents));\n            }\n            else {\n                bufferArray.appendByte(AuthFieldType.PublicKeyUncompressed);\n                bufferArray.push(serializePublicKey(compressPublicKey(field.contents.data)));\n            }\n            break;\n        case StacksMessageType.MessageSignature:\n            if (field.pubKeyEncoding == PubKeyEncoding.Compressed) {\n                bufferArray.appendByte(AuthFieldType.SignatureCompressed);\n            }\n            else {\n                bufferArray.appendByte(AuthFieldType.SignatureUncompressed);\n            }\n            bufferArray.push(serializeMessageSignature(field.contents));\n            break;\n    }\n    return bufferArray.concatBuffer();\n}\nexport function deserializeTransactionAuthField(bufferReader) {\n    const authFieldType = bufferReader.readUInt8Enum(AuthFieldType, n => {\n        throw new DeserializationError(`Could not read ${n} as AuthFieldType`);\n    });\n    switch (authFieldType) {\n        case AuthFieldType.PublicKeyCompressed:\n            return createTransactionAuthField(PubKeyEncoding.Compressed, deserializePublicKey(bufferReader));\n        case AuthFieldType.PublicKeyUncompressed:\n            return createTransactionAuthField(PubKeyEncoding.Uncompressed, deserializePublicKey(bufferReader));\n        case AuthFieldType.SignatureCompressed:\n            return createTransactionAuthField(PubKeyEncoding.Compressed, deserializeMessageSignature(bufferReader));\n        case AuthFieldType.SignatureUncompressed:\n            return createTransactionAuthField(PubKeyEncoding.Uncompressed, deserializeMessageSignature(bufferReader));\n        default:\n            throw new Error(`Unknown auth field type: ${JSON.stringify(authFieldType)}`);\n    }\n}\nexport function createSingleSigSpendingCondition(hashMode, pubKey, nonce, fee) {\n    const signer = addressFromPublicKeys(0, hashMode, 1, [createStacksPublicKey(pubKey)]).hash160;\n    const keyEncoding = isCompressed(createStacksPublicKey(pubKey))\n        ? PubKeyEncoding.Compressed\n        : PubKeyEncoding.Uncompressed;\n    return {\n        hashMode,\n        signer,\n        nonce: intToBigInt(nonce, false),\n        fee: intToBigInt(fee, false),\n        keyEncoding,\n        signature: emptyMessageSignature(),\n    };\n}\nexport function createMultiSigSpendingCondition(hashMode, numSigs, pubKeys, nonce, fee) {\n    const stacksPublicKeys = pubKeys.map(createStacksPublicKey);\n    const signer = addressFromPublicKeys(0, hashMode, numSigs, stacksPublicKeys).hash160;\n    return {\n        hashMode,\n        signer,\n        nonce: intToBigInt(nonce, false),\n        fee: intToBigInt(fee, false),\n        fields: [],\n        signaturesRequired: numSigs,\n    };\n}\nexport function isSingleSig(condition) {\n    return 'signature' in condition;\n}\nfunction clearCondition(condition) {\n    const cloned = cloneDeep(condition);\n    cloned.nonce = 0;\n    cloned.fee = 0;\n    if (isSingleSig(cloned)) {\n        cloned.signature = emptyMessageSignature();\n    }\n    else {\n        cloned.fields = [];\n    }\n    return Object.assign(Object.assign({}, cloned), { nonce: BigInt(0), fee: BigInt(0) });\n}\nexport function serializeSingleSigSpendingCondition(condition) {\n    const bufferArray = new BufferArray();\n    bufferArray.appendByte(condition.hashMode);\n    bufferArray.appendHexString(condition.signer);\n    bufferArray.push(intToBytes(condition.nonce, false, 8));\n    bufferArray.push(intToBytes(condition.fee, false, 8));\n    bufferArray.appendByte(condition.keyEncoding);\n    bufferArray.push(serializeMessageSignature(condition.signature));\n    return bufferArray.concatBuffer();\n}\nexport function serializeMultiSigSpendingCondition(condition) {\n    const bufferArray = new BufferArray();\n    bufferArray.appendByte(condition.hashMode);\n    bufferArray.appendHexString(condition.signer);\n    bufferArray.push(intToBytes(condition.nonce, false, 8));\n    bufferArray.push(intToBytes(condition.fee, false, 8));\n    const fields = createLPList(condition.fields);\n    bufferArray.push(serializeLPList(fields));\n    const numSigs = Buffer.alloc(2);\n    numSigs.writeUInt16BE(condition.signaturesRequired, 0);\n    bufferArray.push(numSigs);\n    return bufferArray.concatBuffer();\n}\nexport function deserializeSingleSigSpendingCondition(hashMode, bufferReader) {\n    const signer = bufferReader.readBuffer(20).toString('hex');\n    const nonce = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n    const fee = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n    const keyEncoding = bufferReader.readUInt8Enum(PubKeyEncoding, n => {\n        throw new DeserializationError(`Could not parse ${n} as PubKeyEncoding`);\n    });\n    const signature = deserializeMessageSignature(bufferReader);\n    return {\n        hashMode,\n        signer,\n        nonce,\n        fee,\n        keyEncoding,\n        signature,\n    };\n}\nexport function deserializeMultiSigSpendingCondition(hashMode, bufferReader) {\n    const signer = bufferReader.readBuffer(20).toString('hex');\n    const nonce = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n    const fee = BigInt('0x' + bufferReader.readBuffer(8).toString('hex'));\n    const fields = deserializeLPList(bufferReader, StacksMessageType.TransactionAuthField)\n        .values;\n    const signaturesRequired = bufferReader.readUInt16BE();\n    return {\n        hashMode,\n        signer,\n        nonce,\n        fee,\n        fields,\n        signaturesRequired,\n    };\n}\nexport function serializeSpendingCondition(condition) {\n    if (isSingleSig(condition)) {\n        return serializeSingleSigSpendingCondition(condition);\n    }\n    else {\n        return serializeMultiSigSpendingCondition(condition);\n    }\n}\nexport function deserializeSpendingCondition(bufferReader) {\n    const hashMode = bufferReader.readUInt8Enum(AddressHashMode, n => {\n        throw new DeserializationError(`Could not parse ${n} as AddressHashMode`);\n    });\n    if (hashMode === AddressHashMode.SerializeP2PKH || hashMode === AddressHashMode.SerializeP2WPKH) {\n        return deserializeSingleSigSpendingCondition(hashMode, bufferReader);\n    }\n    else {\n        return deserializeMultiSigSpendingCondition(hashMode, bufferReader);\n    }\n}\nexport function makeSigHashPreSign(curSigHash, authType, fee, nonce) {\n    const hashLength = 32 + 1 + 8 + 8;\n    const sigHash = curSigHash +\n        Buffer.from([authType]).toString('hex') +\n        intToBytes(fee, false, 8).toString('hex') +\n        intToBytes(nonce, false, 8).toString('hex');\n    if (Buffer.from(sigHash, 'hex').byteLength !== hashLength) {\n        throw Error('Invalid signature hash length');\n    }\n    return txidFromData(Buffer.from(sigHash, 'hex'));\n}\nfunction makeSigHashPostSign(curSigHash, pubKey, signature) {\n    const hashLength = 32 + 1 + RECOVERABLE_ECDSA_SIG_LENGTH_BYTES;\n    const pubKeyEncoding = isCompressed(pubKey)\n        ? PubKeyEncoding.Compressed\n        : PubKeyEncoding.Uncompressed;\n    const sigHash = curSigHash + leftPadHex(pubKeyEncoding.toString(16)) + signature.data;\n    const sigHashBuffer = Buffer.from(sigHash, 'hex');\n    if (sigHashBuffer.byteLength > hashLength) {\n        throw Error('Invalid signature hash length');\n    }\n    return txidFromData(sigHashBuffer);\n}\nexport function nextSignature(curSigHash, authType, fee, nonce, privateKey) {\n    const sigHashPreSign = makeSigHashPreSign(curSigHash, authType, fee, nonce);\n    const signature = signWithKey(privateKey, sigHashPreSign);\n    const publicKey = getPublicKey(privateKey);\n    const nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);\n    return {\n        nextSig: signature,\n        nextSigHash,\n    };\n}\nexport function nextVerification(initialSigHash, authType, fee, nonce, pubKeyEncoding, signature) {\n    const sigHashPreSign = makeSigHashPreSign(initialSigHash, authType, fee, nonce);\n    const publicKey = createStacksPublicKey(publicKeyFromSignature(sigHashPreSign, signature, pubKeyEncoding));\n    const nextSigHash = makeSigHashPostSign(sigHashPreSign, publicKey, signature);\n    return {\n        pubKey: publicKey,\n        nextSigHash,\n    };\n}\nfunction newInitialSigHash() {\n    const spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, '', 0, 0);\n    spendingCondition.signer = createEmptyAddress().hash160;\n    spendingCondition.keyEncoding = PubKeyEncoding.Compressed;\n    spendingCondition.signature = emptyMessageSignature();\n    return spendingCondition;\n}\nfunction verify(condition, initialSigHash, authType) {\n    if (isSingleSig(condition)) {\n        return verifySingleSig(condition, initialSigHash, authType);\n    }\n    else {\n        return '';\n    }\n}\nfunction verifySingleSig(condition, initialSigHash, authType) {\n    const { nextSigHash } = nextVerification(initialSigHash, authType, condition.fee, condition.nonce, condition.keyEncoding, condition.signature);\n    return nextSigHash;\n}\nexport class Authorization extends Deserializable {\n    constructor(authType, spendingConditions, sponsorSpendingCondition) {\n        super();\n        this.authType = authType;\n        if (spendingConditions) {\n            this.spendingCondition = Object.assign(Object.assign({}, spendingConditions), { nonce: intToBigInt(spendingConditions.nonce, false), fee: intToBigInt(spendingConditions.fee, false) });\n        }\n        if (sponsorSpendingCondition) {\n            this.sponsorSpendingCondition = Object.assign(Object.assign({}, sponsorSpendingCondition), { nonce: intToBigInt(sponsorSpendingCondition.nonce, false), fee: intToBigInt(sponsorSpendingCondition.fee, false) });\n        }\n    }\n    intoInitialSighashAuth() {\n        if (this.spendingCondition) {\n            switch (this.authType) {\n                case AuthType.Standard:\n                    return new Authorization(AuthType.Standard, clearCondition(this.spendingCondition));\n                case AuthType.Sponsored:\n                    return new Authorization(AuthType.Sponsored, clearCondition(this.spendingCondition), newInitialSigHash());\n                default:\n                    throw new SigningError('Unexpected authorization type for signing');\n            }\n        }\n        throw new Error('Authorization missing SpendingCondition');\n    }\n    setFee(amount) {\n        switch (this.authType) {\n            case AuthType.Standard:\n                this.spendingCondition.fee = intToBigInt(amount, false);\n                break;\n            case AuthType.Sponsored:\n                this.sponsorSpendingCondition.fee = intToBigInt(amount, false);\n                break;\n        }\n    }\n    getFee() {\n        switch (this.authType) {\n            case AuthType.Standard:\n                return this.spendingCondition.fee;\n            case AuthType.Sponsored:\n                return this.sponsorSpendingCondition.fee;\n            default:\n                return BigInt(0);\n        }\n    }\n    setNonce(nonce) {\n        this.spendingCondition.nonce = intToBigInt(nonce, false);\n    }\n    setSponsorNonce(nonce) {\n        this.sponsorSpendingCondition.nonce = intToBigInt(nonce, false);\n    }\n    setSponsor(sponsorSpendingCondition) {\n        this.sponsorSpendingCondition = Object.assign(Object.assign({}, sponsorSpendingCondition), { nonce: intToBigInt(sponsorSpendingCondition.nonce, false), fee: intToBigInt(sponsorSpendingCondition.fee, false) });\n    }\n    verifyOrigin(initialSigHash) {\n        switch (this.authType) {\n            case AuthType.Standard:\n                return verify(this.spendingCondition, initialSigHash, AuthType.Standard);\n            case AuthType.Sponsored:\n                return verify(this.spendingCondition, initialSigHash, AuthType.Standard);\n            default:\n                throw new SigningError('Invalid origin auth type');\n        }\n    }\n    serialize() {\n        const bufferArray = new BufferArray();\n        if (this.authType === undefined) {\n            throw new SerializationError('\"authType\" is undefined');\n        }\n        bufferArray.appendByte(this.authType);\n        switch (this.authType) {\n            case AuthType.Standard:\n                if (this.spendingCondition === undefined) {\n                    throw new SerializationError('\"spendingCondition\" is undefined');\n                }\n                bufferArray.push(serializeSpendingCondition(this.spendingCondition));\n                break;\n            case AuthType.Sponsored:\n                if (this.spendingCondition === undefined) {\n                    throw new SerializationError('\"spendingCondition\" is undefined');\n                }\n                if (this.sponsorSpendingCondition === undefined) {\n                    throw new SerializationError('\"spendingCondition\" is undefined');\n                }\n                bufferArray.push(serializeSpendingCondition(this.spendingCondition));\n                bufferArray.push(serializeSpendingCondition(this.sponsorSpendingCondition));\n                break;\n            default:\n                throw new SerializationError(`Unexpected transaction AuthType while serializing: ${JSON.stringify(this.authType)}`);\n        }\n        return bufferArray.concatBuffer();\n    }\n    deserialize(bufferReader) {\n        this.authType = bufferReader.readUInt8Enum(AuthType, n => {\n            throw new DeserializationError(`Could not parse ${n} as AuthType`);\n        });\n        switch (this.authType) {\n            case AuthType.Standard:\n                this.spendingCondition = deserializeSpendingCondition(bufferReader);\n                break;\n            case AuthType.Sponsored:\n                this.spendingCondition = deserializeSpendingCondition(bufferReader);\n                this.sponsorSpendingCondition = deserializeSpendingCondition(bufferReader);\n                break;\n            default:\n                throw new DeserializationError(`Unexpected transaction AuthType while deserializing: ${JSON.stringify(this.authType)}`);\n        }\n    }\n}\nexport class StandardAuthorization extends Authorization {\n    constructor(spendingCondition) {\n        super(AuthType.Standard, spendingCondition);\n    }\n}\nexport class SponsoredAuthorization extends Authorization {\n    constructor(originSpendingCondition, sponsorSpendingCondition) {\n        let sponsorSC = sponsorSpendingCondition;\n        if (!sponsorSC) {\n            sponsorSC = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, '0'.repeat(66), 0, 0);\n        }\n        super(AuthType.Sponsored, originSpendingCondition, sponsorSC);\n    }\n}\n//# sourceMappingURL=authorization.js.map"]},"metadata":{},"sourceType":"module"}