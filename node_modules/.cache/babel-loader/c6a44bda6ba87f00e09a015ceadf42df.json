{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.c32ToB58 = exports.b58ToC32 = exports.c32addressDecode = exports.c32address = exports.versions = void 0;\n\nvar checksum_1 = require(\"./checksum\");\n\nvar base58check = require(\"./base58check\");\n\nexports.versions = {\n  mainnet: {\n    p2pkh: 22,\n    p2sh: 20 // 'M'\n\n  },\n  testnet: {\n    p2pkh: 26,\n    p2sh: 21 // 'N'\n\n  }\n}; // address conversion : bitcoin to stacks\n\nvar ADDR_BITCOIN_TO_STACKS = {};\nADDR_BITCOIN_TO_STACKS[0] = exports.versions.mainnet.p2pkh;\nADDR_BITCOIN_TO_STACKS[5] = exports.versions.mainnet.p2sh;\nADDR_BITCOIN_TO_STACKS[111] = exports.versions.testnet.p2pkh;\nADDR_BITCOIN_TO_STACKS[196] = exports.versions.testnet.p2sh; // address conversion : stacks to bitcoin \n\nvar ADDR_STACKS_TO_BITCOIN = {};\nADDR_STACKS_TO_BITCOIN[exports.versions.mainnet.p2pkh] = 0;\nADDR_STACKS_TO_BITCOIN[exports.versions.mainnet.p2sh] = 5;\nADDR_STACKS_TO_BITCOIN[exports.versions.testnet.p2pkh] = 111;\nADDR_STACKS_TO_BITCOIN[exports.versions.testnet.p2sh] = 196;\n/**\n * Make a c32check address with the given version and hash160\n * The only difference between a c32check string and c32 address\n * is that the letter 'S' is pre-pended.\n * @param {number} version - the address version number\n * @param {string} hash160hex - the hash160 to encode (must be a hash160)\n * @returns {string} the address\n */\n\nfunction c32address(version, hash160hex) {\n  if (!hash160hex.match(/^[0-9a-fA-F]{40}$/)) {\n    throw new Error('Invalid argument: not a hash160 hex string');\n  }\n\n  var c32string = checksum_1.c32checkEncode(version, hash160hex);\n  return \"S\" + c32string;\n}\n\nexports.c32address = c32address;\n/**\n * Decode a c32 address into its version and hash160\n * @param {string} c32addr - the c32check-encoded address\n * @returns {[number, string]} a tuple with the version and hash160\n */\n\nfunction c32addressDecode(c32addr) {\n  if (c32addr.length <= 5) {\n    throw new Error('Invalid c32 address: invalid length');\n  }\n\n  return checksum_1.c32checkDecode(c32addr.slice(1));\n}\n\nexports.c32addressDecode = c32addressDecode;\n/*\n * Convert a base58check address to a c32check address.\n * Try to convert the version number if one is not given.\n * @param {string} b58check - the base58check encoded address\n * @param {number} version - the version number, if not inferred from the address\n * @returns {string} the c32 address with the given version number (or the\n *   semantically-equivalent c32 version number, if not given)\n */\n\nfunction b58ToC32(b58check, version) {\n  if (version === void 0) {\n    version = -1;\n  }\n\n  var addrInfo = base58check.decode(b58check);\n  var hash160String = addrInfo.data.toString('hex');\n  var addrVersion = parseInt(addrInfo.prefix.toString('hex'), 16);\n  var stacksVersion;\n\n  if (version < 0) {\n    stacksVersion = addrVersion;\n\n    if (ADDR_BITCOIN_TO_STACKS[addrVersion] !== undefined) {\n      stacksVersion = ADDR_BITCOIN_TO_STACKS[addrVersion];\n    }\n  } else {\n    stacksVersion = version;\n  }\n\n  return c32address(stacksVersion, hash160String);\n}\n\nexports.b58ToC32 = b58ToC32;\n/*\n * Convert a c32check address to a base58check address.\n * @param {string} c32string - the c32check address\n * @param {number} version - the version number, if not inferred from the address\n * @returns {string} the base58 address with the given version number (or the\n *    semantically-equivalent bitcoin version number, if not given)\n */\n\nfunction c32ToB58(c32string, version) {\n  if (version === void 0) {\n    version = -1;\n  }\n\n  var addrInfo = c32addressDecode(c32string);\n  var stacksVersion = addrInfo[0];\n  var hash160String = addrInfo[1];\n  var bitcoinVersion;\n\n  if (version < 0) {\n    bitcoinVersion = stacksVersion;\n\n    if (ADDR_STACKS_TO_BITCOIN[stacksVersion] !== undefined) {\n      bitcoinVersion = ADDR_STACKS_TO_BITCOIN[stacksVersion];\n    }\n  } else {\n    bitcoinVersion = version;\n  }\n\n  var prefix = bitcoinVersion.toString(16);\n\n  if (prefix.length === 1) {\n    prefix = \"0\" + prefix;\n  }\n\n  return base58check.encode(hash160String, prefix);\n}\n\nexports.c32ToB58 = c32ToB58;","map":{"version":3,"sources":["/Users/abdulhaseeb/Work/connectapp/my-app/node_modules/c32check/lib/address.js"],"names":["Object","defineProperty","exports","value","c32ToB58","b58ToC32","c32addressDecode","c32address","versions","checksum_1","require","base58check","mainnet","p2pkh","p2sh","testnet","ADDR_BITCOIN_TO_STACKS","ADDR_STACKS_TO_BITCOIN","version","hash160hex","match","Error","c32string","c32checkEncode","c32addr","length","c32checkDecode","slice","b58check","addrInfo","decode","hash160String","data","toString","addrVersion","parseInt","prefix","stacksVersion","undefined","bitcoinVersion","encode"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.c32ToB58 = exports.b58ToC32 = exports.c32addressDecode = exports.c32address = exports.versions = void 0;\nvar checksum_1 = require(\"./checksum\");\nvar base58check = require(\"./base58check\");\nexports.versions = {\n    mainnet: {\n        p2pkh: 22,\n        p2sh: 20 // 'M'\n    },\n    testnet: {\n        p2pkh: 26,\n        p2sh: 21 // 'N'\n    }\n};\n// address conversion : bitcoin to stacks\nvar ADDR_BITCOIN_TO_STACKS = {};\nADDR_BITCOIN_TO_STACKS[0] = exports.versions.mainnet.p2pkh;\nADDR_BITCOIN_TO_STACKS[5] = exports.versions.mainnet.p2sh;\nADDR_BITCOIN_TO_STACKS[111] = exports.versions.testnet.p2pkh;\nADDR_BITCOIN_TO_STACKS[196] = exports.versions.testnet.p2sh;\n// address conversion : stacks to bitcoin \nvar ADDR_STACKS_TO_BITCOIN = {};\nADDR_STACKS_TO_BITCOIN[exports.versions.mainnet.p2pkh] = 0;\nADDR_STACKS_TO_BITCOIN[exports.versions.mainnet.p2sh] = 5;\nADDR_STACKS_TO_BITCOIN[exports.versions.testnet.p2pkh] = 111;\nADDR_STACKS_TO_BITCOIN[exports.versions.testnet.p2sh] = 196;\n/**\n * Make a c32check address with the given version and hash160\n * The only difference between a c32check string and c32 address\n * is that the letter 'S' is pre-pended.\n * @param {number} version - the address version number\n * @param {string} hash160hex - the hash160 to encode (must be a hash160)\n * @returns {string} the address\n */\nfunction c32address(version, hash160hex) {\n    if (!hash160hex.match(/^[0-9a-fA-F]{40}$/)) {\n        throw new Error('Invalid argument: not a hash160 hex string');\n    }\n    var c32string = checksum_1.c32checkEncode(version, hash160hex);\n    return \"S\" + c32string;\n}\nexports.c32address = c32address;\n/**\n * Decode a c32 address into its version and hash160\n * @param {string} c32addr - the c32check-encoded address\n * @returns {[number, string]} a tuple with the version and hash160\n */\nfunction c32addressDecode(c32addr) {\n    if (c32addr.length <= 5) {\n        throw new Error('Invalid c32 address: invalid length');\n    }\n    return checksum_1.c32checkDecode(c32addr.slice(1));\n}\nexports.c32addressDecode = c32addressDecode;\n/*\n * Convert a base58check address to a c32check address.\n * Try to convert the version number if one is not given.\n * @param {string} b58check - the base58check encoded address\n * @param {number} version - the version number, if not inferred from the address\n * @returns {string} the c32 address with the given version number (or the\n *   semantically-equivalent c32 version number, if not given)\n */\nfunction b58ToC32(b58check, version) {\n    if (version === void 0) { version = -1; }\n    var addrInfo = base58check.decode(b58check);\n    var hash160String = addrInfo.data.toString('hex');\n    var addrVersion = parseInt(addrInfo.prefix.toString('hex'), 16);\n    var stacksVersion;\n    if (version < 0) {\n        stacksVersion = addrVersion;\n        if (ADDR_BITCOIN_TO_STACKS[addrVersion] !== undefined) {\n            stacksVersion = ADDR_BITCOIN_TO_STACKS[addrVersion];\n        }\n    }\n    else {\n        stacksVersion = version;\n    }\n    return c32address(stacksVersion, hash160String);\n}\nexports.b58ToC32 = b58ToC32;\n/*\n * Convert a c32check address to a base58check address.\n * @param {string} c32string - the c32check address\n * @param {number} version - the version number, if not inferred from the address\n * @returns {string} the base58 address with the given version number (or the\n *    semantically-equivalent bitcoin version number, if not given)\n */\nfunction c32ToB58(c32string, version) {\n    if (version === void 0) { version = -1; }\n    var addrInfo = c32addressDecode(c32string);\n    var stacksVersion = addrInfo[0];\n    var hash160String = addrInfo[1];\n    var bitcoinVersion;\n    if (version < 0) {\n        bitcoinVersion = stacksVersion;\n        if (ADDR_STACKS_TO_BITCOIN[stacksVersion] !== undefined) {\n            bitcoinVersion = ADDR_STACKS_TO_BITCOIN[stacksVersion];\n        }\n    }\n    else {\n        bitcoinVersion = version;\n    }\n    var prefix = bitcoinVersion.toString(16);\n    if (prefix.length === 1) {\n        prefix = \"0\" + prefix;\n    }\n    return base58check.encode(hash160String, prefix);\n}\nexports.c32ToB58 = c32ToB58;\n"]},"metadata":{},"sourceType":"script"}